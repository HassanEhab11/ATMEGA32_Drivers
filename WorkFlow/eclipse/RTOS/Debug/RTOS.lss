
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000469a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000022  00800060  0000469a  0000472e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000561  00800082  00800082  00004750  2**0
                  ALLOC
  3 .stab         000059ac  00000000  00000000  00004750  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002fc6  00000000  00000000  0000a0fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000d0c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000d202  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000d372  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000efbb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000fea6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00010c54  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00010db4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00011041  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001180f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 2a 17 	jmp	0x2e54	; 0x2e54 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e9       	ldi	r30, 0x9A	; 154
      68:	f6 e4       	ldi	r31, 0x46	; 70
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3e       	cpi	r26, 0xE3	; 227
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ff 13 	call	0x27fe	; 0x27fe <main>
      8a:	0c 94 4b 23 	jmp	0x4696	; 0x4696 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 f5 22 	jmp	0x45ea	; 0x45ea <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a7 e7       	ldi	r26, 0x77	; 119
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 11 23 	jmp	0x4622	; 0x4622 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 01 23 	jmp	0x4602	; 0x4602 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 1d 23 	jmp	0x463a	; 0x463a <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 01 23 	jmp	0x4602	; 0x4602 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 1d 23 	jmp	0x463a	; 0x463a <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 f5 22 	jmp	0x45ea	; 0x45ea <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	87 e7       	ldi	r24, 0x77	; 119
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 11 23 	jmp	0x4622	; 0x4622 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 01 23 	jmp	0x4602	; 0x4602 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 1d 23 	jmp	0x463a	; 0x463a <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 01 23 	jmp	0x4602	; 0x4602 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 1d 23 	jmp	0x463a	; 0x463a <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 01 23 	jmp	0x4602	; 0x4602 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 1d 23 	jmp	0x463a	; 0x463a <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 05 23 	jmp	0x460a	; 0x460a <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 21 23 	jmp	0x4642	; 0x4642 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <C_LCD_voidSendCommand>:

#include "CLCD_private.h"


void C_LCD_voidSendCommand(u8 Copy_u8Command)
{
     b46:	1f 93       	push	r17
     b48:	df 93       	push	r29
     b4a:	cf 93       	push	r28
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	ea 97       	sbiw	r28, 0x3a	; 58
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	f8 94       	cli
     b56:	de bf       	out	0x3e, r29	; 62
     b58:	0f be       	out	0x3f, r0	; 63
     b5a:	cd bf       	out	0x3d, r28	; 61
     b5c:	8a af       	std	Y+58, r24	; 0x3a
	/*Set RS Pin to low to send command */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_RS_PIN,DIO_u8PIN_LOW);
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	61 e0       	ldi	r22, 0x01	; 1
     b62:	40 e0       	ldi	r20, 0x00	; 0
     b64:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);

#elif   MODE_SELECT ==_4_BIT_MODE

	u8 Local_u8Command = (((Copy_u8Command >> 1) & 0b01111000) | DIO_u8AndWithPort(CLCD_DATA_PORT, 0b10000111));
     b68:	8a ad       	ldd	r24, Y+58	; 0x3a
     b6a:	86 95       	lsr	r24
     b6c:	18 2f       	mov	r17, r24
     b6e:	18 77       	andi	r17, 0x78	; 120
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	67 e8       	ldi	r22, 0x87	; 135
     b74:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <DIO_u8AndWithPort>
     b78:	81 2b       	or	r24, r17
     b7a:	89 af       	std	Y+57, r24	; 0x39
	/* Set Command to data pins */
	DIO_u8SetPortValue(CLCD_DATA_PORT,Local_u8Command);
     b7c:	80 e0       	ldi	r24, 0x00	; 0
     b7e:	69 ad       	ldd	r22, Y+57	; 0x39
     b80:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <DIO_u8SetPortValue>

	/*Send Enable pulse */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_HIGH);
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	62 e0       	ldi	r22, 0x02	; 2
     b88:	41 e0       	ldi	r20, 0x01	; 1
     b8a:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
     b8e:	80 e0       	ldi	r24, 0x00	; 0
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	a0 e0       	ldi	r26, 0x00	; 0
     b94:	b0 e4       	ldi	r27, 0x40	; 64
     b96:	8d ab       	std	Y+53, r24	; 0x35
     b98:	9e ab       	std	Y+54, r25	; 0x36
     b9a:	af ab       	std	Y+55, r26	; 0x37
     b9c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     b9e:	6d a9       	ldd	r22, Y+53	; 0x35
     ba0:	7e a9       	ldd	r23, Y+54	; 0x36
     ba2:	8f a9       	ldd	r24, Y+55	; 0x37
     ba4:	98 ad       	ldd	r25, Y+56	; 0x38
     ba6:	20 e0       	ldi	r18, 0x00	; 0
     ba8:	30 e0       	ldi	r19, 0x00	; 0
     baa:	4a e7       	ldi	r20, 0x7A	; 122
     bac:	55 e4       	ldi	r21, 0x45	; 69
     bae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     bb2:	dc 01       	movw	r26, r24
     bb4:	cb 01       	movw	r24, r22
     bb6:	89 ab       	std	Y+49, r24	; 0x31
     bb8:	9a ab       	std	Y+50, r25	; 0x32
     bba:	ab ab       	std	Y+51, r26	; 0x33
     bbc:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
     bbe:	69 a9       	ldd	r22, Y+49	; 0x31
     bc0:	7a a9       	ldd	r23, Y+50	; 0x32
     bc2:	8b a9       	ldd	r24, Y+51	; 0x33
     bc4:	9c a9       	ldd	r25, Y+52	; 0x34
     bc6:	20 e0       	ldi	r18, 0x00	; 0
     bc8:	30 e0       	ldi	r19, 0x00	; 0
     bca:	40 e8       	ldi	r20, 0x80	; 128
     bcc:	5f e3       	ldi	r21, 0x3F	; 63
     bce:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     bd2:	88 23       	and	r24, r24
     bd4:	2c f4       	brge	.+10     	; 0xbe0 <C_LCD_voidSendCommand+0x9a>
		__ticks = 1;
     bd6:	81 e0       	ldi	r24, 0x01	; 1
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	98 ab       	std	Y+48, r25	; 0x30
     bdc:	8f a7       	std	Y+47, r24	; 0x2f
     bde:	3f c0       	rjmp	.+126    	; 0xc5e <C_LCD_voidSendCommand+0x118>
	else if (__tmp > 65535)
     be0:	69 a9       	ldd	r22, Y+49	; 0x31
     be2:	7a a9       	ldd	r23, Y+50	; 0x32
     be4:	8b a9       	ldd	r24, Y+51	; 0x33
     be6:	9c a9       	ldd	r25, Y+52	; 0x34
     be8:	20 e0       	ldi	r18, 0x00	; 0
     bea:	3f ef       	ldi	r19, 0xFF	; 255
     bec:	4f e7       	ldi	r20, 0x7F	; 127
     bee:	57 e4       	ldi	r21, 0x47	; 71
     bf0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     bf4:	18 16       	cp	r1, r24
     bf6:	4c f5       	brge	.+82     	; 0xc4a <C_LCD_voidSendCommand+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     bf8:	6d a9       	ldd	r22, Y+53	; 0x35
     bfa:	7e a9       	ldd	r23, Y+54	; 0x36
     bfc:	8f a9       	ldd	r24, Y+55	; 0x37
     bfe:	98 ad       	ldd	r25, Y+56	; 0x38
     c00:	20 e0       	ldi	r18, 0x00	; 0
     c02:	30 e0       	ldi	r19, 0x00	; 0
     c04:	40 e2       	ldi	r20, 0x20	; 32
     c06:	51 e4       	ldi	r21, 0x41	; 65
     c08:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c0c:	dc 01       	movw	r26, r24
     c0e:	cb 01       	movw	r24, r22
     c10:	bc 01       	movw	r22, r24
     c12:	cd 01       	movw	r24, r26
     c14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c18:	dc 01       	movw	r26, r24
     c1a:	cb 01       	movw	r24, r22
     c1c:	98 ab       	std	Y+48, r25	; 0x30
     c1e:	8f a7       	std	Y+47, r24	; 0x2f
     c20:	0f c0       	rjmp	.+30     	; 0xc40 <C_LCD_voidSendCommand+0xfa>
     c22:	80 e9       	ldi	r24, 0x90	; 144
     c24:	91 e0       	ldi	r25, 0x01	; 1
     c26:	9e a7       	std	Y+46, r25	; 0x2e
     c28:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c2a:	8d a5       	ldd	r24, Y+45	; 0x2d
     c2c:	9e a5       	ldd	r25, Y+46	; 0x2e
     c2e:	01 97       	sbiw	r24, 0x01	; 1
     c30:	f1 f7       	brne	.-4      	; 0xc2e <C_LCD_voidSendCommand+0xe8>
     c32:	9e a7       	std	Y+46, r25	; 0x2e
     c34:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     c36:	8f a5       	ldd	r24, Y+47	; 0x2f
     c38:	98 a9       	ldd	r25, Y+48	; 0x30
     c3a:	01 97       	sbiw	r24, 0x01	; 1
     c3c:	98 ab       	std	Y+48, r25	; 0x30
     c3e:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     c40:	8f a5       	ldd	r24, Y+47	; 0x2f
     c42:	98 a9       	ldd	r25, Y+48	; 0x30
     c44:	00 97       	sbiw	r24, 0x00	; 0
     c46:	69 f7       	brne	.-38     	; 0xc22 <C_LCD_voidSendCommand+0xdc>
     c48:	14 c0       	rjmp	.+40     	; 0xc72 <C_LCD_voidSendCommand+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     c4a:	69 a9       	ldd	r22, Y+49	; 0x31
     c4c:	7a a9       	ldd	r23, Y+50	; 0x32
     c4e:	8b a9       	ldd	r24, Y+51	; 0x33
     c50:	9c a9       	ldd	r25, Y+52	; 0x34
     c52:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c56:	dc 01       	movw	r26, r24
     c58:	cb 01       	movw	r24, r22
     c5a:	98 ab       	std	Y+48, r25	; 0x30
     c5c:	8f a7       	std	Y+47, r24	; 0x2f
     c5e:	8f a5       	ldd	r24, Y+47	; 0x2f
     c60:	98 a9       	ldd	r25, Y+48	; 0x30
     c62:	9c a7       	std	Y+44, r25	; 0x2c
     c64:	8b a7       	std	Y+43, r24	; 0x2b
     c66:	8b a5       	ldd	r24, Y+43	; 0x2b
     c68:	9c a5       	ldd	r25, Y+44	; 0x2c
     c6a:	01 97       	sbiw	r24, 0x01	; 1
     c6c:	f1 f7       	brne	.-4      	; 0xc6a <C_LCD_voidSendCommand+0x124>
     c6e:	9c a7       	std	Y+44, r25	; 0x2c
     c70:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);
     c72:	80 e0       	ldi	r24, 0x00	; 0
     c74:	62 e0       	ldi	r22, 0x02	; 2
     c76:	40 e0       	ldi	r20, 0x00	; 0
     c78:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
     c7c:	80 e0       	ldi	r24, 0x00	; 0
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	a0 ea       	ldi	r26, 0xA0	; 160
     c82:	b0 e4       	ldi	r27, 0x40	; 64
     c84:	8f a3       	std	Y+39, r24	; 0x27
     c86:	98 a7       	std	Y+40, r25	; 0x28
     c88:	a9 a7       	std	Y+41, r26	; 0x29
     c8a:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     c8c:	6f a1       	ldd	r22, Y+39	; 0x27
     c8e:	78 a5       	ldd	r23, Y+40	; 0x28
     c90:	89 a5       	ldd	r24, Y+41	; 0x29
     c92:	9a a5       	ldd	r25, Y+42	; 0x2a
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	30 e0       	ldi	r19, 0x00	; 0
     c98:	4a e7       	ldi	r20, 0x7A	; 122
     c9a:	55 e4       	ldi	r21, 0x45	; 69
     c9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ca0:	dc 01       	movw	r26, r24
     ca2:	cb 01       	movw	r24, r22
     ca4:	8b a3       	std	Y+35, r24	; 0x23
     ca6:	9c a3       	std	Y+36, r25	; 0x24
     ca8:	ad a3       	std	Y+37, r26	; 0x25
     caa:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
     cac:	6b a1       	ldd	r22, Y+35	; 0x23
     cae:	7c a1       	ldd	r23, Y+36	; 0x24
     cb0:	8d a1       	ldd	r24, Y+37	; 0x25
     cb2:	9e a1       	ldd	r25, Y+38	; 0x26
     cb4:	20 e0       	ldi	r18, 0x00	; 0
     cb6:	30 e0       	ldi	r19, 0x00	; 0
     cb8:	40 e8       	ldi	r20, 0x80	; 128
     cba:	5f e3       	ldi	r21, 0x3F	; 63
     cbc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     cc0:	88 23       	and	r24, r24
     cc2:	2c f4       	brge	.+10     	; 0xcce <C_LCD_voidSendCommand+0x188>
		__ticks = 1;
     cc4:	81 e0       	ldi	r24, 0x01	; 1
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	9a a3       	std	Y+34, r25	; 0x22
     cca:	89 a3       	std	Y+33, r24	; 0x21
     ccc:	3f c0       	rjmp	.+126    	; 0xd4c <C_LCD_voidSendCommand+0x206>
	else if (__tmp > 65535)
     cce:	6b a1       	ldd	r22, Y+35	; 0x23
     cd0:	7c a1       	ldd	r23, Y+36	; 0x24
     cd2:	8d a1       	ldd	r24, Y+37	; 0x25
     cd4:	9e a1       	ldd	r25, Y+38	; 0x26
     cd6:	20 e0       	ldi	r18, 0x00	; 0
     cd8:	3f ef       	ldi	r19, 0xFF	; 255
     cda:	4f e7       	ldi	r20, 0x7F	; 127
     cdc:	57 e4       	ldi	r21, 0x47	; 71
     cde:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     ce2:	18 16       	cp	r1, r24
     ce4:	4c f5       	brge	.+82     	; 0xd38 <C_LCD_voidSendCommand+0x1f2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ce6:	6f a1       	ldd	r22, Y+39	; 0x27
     ce8:	78 a5       	ldd	r23, Y+40	; 0x28
     cea:	89 a5       	ldd	r24, Y+41	; 0x29
     cec:	9a a5       	ldd	r25, Y+42	; 0x2a
     cee:	20 e0       	ldi	r18, 0x00	; 0
     cf0:	30 e0       	ldi	r19, 0x00	; 0
     cf2:	40 e2       	ldi	r20, 0x20	; 32
     cf4:	51 e4       	ldi	r21, 0x41	; 65
     cf6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     cfa:	dc 01       	movw	r26, r24
     cfc:	cb 01       	movw	r24, r22
     cfe:	bc 01       	movw	r22, r24
     d00:	cd 01       	movw	r24, r26
     d02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d06:	dc 01       	movw	r26, r24
     d08:	cb 01       	movw	r24, r22
     d0a:	9a a3       	std	Y+34, r25	; 0x22
     d0c:	89 a3       	std	Y+33, r24	; 0x21
     d0e:	0f c0       	rjmp	.+30     	; 0xd2e <C_LCD_voidSendCommand+0x1e8>
     d10:	80 e9       	ldi	r24, 0x90	; 144
     d12:	91 e0       	ldi	r25, 0x01	; 1
     d14:	98 a3       	std	Y+32, r25	; 0x20
     d16:	8f 8f       	std	Y+31, r24	; 0x1f
     d18:	8f 8d       	ldd	r24, Y+31	; 0x1f
     d1a:	98 a1       	ldd	r25, Y+32	; 0x20
     d1c:	01 97       	sbiw	r24, 0x01	; 1
     d1e:	f1 f7       	brne	.-4      	; 0xd1c <C_LCD_voidSendCommand+0x1d6>
     d20:	98 a3       	std	Y+32, r25	; 0x20
     d22:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d24:	89 a1       	ldd	r24, Y+33	; 0x21
     d26:	9a a1       	ldd	r25, Y+34	; 0x22
     d28:	01 97       	sbiw	r24, 0x01	; 1
     d2a:	9a a3       	std	Y+34, r25	; 0x22
     d2c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d2e:	89 a1       	ldd	r24, Y+33	; 0x21
     d30:	9a a1       	ldd	r25, Y+34	; 0x22
     d32:	00 97       	sbiw	r24, 0x00	; 0
     d34:	69 f7       	brne	.-38     	; 0xd10 <C_LCD_voidSendCommand+0x1ca>
     d36:	14 c0       	rjmp	.+40     	; 0xd60 <C_LCD_voidSendCommand+0x21a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d38:	6b a1       	ldd	r22, Y+35	; 0x23
     d3a:	7c a1       	ldd	r23, Y+36	; 0x24
     d3c:	8d a1       	ldd	r24, Y+37	; 0x25
     d3e:	9e a1       	ldd	r25, Y+38	; 0x26
     d40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d44:	dc 01       	movw	r26, r24
     d46:	cb 01       	movw	r24, r22
     d48:	9a a3       	std	Y+34, r25	; 0x22
     d4a:	89 a3       	std	Y+33, r24	; 0x21
     d4c:	89 a1       	ldd	r24, Y+33	; 0x21
     d4e:	9a a1       	ldd	r25, Y+34	; 0x22
     d50:	9e 8f       	std	Y+30, r25	; 0x1e
     d52:	8d 8f       	std	Y+29, r24	; 0x1d
     d54:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d56:	9e 8d       	ldd	r25, Y+30	; 0x1e
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	f1 f7       	brne	.-4      	; 0xd58 <C_LCD_voidSendCommand+0x212>
     d5c:	9e 8f       	std	Y+30, r25	; 0x1e
     d5e:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(5);

	Local_u8Command = ((Copy_u8Command <<3) |DIO_u8AndWithPort(CLCD_DATA_PORT, 0b10000111));
     d60:	8a ad       	ldd	r24, Y+58	; 0x3a
     d62:	88 2f       	mov	r24, r24
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	88 0f       	add	r24, r24
     d68:	99 1f       	adc	r25, r25
     d6a:	88 0f       	add	r24, r24
     d6c:	99 1f       	adc	r25, r25
     d6e:	88 0f       	add	r24, r24
     d70:	99 1f       	adc	r25, r25
     d72:	18 2f       	mov	r17, r24
     d74:	80 e0       	ldi	r24, 0x00	; 0
     d76:	67 e8       	ldi	r22, 0x87	; 135
     d78:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <DIO_u8AndWithPort>
     d7c:	81 2b       	or	r24, r17
     d7e:	89 af       	std	Y+57, r24	; 0x39
	DIO_u8SetPortValue(CLCD_DATA_PORT,Local_u8Command);
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	69 ad       	ldd	r22, Y+57	; 0x39
     d84:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <DIO_u8SetPortValue>

	/*Send Enable pulse */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_HIGH);
     d88:	80 e0       	ldi	r24, 0x00	; 0
     d8a:	62 e0       	ldi	r22, 0x02	; 2
     d8c:	41 e0       	ldi	r20, 0x01	; 1
     d8e:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
     d92:	80 e0       	ldi	r24, 0x00	; 0
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	a0 e0       	ldi	r26, 0x00	; 0
     d98:	b0 e4       	ldi	r27, 0x40	; 64
     d9a:	89 8f       	std	Y+25, r24	; 0x19
     d9c:	9a 8f       	std	Y+26, r25	; 0x1a
     d9e:	ab 8f       	std	Y+27, r26	; 0x1b
     da0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     da2:	69 8d       	ldd	r22, Y+25	; 0x19
     da4:	7a 8d       	ldd	r23, Y+26	; 0x1a
     da6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     da8:	9c 8d       	ldd	r25, Y+28	; 0x1c
     daa:	20 e0       	ldi	r18, 0x00	; 0
     dac:	30 e0       	ldi	r19, 0x00	; 0
     dae:	4a e7       	ldi	r20, 0x7A	; 122
     db0:	55 e4       	ldi	r21, 0x45	; 69
     db2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     db6:	dc 01       	movw	r26, r24
     db8:	cb 01       	movw	r24, r22
     dba:	8d 8b       	std	Y+21, r24	; 0x15
     dbc:	9e 8b       	std	Y+22, r25	; 0x16
     dbe:	af 8b       	std	Y+23, r26	; 0x17
     dc0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     dc2:	6d 89       	ldd	r22, Y+21	; 0x15
     dc4:	7e 89       	ldd	r23, Y+22	; 0x16
     dc6:	8f 89       	ldd	r24, Y+23	; 0x17
     dc8:	98 8d       	ldd	r25, Y+24	; 0x18
     dca:	20 e0       	ldi	r18, 0x00	; 0
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	40 e8       	ldi	r20, 0x80	; 128
     dd0:	5f e3       	ldi	r21, 0x3F	; 63
     dd2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     dd6:	88 23       	and	r24, r24
     dd8:	2c f4       	brge	.+10     	; 0xde4 <C_LCD_voidSendCommand+0x29e>
		__ticks = 1;
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	9c 8b       	std	Y+20, r25	; 0x14
     de0:	8b 8b       	std	Y+19, r24	; 0x13
     de2:	3f c0       	rjmp	.+126    	; 0xe62 <C_LCD_voidSendCommand+0x31c>
	else if (__tmp > 65535)
     de4:	6d 89       	ldd	r22, Y+21	; 0x15
     de6:	7e 89       	ldd	r23, Y+22	; 0x16
     de8:	8f 89       	ldd	r24, Y+23	; 0x17
     dea:	98 8d       	ldd	r25, Y+24	; 0x18
     dec:	20 e0       	ldi	r18, 0x00	; 0
     dee:	3f ef       	ldi	r19, 0xFF	; 255
     df0:	4f e7       	ldi	r20, 0x7F	; 127
     df2:	57 e4       	ldi	r21, 0x47	; 71
     df4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     df8:	18 16       	cp	r1, r24
     dfa:	4c f5       	brge	.+82     	; 0xe4e <C_LCD_voidSendCommand+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     dfc:	69 8d       	ldd	r22, Y+25	; 0x19
     dfe:	7a 8d       	ldd	r23, Y+26	; 0x1a
     e00:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e02:	9c 8d       	ldd	r25, Y+28	; 0x1c
     e04:	20 e0       	ldi	r18, 0x00	; 0
     e06:	30 e0       	ldi	r19, 0x00	; 0
     e08:	40 e2       	ldi	r20, 0x20	; 32
     e0a:	51 e4       	ldi	r21, 0x41	; 65
     e0c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e10:	dc 01       	movw	r26, r24
     e12:	cb 01       	movw	r24, r22
     e14:	bc 01       	movw	r22, r24
     e16:	cd 01       	movw	r24, r26
     e18:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e1c:	dc 01       	movw	r26, r24
     e1e:	cb 01       	movw	r24, r22
     e20:	9c 8b       	std	Y+20, r25	; 0x14
     e22:	8b 8b       	std	Y+19, r24	; 0x13
     e24:	0f c0       	rjmp	.+30     	; 0xe44 <C_LCD_voidSendCommand+0x2fe>
     e26:	80 e9       	ldi	r24, 0x90	; 144
     e28:	91 e0       	ldi	r25, 0x01	; 1
     e2a:	9a 8b       	std	Y+18, r25	; 0x12
     e2c:	89 8b       	std	Y+17, r24	; 0x11
     e2e:	89 89       	ldd	r24, Y+17	; 0x11
     e30:	9a 89       	ldd	r25, Y+18	; 0x12
     e32:	01 97       	sbiw	r24, 0x01	; 1
     e34:	f1 f7       	brne	.-4      	; 0xe32 <C_LCD_voidSendCommand+0x2ec>
     e36:	9a 8b       	std	Y+18, r25	; 0x12
     e38:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e3a:	8b 89       	ldd	r24, Y+19	; 0x13
     e3c:	9c 89       	ldd	r25, Y+20	; 0x14
     e3e:	01 97       	sbiw	r24, 0x01	; 1
     e40:	9c 8b       	std	Y+20, r25	; 0x14
     e42:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     e44:	8b 89       	ldd	r24, Y+19	; 0x13
     e46:	9c 89       	ldd	r25, Y+20	; 0x14
     e48:	00 97       	sbiw	r24, 0x00	; 0
     e4a:	69 f7       	brne	.-38     	; 0xe26 <C_LCD_voidSendCommand+0x2e0>
     e4c:	14 c0       	rjmp	.+40     	; 0xe76 <C_LCD_voidSendCommand+0x330>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     e4e:	6d 89       	ldd	r22, Y+21	; 0x15
     e50:	7e 89       	ldd	r23, Y+22	; 0x16
     e52:	8f 89       	ldd	r24, Y+23	; 0x17
     e54:	98 8d       	ldd	r25, Y+24	; 0x18
     e56:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e5a:	dc 01       	movw	r26, r24
     e5c:	cb 01       	movw	r24, r22
     e5e:	9c 8b       	std	Y+20, r25	; 0x14
     e60:	8b 8b       	std	Y+19, r24	; 0x13
     e62:	8b 89       	ldd	r24, Y+19	; 0x13
     e64:	9c 89       	ldd	r25, Y+20	; 0x14
     e66:	98 8b       	std	Y+16, r25	; 0x10
     e68:	8f 87       	std	Y+15, r24	; 0x0f
     e6a:	8f 85       	ldd	r24, Y+15	; 0x0f
     e6c:	98 89       	ldd	r25, Y+16	; 0x10
     e6e:	01 97       	sbiw	r24, 0x01	; 1
     e70:	f1 f7       	brne	.-4      	; 0xe6e <C_LCD_voidSendCommand+0x328>
     e72:	98 8b       	std	Y+16, r25	; 0x10
     e74:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);
     e76:	80 e0       	ldi	r24, 0x00	; 0
     e78:	62 e0       	ldi	r22, 0x02	; 2
     e7a:	40 e0       	ldi	r20, 0x00	; 0
     e7c:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
     e80:	80 e0       	ldi	r24, 0x00	; 0
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	a0 ea       	ldi	r26, 0xA0	; 160
     e86:	b0 e4       	ldi	r27, 0x40	; 64
     e88:	8b 87       	std	Y+11, r24	; 0x0b
     e8a:	9c 87       	std	Y+12, r25	; 0x0c
     e8c:	ad 87       	std	Y+13, r26	; 0x0d
     e8e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     e90:	6b 85       	ldd	r22, Y+11	; 0x0b
     e92:	7c 85       	ldd	r23, Y+12	; 0x0c
     e94:	8d 85       	ldd	r24, Y+13	; 0x0d
     e96:	9e 85       	ldd	r25, Y+14	; 0x0e
     e98:	20 e0       	ldi	r18, 0x00	; 0
     e9a:	30 e0       	ldi	r19, 0x00	; 0
     e9c:	4a e7       	ldi	r20, 0x7A	; 122
     e9e:	55 e4       	ldi	r21, 0x45	; 69
     ea0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ea4:	dc 01       	movw	r26, r24
     ea6:	cb 01       	movw	r24, r22
     ea8:	8f 83       	std	Y+7, r24	; 0x07
     eaa:	98 87       	std	Y+8, r25	; 0x08
     eac:	a9 87       	std	Y+9, r26	; 0x09
     eae:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     eb0:	6f 81       	ldd	r22, Y+7	; 0x07
     eb2:	78 85       	ldd	r23, Y+8	; 0x08
     eb4:	89 85       	ldd	r24, Y+9	; 0x09
     eb6:	9a 85       	ldd	r25, Y+10	; 0x0a
     eb8:	20 e0       	ldi	r18, 0x00	; 0
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	40 e8       	ldi	r20, 0x80	; 128
     ebe:	5f e3       	ldi	r21, 0x3F	; 63
     ec0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     ec4:	88 23       	and	r24, r24
     ec6:	2c f4       	brge	.+10     	; 0xed2 <C_LCD_voidSendCommand+0x38c>
		__ticks = 1;
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	9e 83       	std	Y+6, r25	; 0x06
     ece:	8d 83       	std	Y+5, r24	; 0x05
     ed0:	3f c0       	rjmp	.+126    	; 0xf50 <C_LCD_voidSendCommand+0x40a>
	else if (__tmp > 65535)
     ed2:	6f 81       	ldd	r22, Y+7	; 0x07
     ed4:	78 85       	ldd	r23, Y+8	; 0x08
     ed6:	89 85       	ldd	r24, Y+9	; 0x09
     ed8:	9a 85       	ldd	r25, Y+10	; 0x0a
     eda:	20 e0       	ldi	r18, 0x00	; 0
     edc:	3f ef       	ldi	r19, 0xFF	; 255
     ede:	4f e7       	ldi	r20, 0x7F	; 127
     ee0:	57 e4       	ldi	r21, 0x47	; 71
     ee2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     ee6:	18 16       	cp	r1, r24
     ee8:	4c f5       	brge	.+82     	; 0xf3c <C_LCD_voidSendCommand+0x3f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     eea:	6b 85       	ldd	r22, Y+11	; 0x0b
     eec:	7c 85       	ldd	r23, Y+12	; 0x0c
     eee:	8d 85       	ldd	r24, Y+13	; 0x0d
     ef0:	9e 85       	ldd	r25, Y+14	; 0x0e
     ef2:	20 e0       	ldi	r18, 0x00	; 0
     ef4:	30 e0       	ldi	r19, 0x00	; 0
     ef6:	40 e2       	ldi	r20, 0x20	; 32
     ef8:	51 e4       	ldi	r21, 0x41	; 65
     efa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     efe:	dc 01       	movw	r26, r24
     f00:	cb 01       	movw	r24, r22
     f02:	bc 01       	movw	r22, r24
     f04:	cd 01       	movw	r24, r26
     f06:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f0a:	dc 01       	movw	r26, r24
     f0c:	cb 01       	movw	r24, r22
     f0e:	9e 83       	std	Y+6, r25	; 0x06
     f10:	8d 83       	std	Y+5, r24	; 0x05
     f12:	0f c0       	rjmp	.+30     	; 0xf32 <C_LCD_voidSendCommand+0x3ec>
     f14:	80 e9       	ldi	r24, 0x90	; 144
     f16:	91 e0       	ldi	r25, 0x01	; 1
     f18:	9c 83       	std	Y+4, r25	; 0x04
     f1a:	8b 83       	std	Y+3, r24	; 0x03
     f1c:	8b 81       	ldd	r24, Y+3	; 0x03
     f1e:	9c 81       	ldd	r25, Y+4	; 0x04
     f20:	01 97       	sbiw	r24, 0x01	; 1
     f22:	f1 f7       	brne	.-4      	; 0xf20 <C_LCD_voidSendCommand+0x3da>
     f24:	9c 83       	std	Y+4, r25	; 0x04
     f26:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f28:	8d 81       	ldd	r24, Y+5	; 0x05
     f2a:	9e 81       	ldd	r25, Y+6	; 0x06
     f2c:	01 97       	sbiw	r24, 0x01	; 1
     f2e:	9e 83       	std	Y+6, r25	; 0x06
     f30:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f32:	8d 81       	ldd	r24, Y+5	; 0x05
     f34:	9e 81       	ldd	r25, Y+6	; 0x06
     f36:	00 97       	sbiw	r24, 0x00	; 0
     f38:	69 f7       	brne	.-38     	; 0xf14 <C_LCD_voidSendCommand+0x3ce>
     f3a:	14 c0       	rjmp	.+40     	; 0xf64 <C_LCD_voidSendCommand+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f3c:	6f 81       	ldd	r22, Y+7	; 0x07
     f3e:	78 85       	ldd	r23, Y+8	; 0x08
     f40:	89 85       	ldd	r24, Y+9	; 0x09
     f42:	9a 85       	ldd	r25, Y+10	; 0x0a
     f44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f48:	dc 01       	movw	r26, r24
     f4a:	cb 01       	movw	r24, r22
     f4c:	9e 83       	std	Y+6, r25	; 0x06
     f4e:	8d 83       	std	Y+5, r24	; 0x05
     f50:	8d 81       	ldd	r24, Y+5	; 0x05
     f52:	9e 81       	ldd	r25, Y+6	; 0x06
     f54:	9a 83       	std	Y+2, r25	; 0x02
     f56:	89 83       	std	Y+1, r24	; 0x01
     f58:	89 81       	ldd	r24, Y+1	; 0x01
     f5a:	9a 81       	ldd	r25, Y+2	; 0x02
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	f1 f7       	brne	.-4      	; 0xf5c <C_LCD_voidSendCommand+0x416>
     f60:	9a 83       	std	Y+2, r25	; 0x02
     f62:	89 83       	std	Y+1, r24	; 0x01

#endif



}
     f64:	ea 96       	adiw	r28, 0x3a	; 58
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	f8 94       	cli
     f6a:	de bf       	out	0x3e, r29	; 62
     f6c:	0f be       	out	0x3f, r0	; 63
     f6e:	cd bf       	out	0x3d, r28	; 61
     f70:	cf 91       	pop	r28
     f72:	df 91       	pop	r29
     f74:	1f 91       	pop	r17
     f76:	08 95       	ret

00000f78 <CLCD_voidSendData>:

void CLCD_voidSendData(u8 Copy_u8Data)
{
     f78:	1f 93       	push	r17
     f7a:	df 93       	push	r29
     f7c:	cf 93       	push	r28
     f7e:	cd b7       	in	r28, 0x3d	; 61
     f80:	de b7       	in	r29, 0x3e	; 62
     f82:	ea 97       	sbiw	r28, 0x3a	; 58
     f84:	0f b6       	in	r0, 0x3f	; 63
     f86:	f8 94       	cli
     f88:	de bf       	out	0x3e, r29	; 62
     f8a:	0f be       	out	0x3f, r0	; 63
     f8c:	cd bf       	out	0x3d, r28	; 61
     f8e:	8a af       	std	Y+58, r24	; 0x3a
	/*Set RS Pin to low to send data */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_RS_PIN,DIO_u8PIN_HIGH);
     f90:	80 e0       	ldi	r24, 0x00	; 0
     f92:	61 e0       	ldi	r22, 0x01	; 1
     f94:	41 e0       	ldi	r20, 0x01	; 1
     f96:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);

#elif   MODE_SELECT ==_4_BIT_MODE

	u8 Local_u8Data = (((Copy_u8Data >> 1) & 0b01111000) | DIO_u8AndWithPort(CLCD_DATA_PORT, 0b10000111));
     f9a:	8a ad       	ldd	r24, Y+58	; 0x3a
     f9c:	86 95       	lsr	r24
     f9e:	18 2f       	mov	r17, r24
     fa0:	18 77       	andi	r17, 0x78	; 120
     fa2:	80 e0       	ldi	r24, 0x00	; 0
     fa4:	67 e8       	ldi	r22, 0x87	; 135
     fa6:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <DIO_u8AndWithPort>
     faa:	81 2b       	or	r24, r17
     fac:	89 af       	std	Y+57, r24	; 0x39
	/* Set Command to data pins */
	DIO_u8SetPortValue(CLCD_DATA_PORT,Local_u8Data);
     fae:	80 e0       	ldi	r24, 0x00	; 0
     fb0:	69 ad       	ldd	r22, Y+57	; 0x39
     fb2:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <DIO_u8SetPortValue>

	/*Send Enable pulse */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_HIGH);
     fb6:	80 e0       	ldi	r24, 0x00	; 0
     fb8:	62 e0       	ldi	r22, 0x02	; 2
     fba:	41 e0       	ldi	r20, 0x01	; 1
     fbc:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
     fc0:	80 e0       	ldi	r24, 0x00	; 0
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	a0 e0       	ldi	r26, 0x00	; 0
     fc6:	b0 e4       	ldi	r27, 0x40	; 64
     fc8:	8d ab       	std	Y+53, r24	; 0x35
     fca:	9e ab       	std	Y+54, r25	; 0x36
     fcc:	af ab       	std	Y+55, r26	; 0x37
     fce:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     fd0:	6d a9       	ldd	r22, Y+53	; 0x35
     fd2:	7e a9       	ldd	r23, Y+54	; 0x36
     fd4:	8f a9       	ldd	r24, Y+55	; 0x37
     fd6:	98 ad       	ldd	r25, Y+56	; 0x38
     fd8:	20 e0       	ldi	r18, 0x00	; 0
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	4a e7       	ldi	r20, 0x7A	; 122
     fde:	55 e4       	ldi	r21, 0x45	; 69
     fe0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fe4:	dc 01       	movw	r26, r24
     fe6:	cb 01       	movw	r24, r22
     fe8:	89 ab       	std	Y+49, r24	; 0x31
     fea:	9a ab       	std	Y+50, r25	; 0x32
     fec:	ab ab       	std	Y+51, r26	; 0x33
     fee:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
     ff0:	69 a9       	ldd	r22, Y+49	; 0x31
     ff2:	7a a9       	ldd	r23, Y+50	; 0x32
     ff4:	8b a9       	ldd	r24, Y+51	; 0x33
     ff6:	9c a9       	ldd	r25, Y+52	; 0x34
     ff8:	20 e0       	ldi	r18, 0x00	; 0
     ffa:	30 e0       	ldi	r19, 0x00	; 0
     ffc:	40 e8       	ldi	r20, 0x80	; 128
     ffe:	5f e3       	ldi	r21, 0x3F	; 63
    1000:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1004:	88 23       	and	r24, r24
    1006:	2c f4       	brge	.+10     	; 0x1012 <CLCD_voidSendData+0x9a>
		__ticks = 1;
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	98 ab       	std	Y+48, r25	; 0x30
    100e:	8f a7       	std	Y+47, r24	; 0x2f
    1010:	3f c0       	rjmp	.+126    	; 0x1090 <CLCD_voidSendData+0x118>
	else if (__tmp > 65535)
    1012:	69 a9       	ldd	r22, Y+49	; 0x31
    1014:	7a a9       	ldd	r23, Y+50	; 0x32
    1016:	8b a9       	ldd	r24, Y+51	; 0x33
    1018:	9c a9       	ldd	r25, Y+52	; 0x34
    101a:	20 e0       	ldi	r18, 0x00	; 0
    101c:	3f ef       	ldi	r19, 0xFF	; 255
    101e:	4f e7       	ldi	r20, 0x7F	; 127
    1020:	57 e4       	ldi	r21, 0x47	; 71
    1022:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1026:	18 16       	cp	r1, r24
    1028:	4c f5       	brge	.+82     	; 0x107c <CLCD_voidSendData+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    102a:	6d a9       	ldd	r22, Y+53	; 0x35
    102c:	7e a9       	ldd	r23, Y+54	; 0x36
    102e:	8f a9       	ldd	r24, Y+55	; 0x37
    1030:	98 ad       	ldd	r25, Y+56	; 0x38
    1032:	20 e0       	ldi	r18, 0x00	; 0
    1034:	30 e0       	ldi	r19, 0x00	; 0
    1036:	40 e2       	ldi	r20, 0x20	; 32
    1038:	51 e4       	ldi	r21, 0x41	; 65
    103a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    103e:	dc 01       	movw	r26, r24
    1040:	cb 01       	movw	r24, r22
    1042:	bc 01       	movw	r22, r24
    1044:	cd 01       	movw	r24, r26
    1046:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    104a:	dc 01       	movw	r26, r24
    104c:	cb 01       	movw	r24, r22
    104e:	98 ab       	std	Y+48, r25	; 0x30
    1050:	8f a7       	std	Y+47, r24	; 0x2f
    1052:	0f c0       	rjmp	.+30     	; 0x1072 <CLCD_voidSendData+0xfa>
    1054:	80 e9       	ldi	r24, 0x90	; 144
    1056:	91 e0       	ldi	r25, 0x01	; 1
    1058:	9e a7       	std	Y+46, r25	; 0x2e
    105a:	8d a7       	std	Y+45, r24	; 0x2d
    105c:	8d a5       	ldd	r24, Y+45	; 0x2d
    105e:	9e a5       	ldd	r25, Y+46	; 0x2e
    1060:	01 97       	sbiw	r24, 0x01	; 1
    1062:	f1 f7       	brne	.-4      	; 0x1060 <CLCD_voidSendData+0xe8>
    1064:	9e a7       	std	Y+46, r25	; 0x2e
    1066:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1068:	8f a5       	ldd	r24, Y+47	; 0x2f
    106a:	98 a9       	ldd	r25, Y+48	; 0x30
    106c:	01 97       	sbiw	r24, 0x01	; 1
    106e:	98 ab       	std	Y+48, r25	; 0x30
    1070:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1072:	8f a5       	ldd	r24, Y+47	; 0x2f
    1074:	98 a9       	ldd	r25, Y+48	; 0x30
    1076:	00 97       	sbiw	r24, 0x00	; 0
    1078:	69 f7       	brne	.-38     	; 0x1054 <CLCD_voidSendData+0xdc>
    107a:	14 c0       	rjmp	.+40     	; 0x10a4 <CLCD_voidSendData+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    107c:	69 a9       	ldd	r22, Y+49	; 0x31
    107e:	7a a9       	ldd	r23, Y+50	; 0x32
    1080:	8b a9       	ldd	r24, Y+51	; 0x33
    1082:	9c a9       	ldd	r25, Y+52	; 0x34
    1084:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1088:	dc 01       	movw	r26, r24
    108a:	cb 01       	movw	r24, r22
    108c:	98 ab       	std	Y+48, r25	; 0x30
    108e:	8f a7       	std	Y+47, r24	; 0x2f
    1090:	8f a5       	ldd	r24, Y+47	; 0x2f
    1092:	98 a9       	ldd	r25, Y+48	; 0x30
    1094:	9c a7       	std	Y+44, r25	; 0x2c
    1096:	8b a7       	std	Y+43, r24	; 0x2b
    1098:	8b a5       	ldd	r24, Y+43	; 0x2b
    109a:	9c a5       	ldd	r25, Y+44	; 0x2c
    109c:	01 97       	sbiw	r24, 0x01	; 1
    109e:	f1 f7       	brne	.-4      	; 0x109c <CLCD_voidSendData+0x124>
    10a0:	9c a7       	std	Y+44, r25	; 0x2c
    10a2:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);
    10a4:	80 e0       	ldi	r24, 0x00	; 0
    10a6:	62 e0       	ldi	r22, 0x02	; 2
    10a8:	40 e0       	ldi	r20, 0x00	; 0
    10aa:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
    10ae:	80 e0       	ldi	r24, 0x00	; 0
    10b0:	90 e0       	ldi	r25, 0x00	; 0
    10b2:	a0 ea       	ldi	r26, 0xA0	; 160
    10b4:	b0 e4       	ldi	r27, 0x40	; 64
    10b6:	8f a3       	std	Y+39, r24	; 0x27
    10b8:	98 a7       	std	Y+40, r25	; 0x28
    10ba:	a9 a7       	std	Y+41, r26	; 0x29
    10bc:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    10be:	6f a1       	ldd	r22, Y+39	; 0x27
    10c0:	78 a5       	ldd	r23, Y+40	; 0x28
    10c2:	89 a5       	ldd	r24, Y+41	; 0x29
    10c4:	9a a5       	ldd	r25, Y+42	; 0x2a
    10c6:	20 e0       	ldi	r18, 0x00	; 0
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	4a e7       	ldi	r20, 0x7A	; 122
    10cc:	55 e4       	ldi	r21, 0x45	; 69
    10ce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    10d2:	dc 01       	movw	r26, r24
    10d4:	cb 01       	movw	r24, r22
    10d6:	8b a3       	std	Y+35, r24	; 0x23
    10d8:	9c a3       	std	Y+36, r25	; 0x24
    10da:	ad a3       	std	Y+37, r26	; 0x25
    10dc:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    10de:	6b a1       	ldd	r22, Y+35	; 0x23
    10e0:	7c a1       	ldd	r23, Y+36	; 0x24
    10e2:	8d a1       	ldd	r24, Y+37	; 0x25
    10e4:	9e a1       	ldd	r25, Y+38	; 0x26
    10e6:	20 e0       	ldi	r18, 0x00	; 0
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	40 e8       	ldi	r20, 0x80	; 128
    10ec:	5f e3       	ldi	r21, 0x3F	; 63
    10ee:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    10f2:	88 23       	and	r24, r24
    10f4:	2c f4       	brge	.+10     	; 0x1100 <CLCD_voidSendData+0x188>
		__ticks = 1;
    10f6:	81 e0       	ldi	r24, 0x01	; 1
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	9a a3       	std	Y+34, r25	; 0x22
    10fc:	89 a3       	std	Y+33, r24	; 0x21
    10fe:	3f c0       	rjmp	.+126    	; 0x117e <CLCD_voidSendData+0x206>
	else if (__tmp > 65535)
    1100:	6b a1       	ldd	r22, Y+35	; 0x23
    1102:	7c a1       	ldd	r23, Y+36	; 0x24
    1104:	8d a1       	ldd	r24, Y+37	; 0x25
    1106:	9e a1       	ldd	r25, Y+38	; 0x26
    1108:	20 e0       	ldi	r18, 0x00	; 0
    110a:	3f ef       	ldi	r19, 0xFF	; 255
    110c:	4f e7       	ldi	r20, 0x7F	; 127
    110e:	57 e4       	ldi	r21, 0x47	; 71
    1110:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1114:	18 16       	cp	r1, r24
    1116:	4c f5       	brge	.+82     	; 0x116a <CLCD_voidSendData+0x1f2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1118:	6f a1       	ldd	r22, Y+39	; 0x27
    111a:	78 a5       	ldd	r23, Y+40	; 0x28
    111c:	89 a5       	ldd	r24, Y+41	; 0x29
    111e:	9a a5       	ldd	r25, Y+42	; 0x2a
    1120:	20 e0       	ldi	r18, 0x00	; 0
    1122:	30 e0       	ldi	r19, 0x00	; 0
    1124:	40 e2       	ldi	r20, 0x20	; 32
    1126:	51 e4       	ldi	r21, 0x41	; 65
    1128:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    112c:	dc 01       	movw	r26, r24
    112e:	cb 01       	movw	r24, r22
    1130:	bc 01       	movw	r22, r24
    1132:	cd 01       	movw	r24, r26
    1134:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1138:	dc 01       	movw	r26, r24
    113a:	cb 01       	movw	r24, r22
    113c:	9a a3       	std	Y+34, r25	; 0x22
    113e:	89 a3       	std	Y+33, r24	; 0x21
    1140:	0f c0       	rjmp	.+30     	; 0x1160 <CLCD_voidSendData+0x1e8>
    1142:	80 e9       	ldi	r24, 0x90	; 144
    1144:	91 e0       	ldi	r25, 0x01	; 1
    1146:	98 a3       	std	Y+32, r25	; 0x20
    1148:	8f 8f       	std	Y+31, r24	; 0x1f
    114a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    114c:	98 a1       	ldd	r25, Y+32	; 0x20
    114e:	01 97       	sbiw	r24, 0x01	; 1
    1150:	f1 f7       	brne	.-4      	; 0x114e <CLCD_voidSendData+0x1d6>
    1152:	98 a3       	std	Y+32, r25	; 0x20
    1154:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1156:	89 a1       	ldd	r24, Y+33	; 0x21
    1158:	9a a1       	ldd	r25, Y+34	; 0x22
    115a:	01 97       	sbiw	r24, 0x01	; 1
    115c:	9a a3       	std	Y+34, r25	; 0x22
    115e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1160:	89 a1       	ldd	r24, Y+33	; 0x21
    1162:	9a a1       	ldd	r25, Y+34	; 0x22
    1164:	00 97       	sbiw	r24, 0x00	; 0
    1166:	69 f7       	brne	.-38     	; 0x1142 <CLCD_voidSendData+0x1ca>
    1168:	14 c0       	rjmp	.+40     	; 0x1192 <CLCD_voidSendData+0x21a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    116a:	6b a1       	ldd	r22, Y+35	; 0x23
    116c:	7c a1       	ldd	r23, Y+36	; 0x24
    116e:	8d a1       	ldd	r24, Y+37	; 0x25
    1170:	9e a1       	ldd	r25, Y+38	; 0x26
    1172:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1176:	dc 01       	movw	r26, r24
    1178:	cb 01       	movw	r24, r22
    117a:	9a a3       	std	Y+34, r25	; 0x22
    117c:	89 a3       	std	Y+33, r24	; 0x21
    117e:	89 a1       	ldd	r24, Y+33	; 0x21
    1180:	9a a1       	ldd	r25, Y+34	; 0x22
    1182:	9e 8f       	std	Y+30, r25	; 0x1e
    1184:	8d 8f       	std	Y+29, r24	; 0x1d
    1186:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1188:	9e 8d       	ldd	r25, Y+30	; 0x1e
    118a:	01 97       	sbiw	r24, 0x01	; 1
    118c:	f1 f7       	brne	.-4      	; 0x118a <CLCD_voidSendData+0x212>
    118e:	9e 8f       	std	Y+30, r25	; 0x1e
    1190:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(5);

	Local_u8Data = ((Copy_u8Data <<3) |DIO_u8AndWithPort(CLCD_DATA_PORT, 0b10000111));
    1192:	8a ad       	ldd	r24, Y+58	; 0x3a
    1194:	88 2f       	mov	r24, r24
    1196:	90 e0       	ldi	r25, 0x00	; 0
    1198:	88 0f       	add	r24, r24
    119a:	99 1f       	adc	r25, r25
    119c:	88 0f       	add	r24, r24
    119e:	99 1f       	adc	r25, r25
    11a0:	88 0f       	add	r24, r24
    11a2:	99 1f       	adc	r25, r25
    11a4:	18 2f       	mov	r17, r24
    11a6:	80 e0       	ldi	r24, 0x00	; 0
    11a8:	67 e8       	ldi	r22, 0x87	; 135
    11aa:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <DIO_u8AndWithPort>
    11ae:	81 2b       	or	r24, r17
    11b0:	89 af       	std	Y+57, r24	; 0x39

	DIO_u8SetPortValue(CLCD_DATA_PORT,Local_u8Data);
    11b2:	80 e0       	ldi	r24, 0x00	; 0
    11b4:	69 ad       	ldd	r22, Y+57	; 0x39
    11b6:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <DIO_u8SetPortValue>

	/*Send Enable pulse */
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_HIGH);
    11ba:	80 e0       	ldi	r24, 0x00	; 0
    11bc:	62 e0       	ldi	r22, 0x02	; 2
    11be:	41 e0       	ldi	r20, 0x01	; 1
    11c0:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
    11c4:	80 e0       	ldi	r24, 0x00	; 0
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	a0 e0       	ldi	r26, 0x00	; 0
    11ca:	b0 e4       	ldi	r27, 0x40	; 64
    11cc:	89 8f       	std	Y+25, r24	; 0x19
    11ce:	9a 8f       	std	Y+26, r25	; 0x1a
    11d0:	ab 8f       	std	Y+27, r26	; 0x1b
    11d2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    11d4:	69 8d       	ldd	r22, Y+25	; 0x19
    11d6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    11d8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    11da:	9c 8d       	ldd	r25, Y+28	; 0x1c
    11dc:	20 e0       	ldi	r18, 0x00	; 0
    11de:	30 e0       	ldi	r19, 0x00	; 0
    11e0:	4a e7       	ldi	r20, 0x7A	; 122
    11e2:	55 e4       	ldi	r21, 0x45	; 69
    11e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    11e8:	dc 01       	movw	r26, r24
    11ea:	cb 01       	movw	r24, r22
    11ec:	8d 8b       	std	Y+21, r24	; 0x15
    11ee:	9e 8b       	std	Y+22, r25	; 0x16
    11f0:	af 8b       	std	Y+23, r26	; 0x17
    11f2:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    11f4:	6d 89       	ldd	r22, Y+21	; 0x15
    11f6:	7e 89       	ldd	r23, Y+22	; 0x16
    11f8:	8f 89       	ldd	r24, Y+23	; 0x17
    11fa:	98 8d       	ldd	r25, Y+24	; 0x18
    11fc:	20 e0       	ldi	r18, 0x00	; 0
    11fe:	30 e0       	ldi	r19, 0x00	; 0
    1200:	40 e8       	ldi	r20, 0x80	; 128
    1202:	5f e3       	ldi	r21, 0x3F	; 63
    1204:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1208:	88 23       	and	r24, r24
    120a:	2c f4       	brge	.+10     	; 0x1216 <CLCD_voidSendData+0x29e>
		__ticks = 1;
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	90 e0       	ldi	r25, 0x00	; 0
    1210:	9c 8b       	std	Y+20, r25	; 0x14
    1212:	8b 8b       	std	Y+19, r24	; 0x13
    1214:	3f c0       	rjmp	.+126    	; 0x1294 <CLCD_voidSendData+0x31c>
	else if (__tmp > 65535)
    1216:	6d 89       	ldd	r22, Y+21	; 0x15
    1218:	7e 89       	ldd	r23, Y+22	; 0x16
    121a:	8f 89       	ldd	r24, Y+23	; 0x17
    121c:	98 8d       	ldd	r25, Y+24	; 0x18
    121e:	20 e0       	ldi	r18, 0x00	; 0
    1220:	3f ef       	ldi	r19, 0xFF	; 255
    1222:	4f e7       	ldi	r20, 0x7F	; 127
    1224:	57 e4       	ldi	r21, 0x47	; 71
    1226:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    122a:	18 16       	cp	r1, r24
    122c:	4c f5       	brge	.+82     	; 0x1280 <CLCD_voidSendData+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    122e:	69 8d       	ldd	r22, Y+25	; 0x19
    1230:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1232:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1234:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1236:	20 e0       	ldi	r18, 0x00	; 0
    1238:	30 e0       	ldi	r19, 0x00	; 0
    123a:	40 e2       	ldi	r20, 0x20	; 32
    123c:	51 e4       	ldi	r21, 0x41	; 65
    123e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1242:	dc 01       	movw	r26, r24
    1244:	cb 01       	movw	r24, r22
    1246:	bc 01       	movw	r22, r24
    1248:	cd 01       	movw	r24, r26
    124a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    124e:	dc 01       	movw	r26, r24
    1250:	cb 01       	movw	r24, r22
    1252:	9c 8b       	std	Y+20, r25	; 0x14
    1254:	8b 8b       	std	Y+19, r24	; 0x13
    1256:	0f c0       	rjmp	.+30     	; 0x1276 <CLCD_voidSendData+0x2fe>
    1258:	80 e9       	ldi	r24, 0x90	; 144
    125a:	91 e0       	ldi	r25, 0x01	; 1
    125c:	9a 8b       	std	Y+18, r25	; 0x12
    125e:	89 8b       	std	Y+17, r24	; 0x11
    1260:	89 89       	ldd	r24, Y+17	; 0x11
    1262:	9a 89       	ldd	r25, Y+18	; 0x12
    1264:	01 97       	sbiw	r24, 0x01	; 1
    1266:	f1 f7       	brne	.-4      	; 0x1264 <CLCD_voidSendData+0x2ec>
    1268:	9a 8b       	std	Y+18, r25	; 0x12
    126a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    126c:	8b 89       	ldd	r24, Y+19	; 0x13
    126e:	9c 89       	ldd	r25, Y+20	; 0x14
    1270:	01 97       	sbiw	r24, 0x01	; 1
    1272:	9c 8b       	std	Y+20, r25	; 0x14
    1274:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1276:	8b 89       	ldd	r24, Y+19	; 0x13
    1278:	9c 89       	ldd	r25, Y+20	; 0x14
    127a:	00 97       	sbiw	r24, 0x00	; 0
    127c:	69 f7       	brne	.-38     	; 0x1258 <CLCD_voidSendData+0x2e0>
    127e:	14 c0       	rjmp	.+40     	; 0x12a8 <CLCD_voidSendData+0x330>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1280:	6d 89       	ldd	r22, Y+21	; 0x15
    1282:	7e 89       	ldd	r23, Y+22	; 0x16
    1284:	8f 89       	ldd	r24, Y+23	; 0x17
    1286:	98 8d       	ldd	r25, Y+24	; 0x18
    1288:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    128c:	dc 01       	movw	r26, r24
    128e:	cb 01       	movw	r24, r22
    1290:	9c 8b       	std	Y+20, r25	; 0x14
    1292:	8b 8b       	std	Y+19, r24	; 0x13
    1294:	8b 89       	ldd	r24, Y+19	; 0x13
    1296:	9c 89       	ldd	r25, Y+20	; 0x14
    1298:	98 8b       	std	Y+16, r25	; 0x10
    129a:	8f 87       	std	Y+15, r24	; 0x0f
    129c:	8f 85       	ldd	r24, Y+15	; 0x0f
    129e:	98 89       	ldd	r25, Y+16	; 0x10
    12a0:	01 97       	sbiw	r24, 0x01	; 1
    12a2:	f1 f7       	brne	.-4      	; 0x12a0 <CLCD_voidSendData+0x328>
    12a4:	98 8b       	std	Y+16, r25	; 0x10
    12a6:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_LOW);
    12a8:	80 e0       	ldi	r24, 0x00	; 0
    12aa:	62 e0       	ldi	r22, 0x02	; 2
    12ac:	40 e0       	ldi	r20, 0x00	; 0
    12ae:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <DIO_u8SetPinValue>
    12b2:	80 e0       	ldi	r24, 0x00	; 0
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	a0 ea       	ldi	r26, 0xA0	; 160
    12b8:	b0 e4       	ldi	r27, 0x40	; 64
    12ba:	8b 87       	std	Y+11, r24	; 0x0b
    12bc:	9c 87       	std	Y+12, r25	; 0x0c
    12be:	ad 87       	std	Y+13, r26	; 0x0d
    12c0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    12c2:	6b 85       	ldd	r22, Y+11	; 0x0b
    12c4:	7c 85       	ldd	r23, Y+12	; 0x0c
    12c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    12c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    12ca:	20 e0       	ldi	r18, 0x00	; 0
    12cc:	30 e0       	ldi	r19, 0x00	; 0
    12ce:	4a e7       	ldi	r20, 0x7A	; 122
    12d0:	55 e4       	ldi	r21, 0x45	; 69
    12d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    12d6:	dc 01       	movw	r26, r24
    12d8:	cb 01       	movw	r24, r22
    12da:	8f 83       	std	Y+7, r24	; 0x07
    12dc:	98 87       	std	Y+8, r25	; 0x08
    12de:	a9 87       	std	Y+9, r26	; 0x09
    12e0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    12e2:	6f 81       	ldd	r22, Y+7	; 0x07
    12e4:	78 85       	ldd	r23, Y+8	; 0x08
    12e6:	89 85       	ldd	r24, Y+9	; 0x09
    12e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    12ea:	20 e0       	ldi	r18, 0x00	; 0
    12ec:	30 e0       	ldi	r19, 0x00	; 0
    12ee:	40 e8       	ldi	r20, 0x80	; 128
    12f0:	5f e3       	ldi	r21, 0x3F	; 63
    12f2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    12f6:	88 23       	and	r24, r24
    12f8:	2c f4       	brge	.+10     	; 0x1304 <CLCD_voidSendData+0x38c>
		__ticks = 1;
    12fa:	81 e0       	ldi	r24, 0x01	; 1
    12fc:	90 e0       	ldi	r25, 0x00	; 0
    12fe:	9e 83       	std	Y+6, r25	; 0x06
    1300:	8d 83       	std	Y+5, r24	; 0x05
    1302:	3f c0       	rjmp	.+126    	; 0x1382 <CLCD_voidSendData+0x40a>
	else if (__tmp > 65535)
    1304:	6f 81       	ldd	r22, Y+7	; 0x07
    1306:	78 85       	ldd	r23, Y+8	; 0x08
    1308:	89 85       	ldd	r24, Y+9	; 0x09
    130a:	9a 85       	ldd	r25, Y+10	; 0x0a
    130c:	20 e0       	ldi	r18, 0x00	; 0
    130e:	3f ef       	ldi	r19, 0xFF	; 255
    1310:	4f e7       	ldi	r20, 0x7F	; 127
    1312:	57 e4       	ldi	r21, 0x47	; 71
    1314:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1318:	18 16       	cp	r1, r24
    131a:	4c f5       	brge	.+82     	; 0x136e <CLCD_voidSendData+0x3f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    131c:	6b 85       	ldd	r22, Y+11	; 0x0b
    131e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1320:	8d 85       	ldd	r24, Y+13	; 0x0d
    1322:	9e 85       	ldd	r25, Y+14	; 0x0e
    1324:	20 e0       	ldi	r18, 0x00	; 0
    1326:	30 e0       	ldi	r19, 0x00	; 0
    1328:	40 e2       	ldi	r20, 0x20	; 32
    132a:	51 e4       	ldi	r21, 0x41	; 65
    132c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1330:	dc 01       	movw	r26, r24
    1332:	cb 01       	movw	r24, r22
    1334:	bc 01       	movw	r22, r24
    1336:	cd 01       	movw	r24, r26
    1338:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    133c:	dc 01       	movw	r26, r24
    133e:	cb 01       	movw	r24, r22
    1340:	9e 83       	std	Y+6, r25	; 0x06
    1342:	8d 83       	std	Y+5, r24	; 0x05
    1344:	0f c0       	rjmp	.+30     	; 0x1364 <CLCD_voidSendData+0x3ec>
    1346:	80 e9       	ldi	r24, 0x90	; 144
    1348:	91 e0       	ldi	r25, 0x01	; 1
    134a:	9c 83       	std	Y+4, r25	; 0x04
    134c:	8b 83       	std	Y+3, r24	; 0x03
    134e:	8b 81       	ldd	r24, Y+3	; 0x03
    1350:	9c 81       	ldd	r25, Y+4	; 0x04
    1352:	01 97       	sbiw	r24, 0x01	; 1
    1354:	f1 f7       	brne	.-4      	; 0x1352 <CLCD_voidSendData+0x3da>
    1356:	9c 83       	std	Y+4, r25	; 0x04
    1358:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    135a:	8d 81       	ldd	r24, Y+5	; 0x05
    135c:	9e 81       	ldd	r25, Y+6	; 0x06
    135e:	01 97       	sbiw	r24, 0x01	; 1
    1360:	9e 83       	std	Y+6, r25	; 0x06
    1362:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1364:	8d 81       	ldd	r24, Y+5	; 0x05
    1366:	9e 81       	ldd	r25, Y+6	; 0x06
    1368:	00 97       	sbiw	r24, 0x00	; 0
    136a:	69 f7       	brne	.-38     	; 0x1346 <CLCD_voidSendData+0x3ce>
    136c:	14 c0       	rjmp	.+40     	; 0x1396 <CLCD_voidSendData+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    136e:	6f 81       	ldd	r22, Y+7	; 0x07
    1370:	78 85       	ldd	r23, Y+8	; 0x08
    1372:	89 85       	ldd	r24, Y+9	; 0x09
    1374:	9a 85       	ldd	r25, Y+10	; 0x0a
    1376:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    137a:	dc 01       	movw	r26, r24
    137c:	cb 01       	movw	r24, r22
    137e:	9e 83       	std	Y+6, r25	; 0x06
    1380:	8d 83       	std	Y+5, r24	; 0x05
    1382:	8d 81       	ldd	r24, Y+5	; 0x05
    1384:	9e 81       	ldd	r25, Y+6	; 0x06
    1386:	9a 83       	std	Y+2, r25	; 0x02
    1388:	89 83       	std	Y+1, r24	; 0x01
    138a:	89 81       	ldd	r24, Y+1	; 0x01
    138c:	9a 81       	ldd	r25, Y+2	; 0x02
    138e:	01 97       	sbiw	r24, 0x01	; 1
    1390:	f1 f7       	brne	.-4      	; 0x138e <CLCD_voidSendData+0x416>
    1392:	9a 83       	std	Y+2, r25	; 0x02
    1394:	89 83       	std	Y+1, r24	; 0x01



#endif

}
    1396:	ea 96       	adiw	r28, 0x3a	; 58
    1398:	0f b6       	in	r0, 0x3f	; 63
    139a:	f8 94       	cli
    139c:	de bf       	out	0x3e, r29	; 62
    139e:	0f be       	out	0x3f, r0	; 63
    13a0:	cd bf       	out	0x3d, r28	; 61
    13a2:	cf 91       	pop	r28
    13a4:	df 91       	pop	r29
    13a6:	1f 91       	pop	r17
    13a8:	08 95       	ret

000013aa <CLCD_voidInit>:

void CLCD_voidInit(void)
{
    13aa:	df 93       	push	r29
    13ac:	cf 93       	push	r28
    13ae:	cd b7       	in	r28, 0x3d	; 61
    13b0:	de b7       	in	r29, 0x3e	; 62
    13b2:	2e 97       	sbiw	r28, 0x0e	; 14
    13b4:	0f b6       	in	r0, 0x3f	; 63
    13b6:	f8 94       	cli
    13b8:	de bf       	out	0x3e, r29	; 62
    13ba:	0f be       	out	0x3f, r0	; 63
    13bc:	cd bf       	out	0x3d, r28	; 61
	/* Set Pin Direction CTRL PIN */

	DIO_u8SetPinDirection(CLCD_CTRL_PORT,CLCD_E_PIN,DIO_u8PIN_OUTPUT);
    13be:	80 e0       	ldi	r24, 0x00	; 0
    13c0:	62 e0       	ldi	r22, 0x02	; 2
    13c2:	41 e0       	ldi	r20, 0x01	; 1
    13c4:	0e 94 ba 0b 	call	0x1774	; 0x1774 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(CLCD_CTRL_PORT,CLCD_RS_PIN,DIO_u8PIN_OUTPUT);
    13c8:	80 e0       	ldi	r24, 0x00	; 0
    13ca:	61 e0       	ldi	r22, 0x01	; 1
    13cc:	41 e0       	ldi	r20, 0x01	; 1
    13ce:	0e 94 ba 0b 	call	0x1774	; 0x1774 <DIO_u8SetPinDirection>
	/* Set Pin Direction DATA PIN */

#if     MODE_SELECT ==_8_BIT_MODE
	DIO_u8SetPortDirection(CLCD_DATA_PORT,DIO_u8PORT_OUTPUT);
#elif   MODE_SELECT ==_4_BIT_MODE
	DIO_u8SetPinDirection(CLCD_DATA_PORT,CLCD_DATA_4Bit_PIN_0,DIO_u8PIN_OUTPUT);
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	63 e0       	ldi	r22, 0x03	; 3
    13d6:	41 e0       	ldi	r20, 0x01	; 1
    13d8:	0e 94 ba 0b 	call	0x1774	; 0x1774 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(CLCD_DATA_PORT,CLCD_DATA_4Bit_PIN_1,DIO_u8PIN_OUTPUT);
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	64 e0       	ldi	r22, 0x04	; 4
    13e0:	41 e0       	ldi	r20, 0x01	; 1
    13e2:	0e 94 ba 0b 	call	0x1774	; 0x1774 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(CLCD_DATA_PORT,CLCD_DATA_4Bit_PIN_2,DIO_u8PIN_OUTPUT);
    13e6:	80 e0       	ldi	r24, 0x00	; 0
    13e8:	65 e0       	ldi	r22, 0x05	; 5
    13ea:	41 e0       	ldi	r20, 0x01	; 1
    13ec:	0e 94 ba 0b 	call	0x1774	; 0x1774 <DIO_u8SetPinDirection>
	DIO_u8SetPinDirection(CLCD_DATA_PORT,CLCD_DATA_4Bit_PIN_3,DIO_u8PIN_OUTPUT);
    13f0:	80 e0       	ldi	r24, 0x00	; 0
    13f2:	66 e0       	ldi	r22, 0x06	; 6
    13f4:	41 e0       	ldi	r20, 0x01	; 1
    13f6:	0e 94 ba 0b 	call	0x1774	; 0x1774 <DIO_u8SetPinDirection>
    13fa:	80 e0       	ldi	r24, 0x00	; 0
    13fc:	90 e0       	ldi	r25, 0x00	; 0
    13fe:	a0 e2       	ldi	r26, 0x20	; 32
    1400:	b2 e4       	ldi	r27, 0x42	; 66
    1402:	8b 87       	std	Y+11, r24	; 0x0b
    1404:	9c 87       	std	Y+12, r25	; 0x0c
    1406:	ad 87       	std	Y+13, r26	; 0x0d
    1408:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    140a:	6b 85       	ldd	r22, Y+11	; 0x0b
    140c:	7c 85       	ldd	r23, Y+12	; 0x0c
    140e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1410:	9e 85       	ldd	r25, Y+14	; 0x0e
    1412:	20 e0       	ldi	r18, 0x00	; 0
    1414:	30 e0       	ldi	r19, 0x00	; 0
    1416:	4a e7       	ldi	r20, 0x7A	; 122
    1418:	55 e4       	ldi	r21, 0x45	; 69
    141a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    141e:	dc 01       	movw	r26, r24
    1420:	cb 01       	movw	r24, r22
    1422:	8f 83       	std	Y+7, r24	; 0x07
    1424:	98 87       	std	Y+8, r25	; 0x08
    1426:	a9 87       	std	Y+9, r26	; 0x09
    1428:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    142a:	6f 81       	ldd	r22, Y+7	; 0x07
    142c:	78 85       	ldd	r23, Y+8	; 0x08
    142e:	89 85       	ldd	r24, Y+9	; 0x09
    1430:	9a 85       	ldd	r25, Y+10	; 0x0a
    1432:	20 e0       	ldi	r18, 0x00	; 0
    1434:	30 e0       	ldi	r19, 0x00	; 0
    1436:	40 e8       	ldi	r20, 0x80	; 128
    1438:	5f e3       	ldi	r21, 0x3F	; 63
    143a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    143e:	88 23       	and	r24, r24
    1440:	2c f4       	brge	.+10     	; 0x144c <CLCD_voidInit+0xa2>
		__ticks = 1;
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	9e 83       	std	Y+6, r25	; 0x06
    1448:	8d 83       	std	Y+5, r24	; 0x05
    144a:	3f c0       	rjmp	.+126    	; 0x14ca <CLCD_voidInit+0x120>
	else if (__tmp > 65535)
    144c:	6f 81       	ldd	r22, Y+7	; 0x07
    144e:	78 85       	ldd	r23, Y+8	; 0x08
    1450:	89 85       	ldd	r24, Y+9	; 0x09
    1452:	9a 85       	ldd	r25, Y+10	; 0x0a
    1454:	20 e0       	ldi	r18, 0x00	; 0
    1456:	3f ef       	ldi	r19, 0xFF	; 255
    1458:	4f e7       	ldi	r20, 0x7F	; 127
    145a:	57 e4       	ldi	r21, 0x47	; 71
    145c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1460:	18 16       	cp	r1, r24
    1462:	4c f5       	brge	.+82     	; 0x14b6 <CLCD_voidInit+0x10c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1464:	6b 85       	ldd	r22, Y+11	; 0x0b
    1466:	7c 85       	ldd	r23, Y+12	; 0x0c
    1468:	8d 85       	ldd	r24, Y+13	; 0x0d
    146a:	9e 85       	ldd	r25, Y+14	; 0x0e
    146c:	20 e0       	ldi	r18, 0x00	; 0
    146e:	30 e0       	ldi	r19, 0x00	; 0
    1470:	40 e2       	ldi	r20, 0x20	; 32
    1472:	51 e4       	ldi	r21, 0x41	; 65
    1474:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1478:	dc 01       	movw	r26, r24
    147a:	cb 01       	movw	r24, r22
    147c:	bc 01       	movw	r22, r24
    147e:	cd 01       	movw	r24, r26
    1480:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1484:	dc 01       	movw	r26, r24
    1486:	cb 01       	movw	r24, r22
    1488:	9e 83       	std	Y+6, r25	; 0x06
    148a:	8d 83       	std	Y+5, r24	; 0x05
    148c:	0f c0       	rjmp	.+30     	; 0x14ac <CLCD_voidInit+0x102>
    148e:	80 e9       	ldi	r24, 0x90	; 144
    1490:	91 e0       	ldi	r25, 0x01	; 1
    1492:	9c 83       	std	Y+4, r25	; 0x04
    1494:	8b 83       	std	Y+3, r24	; 0x03
    1496:	8b 81       	ldd	r24, Y+3	; 0x03
    1498:	9c 81       	ldd	r25, Y+4	; 0x04
    149a:	01 97       	sbiw	r24, 0x01	; 1
    149c:	f1 f7       	brne	.-4      	; 0x149a <CLCD_voidInit+0xf0>
    149e:	9c 83       	std	Y+4, r25	; 0x04
    14a0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    14a2:	8d 81       	ldd	r24, Y+5	; 0x05
    14a4:	9e 81       	ldd	r25, Y+6	; 0x06
    14a6:	01 97       	sbiw	r24, 0x01	; 1
    14a8:	9e 83       	std	Y+6, r25	; 0x06
    14aa:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    14ac:	8d 81       	ldd	r24, Y+5	; 0x05
    14ae:	9e 81       	ldd	r25, Y+6	; 0x06
    14b0:	00 97       	sbiw	r24, 0x00	; 0
    14b2:	69 f7       	brne	.-38     	; 0x148e <CLCD_voidInit+0xe4>
    14b4:	14 c0       	rjmp	.+40     	; 0x14de <CLCD_voidInit+0x134>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    14b6:	6f 81       	ldd	r22, Y+7	; 0x07
    14b8:	78 85       	ldd	r23, Y+8	; 0x08
    14ba:	89 85       	ldd	r24, Y+9	; 0x09
    14bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    14be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14c2:	dc 01       	movw	r26, r24
    14c4:	cb 01       	movw	r24, r22
    14c6:	9e 83       	std	Y+6, r25	; 0x06
    14c8:	8d 83       	std	Y+5, r24	; 0x05
    14ca:	8d 81       	ldd	r24, Y+5	; 0x05
    14cc:	9e 81       	ldd	r25, Y+6	; 0x06
    14ce:	9a 83       	std	Y+2, r25	; 0x02
    14d0:	89 83       	std	Y+1, r24	; 0x01
    14d2:	89 81       	ldd	r24, Y+1	; 0x01
    14d4:	9a 81       	ldd	r25, Y+2	; 0x02
    14d6:	01 97       	sbiw	r24, 0x01	; 1
    14d8:	f1 f7       	brne	.-4      	; 0x14d6 <CLCD_voidInit+0x12c>
    14da:	9a 83       	std	Y+2, r25	; 0x02
    14dc:	89 83       	std	Y+1, r24	; 0x01
	C_LCD_voidSendCommand(0x01); /* 1 or 0x01 or 0b00000001*/

#elif   MODE_SELECT ==_4_BIT_MODE

	/* Function set command : 2 lines , 5*8 font size */
	C_LCD_voidSendCommand(0x33);
    14de:	83 e3       	ldi	r24, 0x33	; 51
    14e0:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>
	C_LCD_voidSendCommand(0x32);
    14e4:	82 e3       	ldi	r24, 0x32	; 50
    14e6:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>
	C_LCD_voidSendCommand(0x28);   /* 0bNFXXXXXX  --> N: no of lines F: font size*/
    14ea:	88 e2       	ldi	r24, 0x28	; 40
    14ec:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>


	/*Display on off control : disable enable , disable cursor , no blink cursor*/
	C_LCD_voidSendCommand(0x0C);
    14f0:	8c e0       	ldi	r24, 0x0C	; 12
    14f2:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>
	C_LCD_voidSendCommand(0x02);
    14f6:	82 e0       	ldi	r24, 0x02	; 2
    14f8:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>

	C_LCD_voidSendCommand(0x06);
    14fc:	86 e0       	ldi	r24, 0x06	; 6
    14fe:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>

	/* Clear display */
	C_LCD_voidSendCommand(0x01);
    1502:	81 e0       	ldi	r24, 0x01	; 1
    1504:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>


#endif


}
    1508:	2e 96       	adiw	r28, 0x0e	; 14
    150a:	0f b6       	in	r0, 0x3f	; 63
    150c:	f8 94       	cli
    150e:	de bf       	out	0x3e, r29	; 62
    1510:	0f be       	out	0x3f, r0	; 63
    1512:	cd bf       	out	0x3d, r28	; 61
    1514:	cf 91       	pop	r28
    1516:	df 91       	pop	r29
    1518:	08 95       	ret

0000151a <CLCD_voidSendString>:

void CLCD_voidSendString(const char* Copy_pcString )
{
    151a:	df 93       	push	r29
    151c:	cf 93       	push	r28
    151e:	00 d0       	rcall	.+0      	; 0x1520 <CLCD_voidSendString+0x6>
    1520:	0f 92       	push	r0
    1522:	cd b7       	in	r28, 0x3d	; 61
    1524:	de b7       	in	r29, 0x3e	; 62
    1526:	9b 83       	std	Y+3, r25	; 0x03
    1528:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Counter = 0;
    152a:	19 82       	std	Y+1, r1	; 0x01
    152c:	0e c0       	rjmp	.+28     	; 0x154a <CLCD_voidSendString+0x30>
	while (Copy_pcString[Local_u8Counter] != NULL)
	{
		CLCD_voidSendData(Copy_pcString[Local_u8Counter]);
    152e:	89 81       	ldd	r24, Y+1	; 0x01
    1530:	28 2f       	mov	r18, r24
    1532:	30 e0       	ldi	r19, 0x00	; 0
    1534:	8a 81       	ldd	r24, Y+2	; 0x02
    1536:	9b 81       	ldd	r25, Y+3	; 0x03
    1538:	fc 01       	movw	r30, r24
    153a:	e2 0f       	add	r30, r18
    153c:	f3 1f       	adc	r31, r19
    153e:	80 81       	ld	r24, Z
    1540:	0e 94 bc 07 	call	0xf78	; 0xf78 <CLCD_voidSendData>
		Local_u8Counter++;
    1544:	89 81       	ldd	r24, Y+1	; 0x01
    1546:	8f 5f       	subi	r24, 0xFF	; 255
    1548:	89 83       	std	Y+1, r24	; 0x01
}

void CLCD_voidSendString(const char* Copy_pcString )
{
	u8 Local_u8Counter = 0;
	while (Copy_pcString[Local_u8Counter] != NULL)
    154a:	89 81       	ldd	r24, Y+1	; 0x01
    154c:	28 2f       	mov	r18, r24
    154e:	30 e0       	ldi	r19, 0x00	; 0
    1550:	8a 81       	ldd	r24, Y+2	; 0x02
    1552:	9b 81       	ldd	r25, Y+3	; 0x03
    1554:	fc 01       	movw	r30, r24
    1556:	e2 0f       	add	r30, r18
    1558:	f3 1f       	adc	r31, r19
    155a:	80 81       	ld	r24, Z
    155c:	88 23       	and	r24, r24
    155e:	39 f7       	brne	.-50     	; 0x152e <CLCD_voidSendString+0x14>
	{
		CLCD_voidSendData(Copy_pcString[Local_u8Counter]);
		Local_u8Counter++;
	}
}
    1560:	0f 90       	pop	r0
    1562:	0f 90       	pop	r0
    1564:	0f 90       	pop	r0
    1566:	cf 91       	pop	r28
    1568:	df 91       	pop	r29
    156a:	08 95       	ret

0000156c <CLCD_voidGoToXY>:

void CLCD_voidGoToXY(u8 Copy_u8Xpos, u8 Copy_u8Ypos)
{
    156c:	df 93       	push	r29
    156e:	cf 93       	push	r28
    1570:	00 d0       	rcall	.+0      	; 0x1572 <CLCD_voidGoToXY+0x6>
    1572:	0f 92       	push	r0
    1574:	cd b7       	in	r28, 0x3d	; 61
    1576:	de b7       	in	r29, 0x3e	; 62
    1578:	8a 83       	std	Y+2, r24	; 0x02
    157a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8Adress=0;
    157c:	19 82       	std	Y+1, r1	; 0x01
	if (Copy_u8Xpos == 0)
    157e:	8a 81       	ldd	r24, Y+2	; 0x02
    1580:	88 23       	and	r24, r24
    1582:	19 f4       	brne	.+6      	; 0x158a <CLCD_voidGoToXY+0x1e>
	{
		Local_u8Adress = Copy_u8Ypos;
    1584:	8b 81       	ldd	r24, Y+3	; 0x03
    1586:	89 83       	std	Y+1, r24	; 0x01
    1588:	06 c0       	rjmp	.+12     	; 0x1596 <CLCD_voidGoToXY+0x2a>
	}
	else if (Copy_u8Xpos == 1)
    158a:	8a 81       	ldd	r24, Y+2	; 0x02
    158c:	81 30       	cpi	r24, 0x01	; 1
    158e:	19 f4       	brne	.+6      	; 0x1596 <CLCD_voidGoToXY+0x2a>
	{
		Local_u8Adress = Copy_u8Ypos+0x40;
    1590:	8b 81       	ldd	r24, Y+3	; 0x03
    1592:	80 5c       	subi	r24, 0xC0	; 192
    1594:	89 83       	std	Y+1, r24	; 0x01
	}

	C_LCD_voidSendCommand(Local_u8Adress+128);
    1596:	89 81       	ldd	r24, Y+1	; 0x01
    1598:	80 58       	subi	r24, 0x80	; 128
    159a:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>



}
    159e:	0f 90       	pop	r0
    15a0:	0f 90       	pop	r0
    15a2:	0f 90       	pop	r0
    15a4:	cf 91       	pop	r28
    15a6:	df 91       	pop	r29
    15a8:	08 95       	ret

000015aa <CLCD_voidWriteSpecialCharacter>:

void CLCD_voidWriteSpecialCharacter(u8* Copy_pu8Pattern, u8 Copy_u8PatternNumber, u8 Copy_u8XPos, u8 Copy_u8YPos)
{
    15aa:	df 93       	push	r29
    15ac:	cf 93       	push	r28
    15ae:	cd b7       	in	r28, 0x3d	; 61
    15b0:	de b7       	in	r29, 0x3e	; 62
    15b2:	27 97       	sbiw	r28, 0x07	; 7
    15b4:	0f b6       	in	r0, 0x3f	; 63
    15b6:	f8 94       	cli
    15b8:	de bf       	out	0x3e, r29	; 62
    15ba:	0f be       	out	0x3f, r0	; 63
    15bc:	cd bf       	out	0x3d, r28	; 61
    15be:	9c 83       	std	Y+4, r25	; 0x04
    15c0:	8b 83       	std	Y+3, r24	; 0x03
    15c2:	6d 83       	std	Y+5, r22	; 0x05
    15c4:	4e 83       	std	Y+6, r20	; 0x06
    15c6:	2f 83       	std	Y+7, r18	; 0x07
	u8 Local_u8CGRAMAddress= 0, Local_u8Iterator;
    15c8:	1a 82       	std	Y+2, r1	; 0x02
	/* Calculate the CGRAM address whose each block is 8 bytes */
	Local_u8CGRAMAddress =Copy_u8PatternNumber*8;
    15ca:	8d 81       	ldd	r24, Y+5	; 0x05
    15cc:	88 2f       	mov	r24, r24
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	88 0f       	add	r24, r24
    15d2:	99 1f       	adc	r25, r25
    15d4:	88 0f       	add	r24, r24
    15d6:	99 1f       	adc	r25, r25
    15d8:	88 0f       	add	r24, r24
    15da:	99 1f       	adc	r25, r25
    15dc:	8a 83       	std	Y+2, r24	; 0x02

	/* Send CGRAM Address command to LCD, with setting bit 6, clearing bit 7*/
	C_LCD_voidSendCommand(Local_u8CGRAMAddress+64);
    15de:	8a 81       	ldd	r24, Y+2	; 0x02
    15e0:	80 5c       	subi	r24, 0xC0	; 192
    15e2:	0e 94 a3 05 	call	0xb46	; 0xb46 <C_LCD_voidSendCommand>

	/* Write the pattern into CGRAM */

	for (Local_u8Iterator=0;Local_u8Iterator<8;Local_u8Iterator++)
    15e6:	19 82       	std	Y+1, r1	; 0x01
    15e8:	0e c0       	rjmp	.+28     	; 0x1606 <CLCD_voidWriteSpecialCharacter+0x5c>
	{
		CLCD_voidSendData(Copy_pu8Pattern[Local_u8Iterator]);
    15ea:	89 81       	ldd	r24, Y+1	; 0x01
    15ec:	28 2f       	mov	r18, r24
    15ee:	30 e0       	ldi	r19, 0x00	; 0
    15f0:	8b 81       	ldd	r24, Y+3	; 0x03
    15f2:	9c 81       	ldd	r25, Y+4	; 0x04
    15f4:	fc 01       	movw	r30, r24
    15f6:	e2 0f       	add	r30, r18
    15f8:	f3 1f       	adc	r31, r19
    15fa:	80 81       	ld	r24, Z
    15fc:	0e 94 bc 07 	call	0xf78	; 0xf78 <CLCD_voidSendData>
	/* Send CGRAM Address command to LCD, with setting bit 6, clearing bit 7*/
	C_LCD_voidSendCommand(Local_u8CGRAMAddress+64);

	/* Write the pattern into CGRAM */

	for (Local_u8Iterator=0;Local_u8Iterator<8;Local_u8Iterator++)
    1600:	89 81       	ldd	r24, Y+1	; 0x01
    1602:	8f 5f       	subi	r24, 0xFF	; 255
    1604:	89 83       	std	Y+1, r24	; 0x01
    1606:	89 81       	ldd	r24, Y+1	; 0x01
    1608:	88 30       	cpi	r24, 0x08	; 8
    160a:	78 f3       	brcs	.-34     	; 0x15ea <CLCD_voidWriteSpecialCharacter+0x40>
	{
		CLCD_voidSendData(Copy_pu8Pattern[Local_u8Iterator]);
	}

	/* go back to the DDRAM to display the Pattern*/
	CLCD_voidGoToXY(Copy_u8XPos,Copy_u8YPos);
    160c:	8e 81       	ldd	r24, Y+6	; 0x06
    160e:	6f 81       	ldd	r22, Y+7	; 0x07
    1610:	0e 94 b6 0a 	call	0x156c	; 0x156c <CLCD_voidGoToXY>
	/* Display the pattern written in the CGRAM*/
	CLCD_voidSendData(Copy_u8PatternNumber);
    1614:	8d 81       	ldd	r24, Y+5	; 0x05
    1616:	0e 94 bc 07 	call	0xf78	; 0xf78 <CLCD_voidSendData>
}
    161a:	27 96       	adiw	r28, 0x07	; 7
    161c:	0f b6       	in	r0, 0x3f	; 63
    161e:	f8 94       	cli
    1620:	de bf       	out	0x3e, r29	; 62
    1622:	0f be       	out	0x3f, r0	; 63
    1624:	cd bf       	out	0x3d, r28	; 61
    1626:	cf 91       	pop	r28
    1628:	df 91       	pop	r29
    162a:	08 95       	ret

0000162c <CLCD_VoidWriteNumber>:

void CLCD_VoidWriteNumber(f32 Copy_u32Number)
{
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	df 93       	push	r29
    1632:	cf 93       	push	r28
    1634:	cd b7       	in	r28, 0x3d	; 61
    1636:	de b7       	in	r29, 0x3e	; 62
    1638:	6d 97       	sbiw	r28, 0x1d	; 29
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	de bf       	out	0x3e, r29	; 62
    1640:	0f be       	out	0x3f, r0	; 63
    1642:	cd bf       	out	0x3d, r28	; 61
    1644:	6a 8f       	std	Y+26, r22	; 0x1a
    1646:	7b 8f       	std	Y+27, r23	; 0x1b
    1648:	8c 8f       	std	Y+28, r24	; 0x1c
    164a:	9d 8f       	std	Y+29, r25	; 0x1d
	s32 Local_s32Number = Copy_u32Number;
    164c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    164e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1650:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1652:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1654:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
    1658:	dc 01       	movw	r26, r24
    165a:	cb 01       	movw	r24, r22
    165c:	8a 83       	std	Y+2, r24	; 0x02
    165e:	9b 83       	std	Y+3, r25	; 0x03
    1660:	ac 83       	std	Y+4, r26	; 0x04
    1662:	bd 83       	std	Y+5, r27	; 0x05

	if(Local_s32Number == 0)
    1664:	8a 81       	ldd	r24, Y+2	; 0x02
    1666:	9b 81       	ldd	r25, Y+3	; 0x03
    1668:	ac 81       	ldd	r26, Y+4	; 0x04
    166a:	bd 81       	ldd	r27, Y+5	; 0x05
    166c:	00 97       	sbiw	r24, 0x00	; 0
    166e:	a1 05       	cpc	r26, r1
    1670:	b1 05       	cpc	r27, r1
    1672:	21 f4       	brne	.+8      	; 0x167c <CLCD_VoidWriteNumber+0x50>
	{
		CLCD_voidSendData('0');
    1674:	80 e3       	ldi	r24, 0x30	; 48
    1676:	0e 94 bc 07 	call	0xf78	; 0xf78 <CLCD_voidSendData>
    167a:	18 c0       	rjmp	.+48     	; 0x16ac <CLCD_VoidWriteNumber+0x80>
	}
	else if (Local_s32Number <0)
    167c:	8a 81       	ldd	r24, Y+2	; 0x02
    167e:	9b 81       	ldd	r25, Y+3	; 0x03
    1680:	ac 81       	ldd	r26, Y+4	; 0x04
    1682:	bd 81       	ldd	r27, Y+5	; 0x05
    1684:	bb 23       	and	r27, r27
    1686:	94 f4       	brge	.+36     	; 0x16ac <CLCD_VoidWriteNumber+0x80>
	{
		CLCD_voidSendData('-');
    1688:	8d e2       	ldi	r24, 0x2D	; 45
    168a:	0e 94 bc 07 	call	0xf78	; 0xf78 <CLCD_voidSendData>
		Local_s32Number = Local_s32Number *(-1);
    168e:	8a 81       	ldd	r24, Y+2	; 0x02
    1690:	9b 81       	ldd	r25, Y+3	; 0x03
    1692:	ac 81       	ldd	r26, Y+4	; 0x04
    1694:	bd 81       	ldd	r27, Y+5	; 0x05
    1696:	b0 95       	com	r27
    1698:	a0 95       	com	r26
    169a:	90 95       	com	r25
    169c:	81 95       	neg	r24
    169e:	9f 4f       	sbci	r25, 0xFF	; 255
    16a0:	af 4f       	sbci	r26, 0xFF	; 255
    16a2:	bf 4f       	sbci	r27, 0xFF	; 255
    16a4:	8a 83       	std	Y+2, r24	; 0x02
    16a6:	9b 83       	std	Y+3, r25	; 0x03
    16a8:	ac 83       	std	Y+4, r26	; 0x04
    16aa:	bd 83       	std	Y+5, r27	; 0x05

	}
	u8 Local_u8Array[20]={0};
    16ac:	84 e1       	ldi	r24, 0x14	; 20
    16ae:	fe 01       	movw	r30, r28
    16b0:	36 96       	adiw	r30, 0x06	; 6
    16b2:	df 01       	movw	r26, r30
    16b4:	98 2f       	mov	r25, r24
    16b6:	1d 92       	st	X+, r1
    16b8:	9a 95       	dec	r25
    16ba:	e9 f7       	brne	.-6      	; 0x16b6 <CLCD_VoidWriteNumber+0x8a>
	s8 local_s8Counter =0;
    16bc:	19 82       	std	Y+1, r1	; 0x01
    16be:	2f c0       	rjmp	.+94     	; 0x171e <CLCD_VoidWriteNumber+0xf2>
	while (Local_s32Number != 0)
	{
		Local_u8Array[local_s8Counter]= Local_s32Number%10;
    16c0:	89 81       	ldd	r24, Y+1	; 0x01
    16c2:	08 2f       	mov	r16, r24
    16c4:	11 27       	eor	r17, r17
    16c6:	07 fd       	sbrc	r16, 7
    16c8:	10 95       	com	r17
    16ca:	8a 81       	ldd	r24, Y+2	; 0x02
    16cc:	9b 81       	ldd	r25, Y+3	; 0x03
    16ce:	ac 81       	ldd	r26, Y+4	; 0x04
    16d0:	bd 81       	ldd	r27, Y+5	; 0x05
    16d2:	2a e0       	ldi	r18, 0x0A	; 10
    16d4:	30 e0       	ldi	r19, 0x00	; 0
    16d6:	40 e0       	ldi	r20, 0x00	; 0
    16d8:	50 e0       	ldi	r21, 0x00	; 0
    16da:	bc 01       	movw	r22, r24
    16dc:	cd 01       	movw	r24, r26
    16de:	0e 94 b8 22 	call	0x4570	; 0x4570 <__divmodsi4>
    16e2:	dc 01       	movw	r26, r24
    16e4:	cb 01       	movw	r24, r22
    16e6:	28 2f       	mov	r18, r24
    16e8:	ce 01       	movw	r24, r28
    16ea:	06 96       	adiw	r24, 0x06	; 6
    16ec:	fc 01       	movw	r30, r24
    16ee:	e0 0f       	add	r30, r16
    16f0:	f1 1f       	adc	r31, r17
    16f2:	20 83       	st	Z, r18
		Local_s32Number/=10;
    16f4:	8a 81       	ldd	r24, Y+2	; 0x02
    16f6:	9b 81       	ldd	r25, Y+3	; 0x03
    16f8:	ac 81       	ldd	r26, Y+4	; 0x04
    16fa:	bd 81       	ldd	r27, Y+5	; 0x05
    16fc:	2a e0       	ldi	r18, 0x0A	; 10
    16fe:	30 e0       	ldi	r19, 0x00	; 0
    1700:	40 e0       	ldi	r20, 0x00	; 0
    1702:	50 e0       	ldi	r21, 0x00	; 0
    1704:	bc 01       	movw	r22, r24
    1706:	cd 01       	movw	r24, r26
    1708:	0e 94 b8 22 	call	0x4570	; 0x4570 <__divmodsi4>
    170c:	da 01       	movw	r26, r20
    170e:	c9 01       	movw	r24, r18
    1710:	8a 83       	std	Y+2, r24	; 0x02
    1712:	9b 83       	std	Y+3, r25	; 0x03
    1714:	ac 83       	std	Y+4, r26	; 0x04
    1716:	bd 83       	std	Y+5, r27	; 0x05
		local_s8Counter++;
    1718:	89 81       	ldd	r24, Y+1	; 0x01
    171a:	8f 5f       	subi	r24, 0xFF	; 255
    171c:	89 83       	std	Y+1, r24	; 0x01
		Local_s32Number = Local_s32Number *(-1);

	}
	u8 Local_u8Array[20]={0};
	s8 local_s8Counter =0;
	while (Local_s32Number != 0)
    171e:	8a 81       	ldd	r24, Y+2	; 0x02
    1720:	9b 81       	ldd	r25, Y+3	; 0x03
    1722:	ac 81       	ldd	r26, Y+4	; 0x04
    1724:	bd 81       	ldd	r27, Y+5	; 0x05
    1726:	00 97       	sbiw	r24, 0x00	; 0
    1728:	a1 05       	cpc	r26, r1
    172a:	b1 05       	cpc	r27, r1
    172c:	49 f6       	brne	.-110    	; 0x16c0 <CLCD_VoidWriteNumber+0x94>
	{
		Local_u8Array[local_s8Counter]= Local_s32Number%10;
		Local_s32Number/=10;
		local_s8Counter++;
	}
	local_s8Counter--;
    172e:	89 81       	ldd	r24, Y+1	; 0x01
    1730:	81 50       	subi	r24, 0x01	; 1
    1732:	89 83       	std	Y+1, r24	; 0x01
    1734:	11 c0       	rjmp	.+34     	; 0x1758 <CLCD_VoidWriteNumber+0x12c>
	while (local_s8Counter>=0)
	{
		CLCD_voidSendData(Local_u8Array[local_s8Counter]+'0');
    1736:	89 81       	ldd	r24, Y+1	; 0x01
    1738:	28 2f       	mov	r18, r24
    173a:	33 27       	eor	r19, r19
    173c:	27 fd       	sbrc	r18, 7
    173e:	30 95       	com	r19
    1740:	ce 01       	movw	r24, r28
    1742:	06 96       	adiw	r24, 0x06	; 6
    1744:	fc 01       	movw	r30, r24
    1746:	e2 0f       	add	r30, r18
    1748:	f3 1f       	adc	r31, r19
    174a:	80 81       	ld	r24, Z
    174c:	80 5d       	subi	r24, 0xD0	; 208
    174e:	0e 94 bc 07 	call	0xf78	; 0xf78 <CLCD_voidSendData>
		local_s8Counter--;
    1752:	89 81       	ldd	r24, Y+1	; 0x01
    1754:	81 50       	subi	r24, 0x01	; 1
    1756:	89 83       	std	Y+1, r24	; 0x01
		Local_u8Array[local_s8Counter]= Local_s32Number%10;
		Local_s32Number/=10;
		local_s8Counter++;
	}
	local_s8Counter--;
	while (local_s8Counter>=0)
    1758:	89 81       	ldd	r24, Y+1	; 0x01
    175a:	88 23       	and	r24, r24
    175c:	64 f7       	brge	.-40     	; 0x1736 <CLCD_VoidWriteNumber+0x10a>
		CLCD_voidSendData(Local_u8Array[local_s8Counter]+'0');
		local_s8Counter--;
	}


}
    175e:	6d 96       	adiw	r28, 0x1d	; 29
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	0f be       	out	0x3f, r0	; 63
    1768:	cd bf       	out	0x3d, r28	; 61
    176a:	cf 91       	pop	r28
    176c:	df 91       	pop	r29
    176e:	1f 91       	pop	r17
    1770:	0f 91       	pop	r16
    1772:	08 95       	ret

00001774 <DIO_u8SetPinDirection>:
#include "DIO_register.h"
#include "DIO_private.h"
#include "DIO_config.h"

u8 DIO_u8SetPinDirection(u8 Copy_u8port, u8 Copy_u8Pin, u8 Copy_u8Direction)
{
    1774:	df 93       	push	r29
    1776:	cf 93       	push	r28
    1778:	cd b7       	in	r28, 0x3d	; 61
    177a:	de b7       	in	r29, 0x3e	; 62
    177c:	28 97       	sbiw	r28, 0x08	; 8
    177e:	0f b6       	in	r0, 0x3f	; 63
    1780:	f8 94       	cli
    1782:	de bf       	out	0x3e, r29	; 62
    1784:	0f be       	out	0x3f, r0	; 63
    1786:	cd bf       	out	0x3d, r28	; 61
    1788:	8a 83       	std	Y+2, r24	; 0x02
    178a:	6b 83       	std	Y+3, r22	; 0x03
    178c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    178e:	19 82       	std	Y+1, r1	; 0x01

	if(Copy_u8Pin<=DIO_u8PIN7)
    1790:	8b 81       	ldd	r24, Y+3	; 0x03
    1792:	88 30       	cpi	r24, 0x08	; 8
    1794:	08 f0       	brcs	.+2      	; 0x1798 <DIO_u8SetPinDirection+0x24>
    1796:	f4 c0       	rjmp	.+488    	; 0x1980 <DIO_u8SetPinDirection+0x20c>
	{
		if(Copy_u8Direction == DIO_u8PIN_INPUT)
    1798:	8c 81       	ldd	r24, Y+4	; 0x04
    179a:	88 23       	and	r24, r24
    179c:	09 f0       	breq	.+2      	; 0x17a0 <DIO_u8SetPinDirection+0x2c>
    179e:	77 c0       	rjmp	.+238    	; 0x188e <DIO_u8SetPinDirection+0x11a>
		{

			switch(Copy_u8port)
    17a0:	8a 81       	ldd	r24, Y+2	; 0x02
    17a2:	28 2f       	mov	r18, r24
    17a4:	30 e0       	ldi	r19, 0x00	; 0
    17a6:	38 87       	std	Y+8, r19	; 0x08
    17a8:	2f 83       	std	Y+7, r18	; 0x07
    17aa:	8f 81       	ldd	r24, Y+7	; 0x07
    17ac:	98 85       	ldd	r25, Y+8	; 0x08
    17ae:	81 30       	cpi	r24, 0x01	; 1
    17b0:	91 05       	cpc	r25, r1
    17b2:	59 f1       	breq	.+86     	; 0x180a <DIO_u8SetPinDirection+0x96>
    17b4:	2f 81       	ldd	r18, Y+7	; 0x07
    17b6:	38 85       	ldd	r19, Y+8	; 0x08
    17b8:	22 30       	cpi	r18, 0x02	; 2
    17ba:	31 05       	cpc	r19, r1
    17bc:	2c f4       	brge	.+10     	; 0x17c8 <DIO_u8SetPinDirection+0x54>
    17be:	8f 81       	ldd	r24, Y+7	; 0x07
    17c0:	98 85       	ldd	r25, Y+8	; 0x08
    17c2:	00 97       	sbiw	r24, 0x00	; 0
    17c4:	69 f0       	breq	.+26     	; 0x17e0 <DIO_u8SetPinDirection+0x6c>
    17c6:	60 c0       	rjmp	.+192    	; 0x1888 <DIO_u8SetPinDirection+0x114>
    17c8:	2f 81       	ldd	r18, Y+7	; 0x07
    17ca:	38 85       	ldd	r19, Y+8	; 0x08
    17cc:	22 30       	cpi	r18, 0x02	; 2
    17ce:	31 05       	cpc	r19, r1
    17d0:	89 f1       	breq	.+98     	; 0x1834 <DIO_u8SetPinDirection+0xc0>
    17d2:	8f 81       	ldd	r24, Y+7	; 0x07
    17d4:	98 85       	ldd	r25, Y+8	; 0x08
    17d6:	83 30       	cpi	r24, 0x03	; 3
    17d8:	91 05       	cpc	r25, r1
    17da:	09 f4       	brne	.+2      	; 0x17de <DIO_u8SetPinDirection+0x6a>
    17dc:	40 c0       	rjmp	.+128    	; 0x185e <DIO_u8SetPinDirection+0xea>
    17de:	54 c0       	rjmp	.+168    	; 0x1888 <DIO_u8SetPinDirection+0x114>
			{
			case DIO_u8PORTA: CLR_BIT(DDRA,Copy_u8Pin); break;
    17e0:	aa e3       	ldi	r26, 0x3A	; 58
    17e2:	b0 e0       	ldi	r27, 0x00	; 0
    17e4:	ea e3       	ldi	r30, 0x3A	; 58
    17e6:	f0 e0       	ldi	r31, 0x00	; 0
    17e8:	80 81       	ld	r24, Z
    17ea:	48 2f       	mov	r20, r24
    17ec:	8b 81       	ldd	r24, Y+3	; 0x03
    17ee:	28 2f       	mov	r18, r24
    17f0:	30 e0       	ldi	r19, 0x00	; 0
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	02 2e       	mov	r0, r18
    17f8:	02 c0       	rjmp	.+4      	; 0x17fe <DIO_u8SetPinDirection+0x8a>
    17fa:	88 0f       	add	r24, r24
    17fc:	99 1f       	adc	r25, r25
    17fe:	0a 94       	dec	r0
    1800:	e2 f7       	brpl	.-8      	; 0x17fa <DIO_u8SetPinDirection+0x86>
    1802:	80 95       	com	r24
    1804:	84 23       	and	r24, r20
    1806:	8c 93       	st	X, r24
    1808:	bd c0       	rjmp	.+378    	; 0x1984 <DIO_u8SetPinDirection+0x210>
			case DIO_u8PORTB: CLR_BIT(DDRB,Copy_u8Pin); break;
    180a:	a7 e3       	ldi	r26, 0x37	; 55
    180c:	b0 e0       	ldi	r27, 0x00	; 0
    180e:	e7 e3       	ldi	r30, 0x37	; 55
    1810:	f0 e0       	ldi	r31, 0x00	; 0
    1812:	80 81       	ld	r24, Z
    1814:	48 2f       	mov	r20, r24
    1816:	8b 81       	ldd	r24, Y+3	; 0x03
    1818:	28 2f       	mov	r18, r24
    181a:	30 e0       	ldi	r19, 0x00	; 0
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	90 e0       	ldi	r25, 0x00	; 0
    1820:	02 2e       	mov	r0, r18
    1822:	02 c0       	rjmp	.+4      	; 0x1828 <DIO_u8SetPinDirection+0xb4>
    1824:	88 0f       	add	r24, r24
    1826:	99 1f       	adc	r25, r25
    1828:	0a 94       	dec	r0
    182a:	e2 f7       	brpl	.-8      	; 0x1824 <DIO_u8SetPinDirection+0xb0>
    182c:	80 95       	com	r24
    182e:	84 23       	and	r24, r20
    1830:	8c 93       	st	X, r24
    1832:	a8 c0       	rjmp	.+336    	; 0x1984 <DIO_u8SetPinDirection+0x210>
			case DIO_u8PORTC: CLR_BIT(DDRC,Copy_u8Pin); break;
    1834:	a4 e3       	ldi	r26, 0x34	; 52
    1836:	b0 e0       	ldi	r27, 0x00	; 0
    1838:	e4 e3       	ldi	r30, 0x34	; 52
    183a:	f0 e0       	ldi	r31, 0x00	; 0
    183c:	80 81       	ld	r24, Z
    183e:	48 2f       	mov	r20, r24
    1840:	8b 81       	ldd	r24, Y+3	; 0x03
    1842:	28 2f       	mov	r18, r24
    1844:	30 e0       	ldi	r19, 0x00	; 0
    1846:	81 e0       	ldi	r24, 0x01	; 1
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	02 2e       	mov	r0, r18
    184c:	02 c0       	rjmp	.+4      	; 0x1852 <DIO_u8SetPinDirection+0xde>
    184e:	88 0f       	add	r24, r24
    1850:	99 1f       	adc	r25, r25
    1852:	0a 94       	dec	r0
    1854:	e2 f7       	brpl	.-8      	; 0x184e <DIO_u8SetPinDirection+0xda>
    1856:	80 95       	com	r24
    1858:	84 23       	and	r24, r20
    185a:	8c 93       	st	X, r24
    185c:	93 c0       	rjmp	.+294    	; 0x1984 <DIO_u8SetPinDirection+0x210>
			case DIO_u8PORTD: CLR_BIT(DDRD,Copy_u8Pin); break;
    185e:	a1 e3       	ldi	r26, 0x31	; 49
    1860:	b0 e0       	ldi	r27, 0x00	; 0
    1862:	e1 e3       	ldi	r30, 0x31	; 49
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	80 81       	ld	r24, Z
    1868:	48 2f       	mov	r20, r24
    186a:	8b 81       	ldd	r24, Y+3	; 0x03
    186c:	28 2f       	mov	r18, r24
    186e:	30 e0       	ldi	r19, 0x00	; 0
    1870:	81 e0       	ldi	r24, 0x01	; 1
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	02 2e       	mov	r0, r18
    1876:	02 c0       	rjmp	.+4      	; 0x187c <DIO_u8SetPinDirection+0x108>
    1878:	88 0f       	add	r24, r24
    187a:	99 1f       	adc	r25, r25
    187c:	0a 94       	dec	r0
    187e:	e2 f7       	brpl	.-8      	; 0x1878 <DIO_u8SetPinDirection+0x104>
    1880:	80 95       	com	r24
    1882:	84 23       	and	r24, r20
    1884:	8c 93       	st	X, r24
    1886:	7e c0       	rjmp	.+252    	; 0x1984 <DIO_u8SetPinDirection+0x210>
			default: Local_u8ErrorState =1; break;
    1888:	81 e0       	ldi	r24, 0x01	; 1
    188a:	89 83       	std	Y+1, r24	; 0x01
    188c:	7b c0       	rjmp	.+246    	; 0x1984 <DIO_u8SetPinDirection+0x210>

			}
		}
		else if(Copy_u8Direction == DIO_u8PIN_OUTPUT)
    188e:	8c 81       	ldd	r24, Y+4	; 0x04
    1890:	81 30       	cpi	r24, 0x01	; 1
    1892:	09 f0       	breq	.+2      	; 0x1896 <DIO_u8SetPinDirection+0x122>
    1894:	72 c0       	rjmp	.+228    	; 0x197a <DIO_u8SetPinDirection+0x206>
		{

			switch(Copy_u8port)
    1896:	8a 81       	ldd	r24, Y+2	; 0x02
    1898:	28 2f       	mov	r18, r24
    189a:	30 e0       	ldi	r19, 0x00	; 0
    189c:	3e 83       	std	Y+6, r19	; 0x06
    189e:	2d 83       	std	Y+5, r18	; 0x05
    18a0:	8d 81       	ldd	r24, Y+5	; 0x05
    18a2:	9e 81       	ldd	r25, Y+6	; 0x06
    18a4:	81 30       	cpi	r24, 0x01	; 1
    18a6:	91 05       	cpc	r25, r1
    18a8:	49 f1       	breq	.+82     	; 0x18fc <DIO_u8SetPinDirection+0x188>
    18aa:	2d 81       	ldd	r18, Y+5	; 0x05
    18ac:	3e 81       	ldd	r19, Y+6	; 0x06
    18ae:	22 30       	cpi	r18, 0x02	; 2
    18b0:	31 05       	cpc	r19, r1
    18b2:	2c f4       	brge	.+10     	; 0x18be <DIO_u8SetPinDirection+0x14a>
    18b4:	8d 81       	ldd	r24, Y+5	; 0x05
    18b6:	9e 81       	ldd	r25, Y+6	; 0x06
    18b8:	00 97       	sbiw	r24, 0x00	; 0
    18ba:	61 f0       	breq	.+24     	; 0x18d4 <DIO_u8SetPinDirection+0x160>
    18bc:	5b c0       	rjmp	.+182    	; 0x1974 <DIO_u8SetPinDirection+0x200>
    18be:	2d 81       	ldd	r18, Y+5	; 0x05
    18c0:	3e 81       	ldd	r19, Y+6	; 0x06
    18c2:	22 30       	cpi	r18, 0x02	; 2
    18c4:	31 05       	cpc	r19, r1
    18c6:	71 f1       	breq	.+92     	; 0x1924 <DIO_u8SetPinDirection+0x1b0>
    18c8:	8d 81       	ldd	r24, Y+5	; 0x05
    18ca:	9e 81       	ldd	r25, Y+6	; 0x06
    18cc:	83 30       	cpi	r24, 0x03	; 3
    18ce:	91 05       	cpc	r25, r1
    18d0:	e9 f1       	breq	.+122    	; 0x194c <DIO_u8SetPinDirection+0x1d8>
    18d2:	50 c0       	rjmp	.+160    	; 0x1974 <DIO_u8SetPinDirection+0x200>
			{
			case DIO_u8PORTA: SET_BIT(DDRA,Copy_u8Pin); break;
    18d4:	aa e3       	ldi	r26, 0x3A	; 58
    18d6:	b0 e0       	ldi	r27, 0x00	; 0
    18d8:	ea e3       	ldi	r30, 0x3A	; 58
    18da:	f0 e0       	ldi	r31, 0x00	; 0
    18dc:	80 81       	ld	r24, Z
    18de:	48 2f       	mov	r20, r24
    18e0:	8b 81       	ldd	r24, Y+3	; 0x03
    18e2:	28 2f       	mov	r18, r24
    18e4:	30 e0       	ldi	r19, 0x00	; 0
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	02 2e       	mov	r0, r18
    18ec:	02 c0       	rjmp	.+4      	; 0x18f2 <DIO_u8SetPinDirection+0x17e>
    18ee:	88 0f       	add	r24, r24
    18f0:	99 1f       	adc	r25, r25
    18f2:	0a 94       	dec	r0
    18f4:	e2 f7       	brpl	.-8      	; 0x18ee <DIO_u8SetPinDirection+0x17a>
    18f6:	84 2b       	or	r24, r20
    18f8:	8c 93       	st	X, r24
    18fa:	44 c0       	rjmp	.+136    	; 0x1984 <DIO_u8SetPinDirection+0x210>
			case DIO_u8PORTB: SET_BIT(DDRB,Copy_u8Pin); break;
    18fc:	a7 e3       	ldi	r26, 0x37	; 55
    18fe:	b0 e0       	ldi	r27, 0x00	; 0
    1900:	e7 e3       	ldi	r30, 0x37	; 55
    1902:	f0 e0       	ldi	r31, 0x00	; 0
    1904:	80 81       	ld	r24, Z
    1906:	48 2f       	mov	r20, r24
    1908:	8b 81       	ldd	r24, Y+3	; 0x03
    190a:	28 2f       	mov	r18, r24
    190c:	30 e0       	ldi	r19, 0x00	; 0
    190e:	81 e0       	ldi	r24, 0x01	; 1
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	02 2e       	mov	r0, r18
    1914:	02 c0       	rjmp	.+4      	; 0x191a <DIO_u8SetPinDirection+0x1a6>
    1916:	88 0f       	add	r24, r24
    1918:	99 1f       	adc	r25, r25
    191a:	0a 94       	dec	r0
    191c:	e2 f7       	brpl	.-8      	; 0x1916 <DIO_u8SetPinDirection+0x1a2>
    191e:	84 2b       	or	r24, r20
    1920:	8c 93       	st	X, r24
    1922:	30 c0       	rjmp	.+96     	; 0x1984 <DIO_u8SetPinDirection+0x210>
			case DIO_u8PORTC: SET_BIT(DDRC,Copy_u8Pin); break;
    1924:	a4 e3       	ldi	r26, 0x34	; 52
    1926:	b0 e0       	ldi	r27, 0x00	; 0
    1928:	e4 e3       	ldi	r30, 0x34	; 52
    192a:	f0 e0       	ldi	r31, 0x00	; 0
    192c:	80 81       	ld	r24, Z
    192e:	48 2f       	mov	r20, r24
    1930:	8b 81       	ldd	r24, Y+3	; 0x03
    1932:	28 2f       	mov	r18, r24
    1934:	30 e0       	ldi	r19, 0x00	; 0
    1936:	81 e0       	ldi	r24, 0x01	; 1
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	02 2e       	mov	r0, r18
    193c:	02 c0       	rjmp	.+4      	; 0x1942 <DIO_u8SetPinDirection+0x1ce>
    193e:	88 0f       	add	r24, r24
    1940:	99 1f       	adc	r25, r25
    1942:	0a 94       	dec	r0
    1944:	e2 f7       	brpl	.-8      	; 0x193e <DIO_u8SetPinDirection+0x1ca>
    1946:	84 2b       	or	r24, r20
    1948:	8c 93       	st	X, r24
    194a:	1c c0       	rjmp	.+56     	; 0x1984 <DIO_u8SetPinDirection+0x210>
			case DIO_u8PORTD: SET_BIT(DDRD,Copy_u8Pin); break;
    194c:	a1 e3       	ldi	r26, 0x31	; 49
    194e:	b0 e0       	ldi	r27, 0x00	; 0
    1950:	e1 e3       	ldi	r30, 0x31	; 49
    1952:	f0 e0       	ldi	r31, 0x00	; 0
    1954:	80 81       	ld	r24, Z
    1956:	48 2f       	mov	r20, r24
    1958:	8b 81       	ldd	r24, Y+3	; 0x03
    195a:	28 2f       	mov	r18, r24
    195c:	30 e0       	ldi	r19, 0x00	; 0
    195e:	81 e0       	ldi	r24, 0x01	; 1
    1960:	90 e0       	ldi	r25, 0x00	; 0
    1962:	02 2e       	mov	r0, r18
    1964:	02 c0       	rjmp	.+4      	; 0x196a <DIO_u8SetPinDirection+0x1f6>
    1966:	88 0f       	add	r24, r24
    1968:	99 1f       	adc	r25, r25
    196a:	0a 94       	dec	r0
    196c:	e2 f7       	brpl	.-8      	; 0x1966 <DIO_u8SetPinDirection+0x1f2>
    196e:	84 2b       	or	r24, r20
    1970:	8c 93       	st	X, r24
    1972:	08 c0       	rjmp	.+16     	; 0x1984 <DIO_u8SetPinDirection+0x210>
			default: Local_u8ErrorState =1; break;
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	89 83       	std	Y+1, r24	; 0x01
    1978:	05 c0       	rjmp	.+10     	; 0x1984 <DIO_u8SetPinDirection+0x210>

			}
		}
		else
		{
			Local_u8ErrorState = 1;
    197a:	81 e0       	ldi	r24, 0x01	; 1
    197c:	89 83       	std	Y+1, r24	; 0x01
    197e:	02 c0       	rjmp	.+4      	; 0x1984 <DIO_u8SetPinDirection+0x210>
		}

	}
	else
	{
		Local_u8ErrorState = 1;
    1980:	81 e0       	ldi	r24, 0x01	; 1
    1982:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
    1984:	89 81       	ldd	r24, Y+1	; 0x01
}
    1986:	28 96       	adiw	r28, 0x08	; 8
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	f8 94       	cli
    198c:	de bf       	out	0x3e, r29	; 62
    198e:	0f be       	out	0x3f, r0	; 63
    1990:	cd bf       	out	0x3d, r28	; 61
    1992:	cf 91       	pop	r28
    1994:	df 91       	pop	r29
    1996:	08 95       	ret

00001998 <DIO_u8SetPortDirection>:



u8 DIO_u8SetPortDirection(u8 Copy_u8port, u8 Copy_u8Direction)
{
    1998:	df 93       	push	r29
    199a:	cf 93       	push	r28
    199c:	00 d0       	rcall	.+0      	; 0x199e <DIO_u8SetPortDirection+0x6>
    199e:	00 d0       	rcall	.+0      	; 0x19a0 <DIO_u8SetPortDirection+0x8>
    19a0:	0f 92       	push	r0
    19a2:	cd b7       	in	r28, 0x3d	; 61
    19a4:	de b7       	in	r29, 0x3e	; 62
    19a6:	8a 83       	std	Y+2, r24	; 0x02
    19a8:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    19aa:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8port<=DIO_u8PORTD)
    19ac:	8a 81       	ldd	r24, Y+2	; 0x02
    19ae:	84 30       	cpi	r24, 0x04	; 4
    19b0:	b0 f5       	brcc	.+108    	; 0x1a1e <DIO_u8SetPortDirection+0x86>
	{
		switch(Copy_u8port)
    19b2:	8a 81       	ldd	r24, Y+2	; 0x02
    19b4:	28 2f       	mov	r18, r24
    19b6:	30 e0       	ldi	r19, 0x00	; 0
    19b8:	3d 83       	std	Y+5, r19	; 0x05
    19ba:	2c 83       	std	Y+4, r18	; 0x04
    19bc:	8c 81       	ldd	r24, Y+4	; 0x04
    19be:	9d 81       	ldd	r25, Y+5	; 0x05
    19c0:	81 30       	cpi	r24, 0x01	; 1
    19c2:	91 05       	cpc	r25, r1
    19c4:	d1 f0       	breq	.+52     	; 0x19fa <DIO_u8SetPortDirection+0x62>
    19c6:	2c 81       	ldd	r18, Y+4	; 0x04
    19c8:	3d 81       	ldd	r19, Y+5	; 0x05
    19ca:	22 30       	cpi	r18, 0x02	; 2
    19cc:	31 05       	cpc	r19, r1
    19ce:	2c f4       	brge	.+10     	; 0x19da <DIO_u8SetPortDirection+0x42>
    19d0:	8c 81       	ldd	r24, Y+4	; 0x04
    19d2:	9d 81       	ldd	r25, Y+5	; 0x05
    19d4:	00 97       	sbiw	r24, 0x00	; 0
    19d6:	61 f0       	breq	.+24     	; 0x19f0 <DIO_u8SetPortDirection+0x58>
    19d8:	1f c0       	rjmp	.+62     	; 0x1a18 <DIO_u8SetPortDirection+0x80>
    19da:	2c 81       	ldd	r18, Y+4	; 0x04
    19dc:	3d 81       	ldd	r19, Y+5	; 0x05
    19de:	22 30       	cpi	r18, 0x02	; 2
    19e0:	31 05       	cpc	r19, r1
    19e2:	81 f0       	breq	.+32     	; 0x1a04 <DIO_u8SetPortDirection+0x6c>
    19e4:	8c 81       	ldd	r24, Y+4	; 0x04
    19e6:	9d 81       	ldd	r25, Y+5	; 0x05
    19e8:	83 30       	cpi	r24, 0x03	; 3
    19ea:	91 05       	cpc	r25, r1
    19ec:	81 f0       	breq	.+32     	; 0x1a0e <DIO_u8SetPortDirection+0x76>
    19ee:	14 c0       	rjmp	.+40     	; 0x1a18 <DIO_u8SetPortDirection+0x80>
		{
		case DIO_u8PORTA: DDRA = Copy_u8Direction; break;
    19f0:	ea e3       	ldi	r30, 0x3A	; 58
    19f2:	f0 e0       	ldi	r31, 0x00	; 0
    19f4:	8b 81       	ldd	r24, Y+3	; 0x03
    19f6:	80 83       	st	Z, r24
    19f8:	14 c0       	rjmp	.+40     	; 0x1a22 <DIO_u8SetPortDirection+0x8a>
		case DIO_u8PORTB: DDRB = Copy_u8Direction; break;
    19fa:	e7 e3       	ldi	r30, 0x37	; 55
    19fc:	f0 e0       	ldi	r31, 0x00	; 0
    19fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1a00:	80 83       	st	Z, r24
    1a02:	0f c0       	rjmp	.+30     	; 0x1a22 <DIO_u8SetPortDirection+0x8a>
		case DIO_u8PORTC: DDRC = Copy_u8Direction; break;
    1a04:	e4 e3       	ldi	r30, 0x34	; 52
    1a06:	f0 e0       	ldi	r31, 0x00	; 0
    1a08:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0a:	80 83       	st	Z, r24
    1a0c:	0a c0       	rjmp	.+20     	; 0x1a22 <DIO_u8SetPortDirection+0x8a>
		case DIO_u8PORTD: DDRD = Copy_u8Direction; break;
    1a0e:	e1 e3       	ldi	r30, 0x31	; 49
    1a10:	f0 e0       	ldi	r31, 0x00	; 0
    1a12:	8b 81       	ldd	r24, Y+3	; 0x03
    1a14:	80 83       	st	Z, r24
    1a16:	05 c0       	rjmp	.+10     	; 0x1a22 <DIO_u8SetPortDirection+0x8a>
		default: Local_u8ErrorState =1; break;
    1a18:	81 e0       	ldi	r24, 0x01	; 1
    1a1a:	89 83       	std	Y+1, r24	; 0x01
    1a1c:	02 c0       	rjmp	.+4      	; 0x1a22 <DIO_u8SetPortDirection+0x8a>

		}
	}
	else
	{
		Local_u8ErrorState = 1;
    1a1e:	81 e0       	ldi	r24, 0x01	; 1
    1a20:	89 83       	std	Y+1, r24	; 0x01
	}


	return Local_u8ErrorState;
    1a22:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a24:	0f 90       	pop	r0
    1a26:	0f 90       	pop	r0
    1a28:	0f 90       	pop	r0
    1a2a:	0f 90       	pop	r0
    1a2c:	0f 90       	pop	r0
    1a2e:	cf 91       	pop	r28
    1a30:	df 91       	pop	r29
    1a32:	08 95       	ret

00001a34 <DIO_u8SetPinValue>:

u8 DIO_u8SetPinValue(u8 Copy_u8port, u8 Copy_u8Pin, u8 Copy_u8Value)
{
    1a34:	df 93       	push	r29
    1a36:	cf 93       	push	r28
    1a38:	cd b7       	in	r28, 0x3d	; 61
    1a3a:	de b7       	in	r29, 0x3e	; 62
    1a3c:	28 97       	sbiw	r28, 0x08	; 8
    1a3e:	0f b6       	in	r0, 0x3f	; 63
    1a40:	f8 94       	cli
    1a42:	de bf       	out	0x3e, r29	; 62
    1a44:	0f be       	out	0x3f, r0	; 63
    1a46:	cd bf       	out	0x3d, r28	; 61
    1a48:	8a 83       	std	Y+2, r24	; 0x02
    1a4a:	6b 83       	std	Y+3, r22	; 0x03
    1a4c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    1a4e:	19 82       	std	Y+1, r1	; 0x01

	if(Copy_u8Pin<=DIO_u8PIN7)
    1a50:	8b 81       	ldd	r24, Y+3	; 0x03
    1a52:	88 30       	cpi	r24, 0x08	; 8
    1a54:	08 f0       	brcs	.+2      	; 0x1a58 <DIO_u8SetPinValue+0x24>
    1a56:	f4 c0       	rjmp	.+488    	; 0x1c40 <DIO_u8SetPinValue+0x20c>
	{
		if(Copy_u8Value == DIO_u8PIN_LOW)
    1a58:	8c 81       	ldd	r24, Y+4	; 0x04
    1a5a:	88 23       	and	r24, r24
    1a5c:	09 f0       	breq	.+2      	; 0x1a60 <DIO_u8SetPinValue+0x2c>
    1a5e:	77 c0       	rjmp	.+238    	; 0x1b4e <DIO_u8SetPinValue+0x11a>
		{

			switch(Copy_u8port)
    1a60:	8a 81       	ldd	r24, Y+2	; 0x02
    1a62:	28 2f       	mov	r18, r24
    1a64:	30 e0       	ldi	r19, 0x00	; 0
    1a66:	38 87       	std	Y+8, r19	; 0x08
    1a68:	2f 83       	std	Y+7, r18	; 0x07
    1a6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1a6c:	98 85       	ldd	r25, Y+8	; 0x08
    1a6e:	81 30       	cpi	r24, 0x01	; 1
    1a70:	91 05       	cpc	r25, r1
    1a72:	59 f1       	breq	.+86     	; 0x1aca <DIO_u8SetPinValue+0x96>
    1a74:	2f 81       	ldd	r18, Y+7	; 0x07
    1a76:	38 85       	ldd	r19, Y+8	; 0x08
    1a78:	22 30       	cpi	r18, 0x02	; 2
    1a7a:	31 05       	cpc	r19, r1
    1a7c:	2c f4       	brge	.+10     	; 0x1a88 <DIO_u8SetPinValue+0x54>
    1a7e:	8f 81       	ldd	r24, Y+7	; 0x07
    1a80:	98 85       	ldd	r25, Y+8	; 0x08
    1a82:	00 97       	sbiw	r24, 0x00	; 0
    1a84:	69 f0       	breq	.+26     	; 0x1aa0 <DIO_u8SetPinValue+0x6c>
    1a86:	60 c0       	rjmp	.+192    	; 0x1b48 <DIO_u8SetPinValue+0x114>
    1a88:	2f 81       	ldd	r18, Y+7	; 0x07
    1a8a:	38 85       	ldd	r19, Y+8	; 0x08
    1a8c:	22 30       	cpi	r18, 0x02	; 2
    1a8e:	31 05       	cpc	r19, r1
    1a90:	89 f1       	breq	.+98     	; 0x1af4 <DIO_u8SetPinValue+0xc0>
    1a92:	8f 81       	ldd	r24, Y+7	; 0x07
    1a94:	98 85       	ldd	r25, Y+8	; 0x08
    1a96:	83 30       	cpi	r24, 0x03	; 3
    1a98:	91 05       	cpc	r25, r1
    1a9a:	09 f4       	brne	.+2      	; 0x1a9e <DIO_u8SetPinValue+0x6a>
    1a9c:	40 c0       	rjmp	.+128    	; 0x1b1e <DIO_u8SetPinValue+0xea>
    1a9e:	54 c0       	rjmp	.+168    	; 0x1b48 <DIO_u8SetPinValue+0x114>
			{
			case DIO_u8PORTA: CLR_BIT(PORTA,Copy_u8Pin); break;
    1aa0:	ab e3       	ldi	r26, 0x3B	; 59
    1aa2:	b0 e0       	ldi	r27, 0x00	; 0
    1aa4:	eb e3       	ldi	r30, 0x3B	; 59
    1aa6:	f0 e0       	ldi	r31, 0x00	; 0
    1aa8:	80 81       	ld	r24, Z
    1aaa:	48 2f       	mov	r20, r24
    1aac:	8b 81       	ldd	r24, Y+3	; 0x03
    1aae:	28 2f       	mov	r18, r24
    1ab0:	30 e0       	ldi	r19, 0x00	; 0
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	02 2e       	mov	r0, r18
    1ab8:	02 c0       	rjmp	.+4      	; 0x1abe <DIO_u8SetPinValue+0x8a>
    1aba:	88 0f       	add	r24, r24
    1abc:	99 1f       	adc	r25, r25
    1abe:	0a 94       	dec	r0
    1ac0:	e2 f7       	brpl	.-8      	; 0x1aba <DIO_u8SetPinValue+0x86>
    1ac2:	80 95       	com	r24
    1ac4:	84 23       	and	r24, r20
    1ac6:	8c 93       	st	X, r24
    1ac8:	bd c0       	rjmp	.+378    	; 0x1c44 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTB: CLR_BIT(PORTB,Copy_u8Pin); break;
    1aca:	a8 e3       	ldi	r26, 0x38	; 56
    1acc:	b0 e0       	ldi	r27, 0x00	; 0
    1ace:	e8 e3       	ldi	r30, 0x38	; 56
    1ad0:	f0 e0       	ldi	r31, 0x00	; 0
    1ad2:	80 81       	ld	r24, Z
    1ad4:	48 2f       	mov	r20, r24
    1ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad8:	28 2f       	mov	r18, r24
    1ada:	30 e0       	ldi	r19, 0x00	; 0
    1adc:	81 e0       	ldi	r24, 0x01	; 1
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	02 2e       	mov	r0, r18
    1ae2:	02 c0       	rjmp	.+4      	; 0x1ae8 <DIO_u8SetPinValue+0xb4>
    1ae4:	88 0f       	add	r24, r24
    1ae6:	99 1f       	adc	r25, r25
    1ae8:	0a 94       	dec	r0
    1aea:	e2 f7       	brpl	.-8      	; 0x1ae4 <DIO_u8SetPinValue+0xb0>
    1aec:	80 95       	com	r24
    1aee:	84 23       	and	r24, r20
    1af0:	8c 93       	st	X, r24
    1af2:	a8 c0       	rjmp	.+336    	; 0x1c44 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTC: CLR_BIT(PORTC,Copy_u8Pin); break;
    1af4:	a5 e3       	ldi	r26, 0x35	; 53
    1af6:	b0 e0       	ldi	r27, 0x00	; 0
    1af8:	e5 e3       	ldi	r30, 0x35	; 53
    1afa:	f0 e0       	ldi	r31, 0x00	; 0
    1afc:	80 81       	ld	r24, Z
    1afe:	48 2f       	mov	r20, r24
    1b00:	8b 81       	ldd	r24, Y+3	; 0x03
    1b02:	28 2f       	mov	r18, r24
    1b04:	30 e0       	ldi	r19, 0x00	; 0
    1b06:	81 e0       	ldi	r24, 0x01	; 1
    1b08:	90 e0       	ldi	r25, 0x00	; 0
    1b0a:	02 2e       	mov	r0, r18
    1b0c:	02 c0       	rjmp	.+4      	; 0x1b12 <DIO_u8SetPinValue+0xde>
    1b0e:	88 0f       	add	r24, r24
    1b10:	99 1f       	adc	r25, r25
    1b12:	0a 94       	dec	r0
    1b14:	e2 f7       	brpl	.-8      	; 0x1b0e <DIO_u8SetPinValue+0xda>
    1b16:	80 95       	com	r24
    1b18:	84 23       	and	r24, r20
    1b1a:	8c 93       	st	X, r24
    1b1c:	93 c0       	rjmp	.+294    	; 0x1c44 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTD: CLR_BIT(PORTD,Copy_u8Pin); break;
    1b1e:	a2 e3       	ldi	r26, 0x32	; 50
    1b20:	b0 e0       	ldi	r27, 0x00	; 0
    1b22:	e2 e3       	ldi	r30, 0x32	; 50
    1b24:	f0 e0       	ldi	r31, 0x00	; 0
    1b26:	80 81       	ld	r24, Z
    1b28:	48 2f       	mov	r20, r24
    1b2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2c:	28 2f       	mov	r18, r24
    1b2e:	30 e0       	ldi	r19, 0x00	; 0
    1b30:	81 e0       	ldi	r24, 0x01	; 1
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	02 2e       	mov	r0, r18
    1b36:	02 c0       	rjmp	.+4      	; 0x1b3c <DIO_u8SetPinValue+0x108>
    1b38:	88 0f       	add	r24, r24
    1b3a:	99 1f       	adc	r25, r25
    1b3c:	0a 94       	dec	r0
    1b3e:	e2 f7       	brpl	.-8      	; 0x1b38 <DIO_u8SetPinValue+0x104>
    1b40:	80 95       	com	r24
    1b42:	84 23       	and	r24, r20
    1b44:	8c 93       	st	X, r24
    1b46:	7e c0       	rjmp	.+252    	; 0x1c44 <DIO_u8SetPinValue+0x210>
			default: Local_u8ErrorState =1; break;
    1b48:	81 e0       	ldi	r24, 0x01	; 1
    1b4a:	89 83       	std	Y+1, r24	; 0x01
    1b4c:	7b c0       	rjmp	.+246    	; 0x1c44 <DIO_u8SetPinValue+0x210>

			}
		}
		else if(Copy_u8Value == DIO_u8PIN_HIGH)
    1b4e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b50:	81 30       	cpi	r24, 0x01	; 1
    1b52:	09 f0       	breq	.+2      	; 0x1b56 <DIO_u8SetPinValue+0x122>
    1b54:	72 c0       	rjmp	.+228    	; 0x1c3a <DIO_u8SetPinValue+0x206>
		{

			switch(Copy_u8port)
    1b56:	8a 81       	ldd	r24, Y+2	; 0x02
    1b58:	28 2f       	mov	r18, r24
    1b5a:	30 e0       	ldi	r19, 0x00	; 0
    1b5c:	3e 83       	std	Y+6, r19	; 0x06
    1b5e:	2d 83       	std	Y+5, r18	; 0x05
    1b60:	8d 81       	ldd	r24, Y+5	; 0x05
    1b62:	9e 81       	ldd	r25, Y+6	; 0x06
    1b64:	81 30       	cpi	r24, 0x01	; 1
    1b66:	91 05       	cpc	r25, r1
    1b68:	49 f1       	breq	.+82     	; 0x1bbc <DIO_u8SetPinValue+0x188>
    1b6a:	2d 81       	ldd	r18, Y+5	; 0x05
    1b6c:	3e 81       	ldd	r19, Y+6	; 0x06
    1b6e:	22 30       	cpi	r18, 0x02	; 2
    1b70:	31 05       	cpc	r19, r1
    1b72:	2c f4       	brge	.+10     	; 0x1b7e <DIO_u8SetPinValue+0x14a>
    1b74:	8d 81       	ldd	r24, Y+5	; 0x05
    1b76:	9e 81       	ldd	r25, Y+6	; 0x06
    1b78:	00 97       	sbiw	r24, 0x00	; 0
    1b7a:	61 f0       	breq	.+24     	; 0x1b94 <DIO_u8SetPinValue+0x160>
    1b7c:	5b c0       	rjmp	.+182    	; 0x1c34 <DIO_u8SetPinValue+0x200>
    1b7e:	2d 81       	ldd	r18, Y+5	; 0x05
    1b80:	3e 81       	ldd	r19, Y+6	; 0x06
    1b82:	22 30       	cpi	r18, 0x02	; 2
    1b84:	31 05       	cpc	r19, r1
    1b86:	71 f1       	breq	.+92     	; 0x1be4 <DIO_u8SetPinValue+0x1b0>
    1b88:	8d 81       	ldd	r24, Y+5	; 0x05
    1b8a:	9e 81       	ldd	r25, Y+6	; 0x06
    1b8c:	83 30       	cpi	r24, 0x03	; 3
    1b8e:	91 05       	cpc	r25, r1
    1b90:	e9 f1       	breq	.+122    	; 0x1c0c <DIO_u8SetPinValue+0x1d8>
    1b92:	50 c0       	rjmp	.+160    	; 0x1c34 <DIO_u8SetPinValue+0x200>
			{
			case DIO_u8PORTA: SET_BIT(PORTA,Copy_u8Pin); break;
    1b94:	ab e3       	ldi	r26, 0x3B	; 59
    1b96:	b0 e0       	ldi	r27, 0x00	; 0
    1b98:	eb e3       	ldi	r30, 0x3B	; 59
    1b9a:	f0 e0       	ldi	r31, 0x00	; 0
    1b9c:	80 81       	ld	r24, Z
    1b9e:	48 2f       	mov	r20, r24
    1ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ba2:	28 2f       	mov	r18, r24
    1ba4:	30 e0       	ldi	r19, 0x00	; 0
    1ba6:	81 e0       	ldi	r24, 0x01	; 1
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	02 2e       	mov	r0, r18
    1bac:	02 c0       	rjmp	.+4      	; 0x1bb2 <DIO_u8SetPinValue+0x17e>
    1bae:	88 0f       	add	r24, r24
    1bb0:	99 1f       	adc	r25, r25
    1bb2:	0a 94       	dec	r0
    1bb4:	e2 f7       	brpl	.-8      	; 0x1bae <DIO_u8SetPinValue+0x17a>
    1bb6:	84 2b       	or	r24, r20
    1bb8:	8c 93       	st	X, r24
    1bba:	44 c0       	rjmp	.+136    	; 0x1c44 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTB: SET_BIT(PORTB,Copy_u8Pin); break;
    1bbc:	a8 e3       	ldi	r26, 0x38	; 56
    1bbe:	b0 e0       	ldi	r27, 0x00	; 0
    1bc0:	e8 e3       	ldi	r30, 0x38	; 56
    1bc2:	f0 e0       	ldi	r31, 0x00	; 0
    1bc4:	80 81       	ld	r24, Z
    1bc6:	48 2f       	mov	r20, r24
    1bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bca:	28 2f       	mov	r18, r24
    1bcc:	30 e0       	ldi	r19, 0x00	; 0
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	02 2e       	mov	r0, r18
    1bd4:	02 c0       	rjmp	.+4      	; 0x1bda <DIO_u8SetPinValue+0x1a6>
    1bd6:	88 0f       	add	r24, r24
    1bd8:	99 1f       	adc	r25, r25
    1bda:	0a 94       	dec	r0
    1bdc:	e2 f7       	brpl	.-8      	; 0x1bd6 <DIO_u8SetPinValue+0x1a2>
    1bde:	84 2b       	or	r24, r20
    1be0:	8c 93       	st	X, r24
    1be2:	30 c0       	rjmp	.+96     	; 0x1c44 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTC: SET_BIT(PORTC,Copy_u8Pin); break;
    1be4:	a5 e3       	ldi	r26, 0x35	; 53
    1be6:	b0 e0       	ldi	r27, 0x00	; 0
    1be8:	e5 e3       	ldi	r30, 0x35	; 53
    1bea:	f0 e0       	ldi	r31, 0x00	; 0
    1bec:	80 81       	ld	r24, Z
    1bee:	48 2f       	mov	r20, r24
    1bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf2:	28 2f       	mov	r18, r24
    1bf4:	30 e0       	ldi	r19, 0x00	; 0
    1bf6:	81 e0       	ldi	r24, 0x01	; 1
    1bf8:	90 e0       	ldi	r25, 0x00	; 0
    1bfa:	02 2e       	mov	r0, r18
    1bfc:	02 c0       	rjmp	.+4      	; 0x1c02 <DIO_u8SetPinValue+0x1ce>
    1bfe:	88 0f       	add	r24, r24
    1c00:	99 1f       	adc	r25, r25
    1c02:	0a 94       	dec	r0
    1c04:	e2 f7       	brpl	.-8      	; 0x1bfe <DIO_u8SetPinValue+0x1ca>
    1c06:	84 2b       	or	r24, r20
    1c08:	8c 93       	st	X, r24
    1c0a:	1c c0       	rjmp	.+56     	; 0x1c44 <DIO_u8SetPinValue+0x210>
			case DIO_u8PORTD: SET_BIT(PORTD,Copy_u8Pin); break;
    1c0c:	a2 e3       	ldi	r26, 0x32	; 50
    1c0e:	b0 e0       	ldi	r27, 0x00	; 0
    1c10:	e2 e3       	ldi	r30, 0x32	; 50
    1c12:	f0 e0       	ldi	r31, 0x00	; 0
    1c14:	80 81       	ld	r24, Z
    1c16:	48 2f       	mov	r20, r24
    1c18:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1a:	28 2f       	mov	r18, r24
    1c1c:	30 e0       	ldi	r19, 0x00	; 0
    1c1e:	81 e0       	ldi	r24, 0x01	; 1
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	02 2e       	mov	r0, r18
    1c24:	02 c0       	rjmp	.+4      	; 0x1c2a <DIO_u8SetPinValue+0x1f6>
    1c26:	88 0f       	add	r24, r24
    1c28:	99 1f       	adc	r25, r25
    1c2a:	0a 94       	dec	r0
    1c2c:	e2 f7       	brpl	.-8      	; 0x1c26 <DIO_u8SetPinValue+0x1f2>
    1c2e:	84 2b       	or	r24, r20
    1c30:	8c 93       	st	X, r24
    1c32:	08 c0       	rjmp	.+16     	; 0x1c44 <DIO_u8SetPinValue+0x210>
			default: Local_u8ErrorState =1; break;
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	89 83       	std	Y+1, r24	; 0x01
    1c38:	05 c0       	rjmp	.+10     	; 0x1c44 <DIO_u8SetPinValue+0x210>

			}
		}
		else
		{
			Local_u8ErrorState = 1;
    1c3a:	81 e0       	ldi	r24, 0x01	; 1
    1c3c:	89 83       	std	Y+1, r24	; 0x01
    1c3e:	02 c0       	rjmp	.+4      	; 0x1c44 <DIO_u8SetPinValue+0x210>
		}

	}
	else
	{
		Local_u8ErrorState = 1;
    1c40:	81 e0       	ldi	r24, 0x01	; 1
    1c42:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c46:	28 96       	adiw	r28, 0x08	; 8
    1c48:	0f b6       	in	r0, 0x3f	; 63
    1c4a:	f8 94       	cli
    1c4c:	de bf       	out	0x3e, r29	; 62
    1c4e:	0f be       	out	0x3f, r0	; 63
    1c50:	cd bf       	out	0x3d, r28	; 61
    1c52:	cf 91       	pop	r28
    1c54:	df 91       	pop	r29
    1c56:	08 95       	ret

00001c58 <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue(u8 Copy_u8port, u8 Copy_u8Value)
{
    1c58:	df 93       	push	r29
    1c5a:	cf 93       	push	r28
    1c5c:	00 d0       	rcall	.+0      	; 0x1c5e <DIO_u8SetPortValue+0x6>
    1c5e:	00 d0       	rcall	.+0      	; 0x1c60 <DIO_u8SetPortValue+0x8>
    1c60:	0f 92       	push	r0
    1c62:	cd b7       	in	r28, 0x3d	; 61
    1c64:	de b7       	in	r29, 0x3e	; 62
    1c66:	8a 83       	std	Y+2, r24	; 0x02
    1c68:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    1c6a:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8port<=DIO_u8PORTD)
    1c6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c6e:	84 30       	cpi	r24, 0x04	; 4
    1c70:	b0 f5       	brcc	.+108    	; 0x1cde <DIO_u8SetPortValue+0x86>
	{
		switch(Copy_u8port)
    1c72:	8a 81       	ldd	r24, Y+2	; 0x02
    1c74:	28 2f       	mov	r18, r24
    1c76:	30 e0       	ldi	r19, 0x00	; 0
    1c78:	3d 83       	std	Y+5, r19	; 0x05
    1c7a:	2c 83       	std	Y+4, r18	; 0x04
    1c7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c7e:	9d 81       	ldd	r25, Y+5	; 0x05
    1c80:	81 30       	cpi	r24, 0x01	; 1
    1c82:	91 05       	cpc	r25, r1
    1c84:	d1 f0       	breq	.+52     	; 0x1cba <DIO_u8SetPortValue+0x62>
    1c86:	2c 81       	ldd	r18, Y+4	; 0x04
    1c88:	3d 81       	ldd	r19, Y+5	; 0x05
    1c8a:	22 30       	cpi	r18, 0x02	; 2
    1c8c:	31 05       	cpc	r19, r1
    1c8e:	2c f4       	brge	.+10     	; 0x1c9a <DIO_u8SetPortValue+0x42>
    1c90:	8c 81       	ldd	r24, Y+4	; 0x04
    1c92:	9d 81       	ldd	r25, Y+5	; 0x05
    1c94:	00 97       	sbiw	r24, 0x00	; 0
    1c96:	61 f0       	breq	.+24     	; 0x1cb0 <DIO_u8SetPortValue+0x58>
    1c98:	1f c0       	rjmp	.+62     	; 0x1cd8 <DIO_u8SetPortValue+0x80>
    1c9a:	2c 81       	ldd	r18, Y+4	; 0x04
    1c9c:	3d 81       	ldd	r19, Y+5	; 0x05
    1c9e:	22 30       	cpi	r18, 0x02	; 2
    1ca0:	31 05       	cpc	r19, r1
    1ca2:	81 f0       	breq	.+32     	; 0x1cc4 <DIO_u8SetPortValue+0x6c>
    1ca4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ca6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ca8:	83 30       	cpi	r24, 0x03	; 3
    1caa:	91 05       	cpc	r25, r1
    1cac:	81 f0       	breq	.+32     	; 0x1cce <DIO_u8SetPortValue+0x76>
    1cae:	14 c0       	rjmp	.+40     	; 0x1cd8 <DIO_u8SetPortValue+0x80>
		{
		case DIO_u8PORTA: PORTA = Copy_u8Value; break;
    1cb0:	eb e3       	ldi	r30, 0x3B	; 59
    1cb2:	f0 e0       	ldi	r31, 0x00	; 0
    1cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb6:	80 83       	st	Z, r24
    1cb8:	14 c0       	rjmp	.+40     	; 0x1ce2 <DIO_u8SetPortValue+0x8a>
		case DIO_u8PORTB: PORTB = Copy_u8Value; break;
    1cba:	e8 e3       	ldi	r30, 0x38	; 56
    1cbc:	f0 e0       	ldi	r31, 0x00	; 0
    1cbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc0:	80 83       	st	Z, r24
    1cc2:	0f c0       	rjmp	.+30     	; 0x1ce2 <DIO_u8SetPortValue+0x8a>
		case DIO_u8PORTC: PORTC = Copy_u8Value; break;
    1cc4:	e5 e3       	ldi	r30, 0x35	; 53
    1cc6:	f0 e0       	ldi	r31, 0x00	; 0
    1cc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cca:	80 83       	st	Z, r24
    1ccc:	0a c0       	rjmp	.+20     	; 0x1ce2 <DIO_u8SetPortValue+0x8a>
		case DIO_u8PORTD: PORTD = Copy_u8Value; break;
    1cce:	e2 e3       	ldi	r30, 0x32	; 50
    1cd0:	f0 e0       	ldi	r31, 0x00	; 0
    1cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd4:	80 83       	st	Z, r24
    1cd6:	05 c0       	rjmp	.+10     	; 0x1ce2 <DIO_u8SetPortValue+0x8a>
		default: Local_u8ErrorState =1; break;
    1cd8:	81 e0       	ldi	r24, 0x01	; 1
    1cda:	89 83       	std	Y+1, r24	; 0x01
    1cdc:	02 c0       	rjmp	.+4      	; 0x1ce2 <DIO_u8SetPortValue+0x8a>

		}
	}
	else
	{
		Local_u8ErrorState = 1;
    1cde:	81 e0       	ldi	r24, 0x01	; 1
    1ce0:	89 83       	std	Y+1, r24	; 0x01
	}


	return Local_u8ErrorState;
    1ce2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ce4:	0f 90       	pop	r0
    1ce6:	0f 90       	pop	r0
    1ce8:	0f 90       	pop	r0
    1cea:	0f 90       	pop	r0
    1cec:	0f 90       	pop	r0
    1cee:	cf 91       	pop	r28
    1cf0:	df 91       	pop	r29
    1cf2:	08 95       	ret

00001cf4 <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 Copy_u8port, u8 Copy_u8Pin, u8* Copy_Pu8Value)
{
    1cf4:	df 93       	push	r29
    1cf6:	cf 93       	push	r28
    1cf8:	cd b7       	in	r28, 0x3d	; 61
    1cfa:	de b7       	in	r29, 0x3e	; 62
    1cfc:	27 97       	sbiw	r28, 0x07	; 7
    1cfe:	0f b6       	in	r0, 0x3f	; 63
    1d00:	f8 94       	cli
    1d02:	de bf       	out	0x3e, r29	; 62
    1d04:	0f be       	out	0x3f, r0	; 63
    1d06:	cd bf       	out	0x3d, r28	; 61
    1d08:	8a 83       	std	Y+2, r24	; 0x02
    1d0a:	6b 83       	std	Y+3, r22	; 0x03
    1d0c:	5d 83       	std	Y+5, r21	; 0x05
    1d0e:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    1d10:	19 82       	std	Y+1, r1	; 0x01

	if((Copy_Pu8Value != NULL )&&(Copy_u8Pin<=DIO_u8PIN7))
    1d12:	8c 81       	ldd	r24, Y+4	; 0x04
    1d14:	9d 81       	ldd	r25, Y+5	; 0x05
    1d16:	00 97       	sbiw	r24, 0x00	; 0
    1d18:	09 f4       	brne	.+2      	; 0x1d1c <DIO_u8GetPinValue+0x28>
    1d1a:	78 c0       	rjmp	.+240    	; 0x1e0c <DIO_u8GetPinValue+0x118>
    1d1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d1e:	88 30       	cpi	r24, 0x08	; 8
    1d20:	08 f0       	brcs	.+2      	; 0x1d24 <DIO_u8GetPinValue+0x30>
    1d22:	74 c0       	rjmp	.+232    	; 0x1e0c <DIO_u8GetPinValue+0x118>
	{


			switch(Copy_u8port)
    1d24:	8a 81       	ldd	r24, Y+2	; 0x02
    1d26:	28 2f       	mov	r18, r24
    1d28:	30 e0       	ldi	r19, 0x00	; 0
    1d2a:	3f 83       	std	Y+7, r19	; 0x07
    1d2c:	2e 83       	std	Y+6, r18	; 0x06
    1d2e:	4e 81       	ldd	r20, Y+6	; 0x06
    1d30:	5f 81       	ldd	r21, Y+7	; 0x07
    1d32:	41 30       	cpi	r20, 0x01	; 1
    1d34:	51 05       	cpc	r21, r1
    1d36:	59 f1       	breq	.+86     	; 0x1d8e <DIO_u8GetPinValue+0x9a>
    1d38:	8e 81       	ldd	r24, Y+6	; 0x06
    1d3a:	9f 81       	ldd	r25, Y+7	; 0x07
    1d3c:	82 30       	cpi	r24, 0x02	; 2
    1d3e:	91 05       	cpc	r25, r1
    1d40:	34 f4       	brge	.+12     	; 0x1d4e <DIO_u8GetPinValue+0x5a>
    1d42:	2e 81       	ldd	r18, Y+6	; 0x06
    1d44:	3f 81       	ldd	r19, Y+7	; 0x07
    1d46:	21 15       	cp	r18, r1
    1d48:	31 05       	cpc	r19, r1
    1d4a:	69 f0       	breq	.+26     	; 0x1d66 <DIO_u8GetPinValue+0x72>
    1d4c:	5c c0       	rjmp	.+184    	; 0x1e06 <DIO_u8GetPinValue+0x112>
    1d4e:	4e 81       	ldd	r20, Y+6	; 0x06
    1d50:	5f 81       	ldd	r21, Y+7	; 0x07
    1d52:	42 30       	cpi	r20, 0x02	; 2
    1d54:	51 05       	cpc	r21, r1
    1d56:	79 f1       	breq	.+94     	; 0x1db6 <DIO_u8GetPinValue+0xc2>
    1d58:	8e 81       	ldd	r24, Y+6	; 0x06
    1d5a:	9f 81       	ldd	r25, Y+7	; 0x07
    1d5c:	83 30       	cpi	r24, 0x03	; 3
    1d5e:	91 05       	cpc	r25, r1
    1d60:	09 f4       	brne	.+2      	; 0x1d64 <DIO_u8GetPinValue+0x70>
    1d62:	3d c0       	rjmp	.+122    	; 0x1dde <DIO_u8GetPinValue+0xea>
    1d64:	50 c0       	rjmp	.+160    	; 0x1e06 <DIO_u8GetPinValue+0x112>
			{
			case DIO_u8PORTA: * Copy_Pu8Value = GET_BIT(PINA,Copy_u8Pin); break;
    1d66:	e9 e3       	ldi	r30, 0x39	; 57
    1d68:	f0 e0       	ldi	r31, 0x00	; 0
    1d6a:	80 81       	ld	r24, Z
    1d6c:	28 2f       	mov	r18, r24
    1d6e:	30 e0       	ldi	r19, 0x00	; 0
    1d70:	8b 81       	ldd	r24, Y+3	; 0x03
    1d72:	88 2f       	mov	r24, r24
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	a9 01       	movw	r20, r18
    1d78:	02 c0       	rjmp	.+4      	; 0x1d7e <DIO_u8GetPinValue+0x8a>
    1d7a:	55 95       	asr	r21
    1d7c:	47 95       	ror	r20
    1d7e:	8a 95       	dec	r24
    1d80:	e2 f7       	brpl	.-8      	; 0x1d7a <DIO_u8GetPinValue+0x86>
    1d82:	ca 01       	movw	r24, r20
    1d84:	81 70       	andi	r24, 0x01	; 1
    1d86:	ec 81       	ldd	r30, Y+4	; 0x04
    1d88:	fd 81       	ldd	r31, Y+5	; 0x05
    1d8a:	80 83       	st	Z, r24
    1d8c:	41 c0       	rjmp	.+130    	; 0x1e10 <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTB: * Copy_Pu8Value = GET_BIT(PINB,Copy_u8Pin); break;
    1d8e:	e6 e3       	ldi	r30, 0x36	; 54
    1d90:	f0 e0       	ldi	r31, 0x00	; 0
    1d92:	80 81       	ld	r24, Z
    1d94:	28 2f       	mov	r18, r24
    1d96:	30 e0       	ldi	r19, 0x00	; 0
    1d98:	8b 81       	ldd	r24, Y+3	; 0x03
    1d9a:	88 2f       	mov	r24, r24
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	a9 01       	movw	r20, r18
    1da0:	02 c0       	rjmp	.+4      	; 0x1da6 <DIO_u8GetPinValue+0xb2>
    1da2:	55 95       	asr	r21
    1da4:	47 95       	ror	r20
    1da6:	8a 95       	dec	r24
    1da8:	e2 f7       	brpl	.-8      	; 0x1da2 <DIO_u8GetPinValue+0xae>
    1daa:	ca 01       	movw	r24, r20
    1dac:	81 70       	andi	r24, 0x01	; 1
    1dae:	ec 81       	ldd	r30, Y+4	; 0x04
    1db0:	fd 81       	ldd	r31, Y+5	; 0x05
    1db2:	80 83       	st	Z, r24
    1db4:	2d c0       	rjmp	.+90     	; 0x1e10 <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTC: * Copy_Pu8Value = GET_BIT(PINC,Copy_u8Pin); break;
    1db6:	e3 e3       	ldi	r30, 0x33	; 51
    1db8:	f0 e0       	ldi	r31, 0x00	; 0
    1dba:	80 81       	ld	r24, Z
    1dbc:	28 2f       	mov	r18, r24
    1dbe:	30 e0       	ldi	r19, 0x00	; 0
    1dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc2:	88 2f       	mov	r24, r24
    1dc4:	90 e0       	ldi	r25, 0x00	; 0
    1dc6:	a9 01       	movw	r20, r18
    1dc8:	02 c0       	rjmp	.+4      	; 0x1dce <DIO_u8GetPinValue+0xda>
    1dca:	55 95       	asr	r21
    1dcc:	47 95       	ror	r20
    1dce:	8a 95       	dec	r24
    1dd0:	e2 f7       	brpl	.-8      	; 0x1dca <DIO_u8GetPinValue+0xd6>
    1dd2:	ca 01       	movw	r24, r20
    1dd4:	81 70       	andi	r24, 0x01	; 1
    1dd6:	ec 81       	ldd	r30, Y+4	; 0x04
    1dd8:	fd 81       	ldd	r31, Y+5	; 0x05
    1dda:	80 83       	st	Z, r24
    1ddc:	19 c0       	rjmp	.+50     	; 0x1e10 <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTD: * Copy_Pu8Value = GET_BIT(PIND,Copy_u8Pin); break;
    1dde:	e0 e3       	ldi	r30, 0x30	; 48
    1de0:	f0 e0       	ldi	r31, 0x00	; 0
    1de2:	80 81       	ld	r24, Z
    1de4:	28 2f       	mov	r18, r24
    1de6:	30 e0       	ldi	r19, 0x00	; 0
    1de8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dea:	88 2f       	mov	r24, r24
    1dec:	90 e0       	ldi	r25, 0x00	; 0
    1dee:	a9 01       	movw	r20, r18
    1df0:	02 c0       	rjmp	.+4      	; 0x1df6 <DIO_u8GetPinValue+0x102>
    1df2:	55 95       	asr	r21
    1df4:	47 95       	ror	r20
    1df6:	8a 95       	dec	r24
    1df8:	e2 f7       	brpl	.-8      	; 0x1df2 <DIO_u8GetPinValue+0xfe>
    1dfa:	ca 01       	movw	r24, r20
    1dfc:	81 70       	andi	r24, 0x01	; 1
    1dfe:	ec 81       	ldd	r30, Y+4	; 0x04
    1e00:	fd 81       	ldd	r31, Y+5	; 0x05
    1e02:	80 83       	st	Z, r24
    1e04:	05 c0       	rjmp	.+10     	; 0x1e10 <DIO_u8GetPinValue+0x11c>
			default: Local_u8ErrorState =1; break;
    1e06:	81 e0       	ldi	r24, 0x01	; 1
    1e08:	89 83       	std	Y+1, r24	; 0x01
    1e0a:	02 c0       	rjmp	.+4      	; 0x1e10 <DIO_u8GetPinValue+0x11c>

			}
	}
	else
	{
		Local_u8ErrorState = 1;
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
    1e10:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e12:	27 96       	adiw	r28, 0x07	; 7
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	f8 94       	cli
    1e18:	de bf       	out	0x3e, r29	; 62
    1e1a:	0f be       	out	0x3f, r0	; 63
    1e1c:	cd bf       	out	0x3d, r28	; 61
    1e1e:	cf 91       	pop	r28
    1e20:	df 91       	pop	r29
    1e22:	08 95       	ret

00001e24 <DIO_u8AndWithPort>:

u8 DIO_u8AndWithPort(u8 Copy_u8port, u8 Copy_u8Value)
{
    1e24:	df 93       	push	r29
    1e26:	cf 93       	push	r28
    1e28:	00 d0       	rcall	.+0      	; 0x1e2a <DIO_u8AndWithPort+0x6>
    1e2a:	00 d0       	rcall	.+0      	; 0x1e2c <DIO_u8AndWithPort+0x8>
    1e2c:	0f 92       	push	r0
    1e2e:	cd b7       	in	r28, 0x3d	; 61
    1e30:	de b7       	in	r29, 0x3e	; 62
    1e32:	8a 83       	std	Y+2, r24	; 0x02
    1e34:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8Result = 0;
    1e36:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_u8port)
    1e38:	8a 81       	ldd	r24, Y+2	; 0x02
    1e3a:	28 2f       	mov	r18, r24
    1e3c:	30 e0       	ldi	r19, 0x00	; 0
    1e3e:	3d 83       	std	Y+5, r19	; 0x05
    1e40:	2c 83       	std	Y+4, r18	; 0x04
    1e42:	8c 81       	ldd	r24, Y+4	; 0x04
    1e44:	9d 81       	ldd	r25, Y+5	; 0x05
    1e46:	81 30       	cpi	r24, 0x01	; 1
    1e48:	91 05       	cpc	r25, r1
    1e4a:	e1 f0       	breq	.+56     	; 0x1e84 <DIO_u8AndWithPort+0x60>
    1e4c:	2c 81       	ldd	r18, Y+4	; 0x04
    1e4e:	3d 81       	ldd	r19, Y+5	; 0x05
    1e50:	22 30       	cpi	r18, 0x02	; 2
    1e52:	31 05       	cpc	r19, r1
    1e54:	2c f4       	brge	.+10     	; 0x1e60 <DIO_u8AndWithPort+0x3c>
    1e56:	8c 81       	ldd	r24, Y+4	; 0x04
    1e58:	9d 81       	ldd	r25, Y+5	; 0x05
    1e5a:	00 97       	sbiw	r24, 0x00	; 0
    1e5c:	61 f0       	breq	.+24     	; 0x1e76 <DIO_u8AndWithPort+0x52>
    1e5e:	26 c0       	rjmp	.+76     	; 0x1eac <DIO_u8AndWithPort+0x88>
    1e60:	2c 81       	ldd	r18, Y+4	; 0x04
    1e62:	3d 81       	ldd	r19, Y+5	; 0x05
    1e64:	22 30       	cpi	r18, 0x02	; 2
    1e66:	31 05       	cpc	r19, r1
    1e68:	a1 f0       	breq	.+40     	; 0x1e92 <DIO_u8AndWithPort+0x6e>
    1e6a:	8c 81       	ldd	r24, Y+4	; 0x04
    1e6c:	9d 81       	ldd	r25, Y+5	; 0x05
    1e6e:	83 30       	cpi	r24, 0x03	; 3
    1e70:	91 05       	cpc	r25, r1
    1e72:	b1 f0       	breq	.+44     	; 0x1ea0 <DIO_u8AndWithPort+0x7c>
    1e74:	1b c0       	rjmp	.+54     	; 0x1eac <DIO_u8AndWithPort+0x88>
			{
			case DIO_u8PORTA: Local_u8Result= PORTA & Copy_u8Value; break;
    1e76:	eb e3       	ldi	r30, 0x3B	; 59
    1e78:	f0 e0       	ldi	r31, 0x00	; 0
    1e7a:	90 81       	ld	r25, Z
    1e7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7e:	89 23       	and	r24, r25
    1e80:	89 83       	std	Y+1, r24	; 0x01
    1e82:	14 c0       	rjmp	.+40     	; 0x1eac <DIO_u8AndWithPort+0x88>
			case DIO_u8PORTB: Local_u8Result= PORTB & Copy_u8Value; break;
    1e84:	e8 e3       	ldi	r30, 0x38	; 56
    1e86:	f0 e0       	ldi	r31, 0x00	; 0
    1e88:	90 81       	ld	r25, Z
    1e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8c:	89 23       	and	r24, r25
    1e8e:	89 83       	std	Y+1, r24	; 0x01
    1e90:	0d c0       	rjmp	.+26     	; 0x1eac <DIO_u8AndWithPort+0x88>
			case DIO_u8PORTC: Local_u8Result= PORTC & Copy_u8Value; break;
    1e92:	e5 e3       	ldi	r30, 0x35	; 53
    1e94:	f0 e0       	ldi	r31, 0x00	; 0
    1e96:	90 81       	ld	r25, Z
    1e98:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9a:	89 23       	and	r24, r25
    1e9c:	89 83       	std	Y+1, r24	; 0x01
    1e9e:	06 c0       	rjmp	.+12     	; 0x1eac <DIO_u8AndWithPort+0x88>
			case DIO_u8PORTD: Local_u8Result = PORTD & Copy_u8Value; break;
    1ea0:	e2 e3       	ldi	r30, 0x32	; 50
    1ea2:	f0 e0       	ldi	r31, 0x00	; 0
    1ea4:	90 81       	ld	r25, Z
    1ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea8:	89 23       	and	r24, r25
    1eaa:	89 83       	std	Y+1, r24	; 0x01
			default:  break;


			}
	return Local_u8Result;
    1eac:	89 81       	ldd	r24, Y+1	; 0x01
}
    1eae:	0f 90       	pop	r0
    1eb0:	0f 90       	pop	r0
    1eb2:	0f 90       	pop	r0
    1eb4:	0f 90       	pop	r0
    1eb6:	0f 90       	pop	r0
    1eb8:	cf 91       	pop	r28
    1eba:	df 91       	pop	r29
    1ebc:	08 95       	ret

00001ebe <PORT_VoidInit>:
#include "PORT_interface.h"
#include "PORT_register.h"


void PORT_VoidInit(void)
{
    1ebe:	df 93       	push	r29
    1ec0:	cf 93       	push	r28
    1ec2:	cd b7       	in	r28, 0x3d	; 61
    1ec4:	de b7       	in	r29, 0x3e	; 62
	DDRA = PORTA_DIR;
    1ec6:	ea e3       	ldi	r30, 0x3A	; 58
    1ec8:	f0 e0       	ldi	r31, 0x00	; 0
    1eca:	10 82       	st	Z, r1
	DDRB = PORTB_DIR;
    1ecc:	e7 e3       	ldi	r30, 0x37	; 55
    1ece:	f0 e0       	ldi	r31, 0x00	; 0
    1ed0:	88 e0       	ldi	r24, 0x08	; 8
    1ed2:	80 83       	st	Z, r24
	DDRC = PORTC_DIR;
    1ed4:	e4 e3       	ldi	r30, 0x34	; 52
    1ed6:	f0 e0       	ldi	r31, 0x00	; 0
    1ed8:	8f ef       	ldi	r24, 0xFF	; 255
    1eda:	80 83       	st	Z, r24
	DDRD = PORTD_DIR;
    1edc:	e1 e3       	ldi	r30, 0x31	; 49
    1ede:	f0 e0       	ldi	r31, 0x00	; 0
    1ee0:	10 82       	st	Z, r1
	
	PORTA = PORTA_INITIAL_VALUE;
    1ee2:	eb e3       	ldi	r30, 0x3B	; 59
    1ee4:	f0 e0       	ldi	r31, 0x00	; 0
    1ee6:	10 82       	st	Z, r1
	PORTB = PORTB_INITIAL_VALUE;
    1ee8:	e8 e3       	ldi	r30, 0x38	; 56
    1eea:	f0 e0       	ldi	r31, 0x00	; 0
    1eec:	10 82       	st	Z, r1
	PORTC = PORTC_INITIAL_VALUE;
    1eee:	e5 e3       	ldi	r30, 0x35	; 53
    1ef0:	f0 e0       	ldi	r31, 0x00	; 0
    1ef2:	10 82       	st	Z, r1
	PORTD = PORTD_INITIAL_VALUE;
    1ef4:	e2 e3       	ldi	r30, 0x32	; 50
    1ef6:	f0 e0       	ldi	r31, 0x00	; 0
    1ef8:	10 82       	st	Z, r1


}
    1efa:	cf 91       	pop	r28
    1efc:	df 91       	pop	r29
    1efe:	08 95       	ret

00001f00 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1f00:	df 93       	push	r29
    1f02:	cf 93       	push	r28
    1f04:	cd b7       	in	r28, 0x3d	; 61
    1f06:	de b7       	in	r29, 0x3e	; 62
    1f08:	27 97       	sbiw	r28, 0x07	; 7
    1f0a:	0f b6       	in	r0, 0x3f	; 63
    1f0c:	f8 94       	cli
    1f0e:	de bf       	out	0x3e, r29	; 62
    1f10:	0f be       	out	0x3f, r0	; 63
    1f12:	cd bf       	out	0x3d, r28	; 61
    1f14:	9d 83       	std	Y+5, r25	; 0x05
    1f16:	8c 83       	std	Y+4, r24	; 0x04
    1f18:	6e 83       	std	Y+6, r22	; 0x06
    1f1a:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1f1c:	8a e1       	ldi	r24, 0x1A	; 26
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	0e 94 58 12 	call	0x24b0	; 0x24b0 <pvPortMalloc>
    1f24:	9a 83       	std	Y+2, r25	; 0x02
    1f26:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1f28:	89 81       	ldd	r24, Y+1	; 0x01
    1f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f2c:	00 97       	sbiw	r24, 0x00	; 0
    1f2e:	09 f4       	brne	.+2      	; 0x1f32 <xCoRoutineCreate+0x32>
    1f30:	6f c0       	rjmp	.+222    	; 0x2010 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1f32:	80 91 82 00 	lds	r24, 0x0082
    1f36:	90 91 83 00 	lds	r25, 0x0083
    1f3a:	00 97       	sbiw	r24, 0x00	; 0
    1f3c:	41 f4       	brne	.+16     	; 0x1f4e <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1f3e:	89 81       	ldd	r24, Y+1	; 0x01
    1f40:	9a 81       	ldd	r25, Y+2	; 0x02
    1f42:	90 93 83 00 	sts	0x0083, r25
    1f46:	80 93 82 00 	sts	0x0082, r24
			prvInitialiseCoRoutineLists();
    1f4a:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1f4e:	8e 81       	ldd	r24, Y+6	; 0x06
    1f50:	82 30       	cpi	r24, 0x02	; 2
    1f52:	10 f0       	brcs	.+4      	; 0x1f58 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1f54:	81 e0       	ldi	r24, 0x01	; 1
    1f56:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1f58:	e9 81       	ldd	r30, Y+1	; 0x01
    1f5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f5c:	11 8e       	std	Z+25, r1	; 0x19
    1f5e:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1f60:	e9 81       	ldd	r30, Y+1	; 0x01
    1f62:	fa 81       	ldd	r31, Y+2	; 0x02
    1f64:	8e 81       	ldd	r24, Y+6	; 0x06
    1f66:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1f68:	e9 81       	ldd	r30, Y+1	; 0x01
    1f6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f6c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f6e:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1f70:	e9 81       	ldd	r30, Y+1	; 0x01
    1f72:	fa 81       	ldd	r31, Y+2	; 0x02
    1f74:	8c 81       	ldd	r24, Y+4	; 0x04
    1f76:	9d 81       	ldd	r25, Y+5	; 0x05
    1f78:	91 83       	std	Z+1, r25	; 0x01
    1f7a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1f7c:	89 81       	ldd	r24, Y+1	; 0x01
    1f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f80:	02 96       	adiw	r24, 0x02	; 2
    1f82:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1f86:	89 81       	ldd	r24, Y+1	; 0x01
    1f88:	9a 81       	ldd	r25, Y+2	; 0x02
    1f8a:	0c 96       	adiw	r24, 0x0c	; 12
    1f8c:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1f90:	e9 81       	ldd	r30, Y+1	; 0x01
    1f92:	fa 81       	ldd	r31, Y+2	; 0x02
    1f94:	89 81       	ldd	r24, Y+1	; 0x01
    1f96:	9a 81       	ldd	r25, Y+2	; 0x02
    1f98:	91 87       	std	Z+9, r25	; 0x09
    1f9a:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa0:	89 81       	ldd	r24, Y+1	; 0x01
    1fa2:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa4:	93 8b       	std	Z+19, r25	; 0x13
    1fa6:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1fa8:	8e 81       	ldd	r24, Y+6	; 0x06
    1faa:	28 2f       	mov	r18, r24
    1fac:	30 e0       	ldi	r19, 0x00	; 0
    1fae:	87 e0       	ldi	r24, 0x07	; 7
    1fb0:	90 e0       	ldi	r25, 0x00	; 0
    1fb2:	82 1b       	sub	r24, r18
    1fb4:	93 0b       	sbc	r25, r19
    1fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fba:	95 87       	std	Z+13, r25	; 0x0d
    1fbc:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1fbe:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc0:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc2:	96 89       	ldd	r25, Z+22	; 0x16
    1fc4:	80 91 84 00 	lds	r24, 0x0084
    1fc8:	89 17       	cp	r24, r25
    1fca:	28 f4       	brcc	.+10     	; 0x1fd6 <xCoRoutineCreate+0xd6>
    1fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    1fce:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd0:	86 89       	ldd	r24, Z+22	; 0x16
    1fd2:	80 93 84 00 	sts	0x0084, r24
    1fd6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fd8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fda:	86 89       	ldd	r24, Z+22	; 0x16
    1fdc:	28 2f       	mov	r18, r24
    1fde:	30 e0       	ldi	r19, 0x00	; 0
    1fe0:	c9 01       	movw	r24, r18
    1fe2:	88 0f       	add	r24, r24
    1fe4:	99 1f       	adc	r25, r25
    1fe6:	88 0f       	add	r24, r24
    1fe8:	99 1f       	adc	r25, r25
    1fea:	88 0f       	add	r24, r24
    1fec:	99 1f       	adc	r25, r25
    1fee:	82 0f       	add	r24, r18
    1ff0:	93 1f       	adc	r25, r19
    1ff2:	ac 01       	movw	r20, r24
    1ff4:	45 57       	subi	r20, 0x75	; 117
    1ff6:	5f 4f       	sbci	r21, 0xFF	; 255
    1ff8:	89 81       	ldd	r24, Y+1	; 0x01
    1ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffc:	9c 01       	movw	r18, r24
    1ffe:	2e 5f       	subi	r18, 0xFE	; 254
    2000:	3f 4f       	sbci	r19, 0xFF	; 255
    2002:	ca 01       	movw	r24, r20
    2004:	b9 01       	movw	r22, r18
    2006:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>

		xReturn = pdPASS;
    200a:	81 e0       	ldi	r24, 0x01	; 1
    200c:	8b 83       	std	Y+3, r24	; 0x03
    200e:	02 c0       	rjmp	.+4      	; 0x2014 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2010:	8f ef       	ldi	r24, 0xFF	; 255
    2012:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    2014:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2016:	27 96       	adiw	r28, 0x07	; 7
    2018:	0f b6       	in	r0, 0x3f	; 63
    201a:	f8 94       	cli
    201c:	de bf       	out	0x3e, r29	; 62
    201e:	0f be       	out	0x3f, r0	; 63
    2020:	cd bf       	out	0x3d, r28	; 61
    2022:	cf 91       	pop	r28
    2024:	df 91       	pop	r29
    2026:	08 95       	ret

00002028 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    2028:	df 93       	push	r29
    202a:	cf 93       	push	r28
    202c:	00 d0       	rcall	.+0      	; 0x202e <vCoRoutineAddToDelayedList+0x6>
    202e:	00 d0       	rcall	.+0      	; 0x2030 <vCoRoutineAddToDelayedList+0x8>
    2030:	00 d0       	rcall	.+0      	; 0x2032 <vCoRoutineAddToDelayedList+0xa>
    2032:	cd b7       	in	r28, 0x3d	; 61
    2034:	de b7       	in	r29, 0x3e	; 62
    2036:	9c 83       	std	Y+4, r25	; 0x04
    2038:	8b 83       	std	Y+3, r24	; 0x03
    203a:	7e 83       	std	Y+6, r23	; 0x06
    203c:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    203e:	20 91 85 00 	lds	r18, 0x0085
    2042:	30 91 86 00 	lds	r19, 0x0086
    2046:	8b 81       	ldd	r24, Y+3	; 0x03
    2048:	9c 81       	ldd	r25, Y+4	; 0x04
    204a:	82 0f       	add	r24, r18
    204c:	93 1f       	adc	r25, r19
    204e:	9a 83       	std	Y+2, r25	; 0x02
    2050:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2052:	80 91 82 00 	lds	r24, 0x0082
    2056:	90 91 83 00 	lds	r25, 0x0083
    205a:	02 96       	adiw	r24, 0x02	; 2
    205c:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2060:	e0 91 82 00 	lds	r30, 0x0082
    2064:	f0 91 83 00 	lds	r31, 0x0083
    2068:	89 81       	ldd	r24, Y+1	; 0x01
    206a:	9a 81       	ldd	r25, Y+2	; 0x02
    206c:	93 83       	std	Z+3, r25	; 0x03
    206e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2070:	20 91 85 00 	lds	r18, 0x0085
    2074:	30 91 86 00 	lds	r19, 0x0086
    2078:	89 81       	ldd	r24, Y+1	; 0x01
    207a:	9a 81       	ldd	r25, Y+2	; 0x02
    207c:	82 17       	cp	r24, r18
    207e:	93 07       	cpc	r25, r19
    2080:	70 f4       	brcc	.+28     	; 0x209e <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2082:	80 91 b1 00 	lds	r24, 0x00B1
    2086:	90 91 b2 00 	lds	r25, 0x00B2
    208a:	20 91 82 00 	lds	r18, 0x0082
    208e:	30 91 83 00 	lds	r19, 0x0083
    2092:	2e 5f       	subi	r18, 0xFE	; 254
    2094:	3f 4f       	sbci	r19, 0xFF	; 255
    2096:	b9 01       	movw	r22, r18
    2098:	0e 94 4a 13 	call	0x2694	; 0x2694 <vListInsert>
    209c:	0d c0       	rjmp	.+26     	; 0x20b8 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    209e:	80 91 af 00 	lds	r24, 0x00AF
    20a2:	90 91 b0 00 	lds	r25, 0x00B0
    20a6:	20 91 82 00 	lds	r18, 0x0082
    20aa:	30 91 83 00 	lds	r19, 0x0083
    20ae:	2e 5f       	subi	r18, 0xFE	; 254
    20b0:	3f 4f       	sbci	r19, 0xFF	; 255
    20b2:	b9 01       	movw	r22, r18
    20b4:	0e 94 4a 13 	call	0x2694	; 0x2694 <vListInsert>
	}

	if( pxEventList )
    20b8:	8d 81       	ldd	r24, Y+5	; 0x05
    20ba:	9e 81       	ldd	r25, Y+6	; 0x06
    20bc:	00 97       	sbiw	r24, 0x00	; 0
    20be:	61 f0       	breq	.+24     	; 0x20d8 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    20c0:	80 91 82 00 	lds	r24, 0x0082
    20c4:	90 91 83 00 	lds	r25, 0x0083
    20c8:	9c 01       	movw	r18, r24
    20ca:	24 5f       	subi	r18, 0xF4	; 244
    20cc:	3f 4f       	sbci	r19, 0xFF	; 255
    20ce:	8d 81       	ldd	r24, Y+5	; 0x05
    20d0:	9e 81       	ldd	r25, Y+6	; 0x06
    20d2:	b9 01       	movw	r22, r18
    20d4:	0e 94 4a 13 	call	0x2694	; 0x2694 <vListInsert>
	}
}
    20d8:	26 96       	adiw	r28, 0x06	; 6
    20da:	0f b6       	in	r0, 0x3f	; 63
    20dc:	f8 94       	cli
    20de:	de bf       	out	0x3e, r29	; 62
    20e0:	0f be       	out	0x3f, r0	; 63
    20e2:	cd bf       	out	0x3d, r28	; 61
    20e4:	cf 91       	pop	r28
    20e6:	df 91       	pop	r29
    20e8:	08 95       	ret

000020ea <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    20ea:	df 93       	push	r29
    20ec:	cf 93       	push	r28
    20ee:	00 d0       	rcall	.+0      	; 0x20f0 <prvCheckPendingReadyList+0x6>
    20f0:	cd b7       	in	r28, 0x3d	; 61
    20f2:	de b7       	in	r29, 0x3e	; 62
    20f4:	3a c0       	rjmp	.+116    	; 0x216a <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    20f6:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    20f8:	e0 91 b8 00 	lds	r30, 0x00B8
    20fc:	f0 91 b9 00 	lds	r31, 0x00B9
    2100:	86 81       	ldd	r24, Z+6	; 0x06
    2102:	97 81       	ldd	r25, Z+7	; 0x07
    2104:	9a 83       	std	Y+2, r25	; 0x02
    2106:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2108:	89 81       	ldd	r24, Y+1	; 0x01
    210a:	9a 81       	ldd	r25, Y+2	; 0x02
    210c:	0c 96       	adiw	r24, 0x0c	; 12
    210e:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2112:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2114:	89 81       	ldd	r24, Y+1	; 0x01
    2116:	9a 81       	ldd	r25, Y+2	; 0x02
    2118:	02 96       	adiw	r24, 0x02	; 2
    211a:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    211e:	e9 81       	ldd	r30, Y+1	; 0x01
    2120:	fa 81       	ldd	r31, Y+2	; 0x02
    2122:	96 89       	ldd	r25, Z+22	; 0x16
    2124:	80 91 84 00 	lds	r24, 0x0084
    2128:	89 17       	cp	r24, r25
    212a:	28 f4       	brcc	.+10     	; 0x2136 <prvCheckPendingReadyList+0x4c>
    212c:	e9 81       	ldd	r30, Y+1	; 0x01
    212e:	fa 81       	ldd	r31, Y+2	; 0x02
    2130:	86 89       	ldd	r24, Z+22	; 0x16
    2132:	80 93 84 00 	sts	0x0084, r24
    2136:	e9 81       	ldd	r30, Y+1	; 0x01
    2138:	fa 81       	ldd	r31, Y+2	; 0x02
    213a:	86 89       	ldd	r24, Z+22	; 0x16
    213c:	28 2f       	mov	r18, r24
    213e:	30 e0       	ldi	r19, 0x00	; 0
    2140:	c9 01       	movw	r24, r18
    2142:	88 0f       	add	r24, r24
    2144:	99 1f       	adc	r25, r25
    2146:	88 0f       	add	r24, r24
    2148:	99 1f       	adc	r25, r25
    214a:	88 0f       	add	r24, r24
    214c:	99 1f       	adc	r25, r25
    214e:	82 0f       	add	r24, r18
    2150:	93 1f       	adc	r25, r19
    2152:	ac 01       	movw	r20, r24
    2154:	45 57       	subi	r20, 0x75	; 117
    2156:	5f 4f       	sbci	r21, 0xFF	; 255
    2158:	89 81       	ldd	r24, Y+1	; 0x01
    215a:	9a 81       	ldd	r25, Y+2	; 0x02
    215c:	9c 01       	movw	r18, r24
    215e:	2e 5f       	subi	r18, 0xFE	; 254
    2160:	3f 4f       	sbci	r19, 0xFF	; 255
    2162:	ca 01       	movw	r24, r20
    2164:	b9 01       	movw	r22, r18
    2166:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    216a:	80 91 b3 00 	lds	r24, 0x00B3
    216e:	88 23       	and	r24, r24
    2170:	09 f0       	breq	.+2      	; 0x2174 <prvCheckPendingReadyList+0x8a>
    2172:	c1 cf       	rjmp	.-126    	; 0x20f6 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2174:	0f 90       	pop	r0
    2176:	0f 90       	pop	r0
    2178:	cf 91       	pop	r28
    217a:	df 91       	pop	r29
    217c:	08 95       	ret

0000217e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    217e:	df 93       	push	r29
    2180:	cf 93       	push	r28
    2182:	00 d0       	rcall	.+0      	; 0x2184 <prvCheckDelayedList+0x6>
    2184:	00 d0       	rcall	.+0      	; 0x2186 <prvCheckDelayedList+0x8>
    2186:	cd b7       	in	r28, 0x3d	; 61
    2188:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    218a:	0e 94 9f 1e 	call	0x3d3e	; 0x3d3e <xTaskGetTickCount>
    218e:	20 91 87 00 	lds	r18, 0x0087
    2192:	30 91 88 00 	lds	r19, 0x0088
    2196:	82 1b       	sub	r24, r18
    2198:	93 0b       	sbc	r25, r19
    219a:	90 93 8a 00 	sts	0x008A, r25
    219e:	80 93 89 00 	sts	0x0089, r24
    21a2:	85 c0       	rjmp	.+266    	; 0x22ae <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    21a4:	80 91 85 00 	lds	r24, 0x0085
    21a8:	90 91 86 00 	lds	r25, 0x0086
    21ac:	01 96       	adiw	r24, 0x01	; 1
    21ae:	90 93 86 00 	sts	0x0086, r25
    21b2:	80 93 85 00 	sts	0x0085, r24
		xPassedTicks--;
    21b6:	80 91 89 00 	lds	r24, 0x0089
    21ba:	90 91 8a 00 	lds	r25, 0x008A
    21be:	01 97       	sbiw	r24, 0x01	; 1
    21c0:	90 93 8a 00 	sts	0x008A, r25
    21c4:	80 93 89 00 	sts	0x0089, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    21c8:	80 91 85 00 	lds	r24, 0x0085
    21cc:	90 91 86 00 	lds	r25, 0x0086
    21d0:	00 97       	sbiw	r24, 0x00	; 0
    21d2:	09 f0       	breq	.+2      	; 0x21d6 <prvCheckDelayedList+0x58>
    21d4:	64 c0       	rjmp	.+200    	; 0x229e <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    21d6:	80 91 af 00 	lds	r24, 0x00AF
    21da:	90 91 b0 00 	lds	r25, 0x00B0
    21de:	9a 83       	std	Y+2, r25	; 0x02
    21e0:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    21e2:	80 91 b1 00 	lds	r24, 0x00B1
    21e6:	90 91 b2 00 	lds	r25, 0x00B2
    21ea:	90 93 b0 00 	sts	0x00B0, r25
    21ee:	80 93 af 00 	sts	0x00AF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    21f2:	89 81       	ldd	r24, Y+1	; 0x01
    21f4:	9a 81       	ldd	r25, Y+2	; 0x02
    21f6:	90 93 b2 00 	sts	0x00B2, r25
    21fa:	80 93 b1 00 	sts	0x00B1, r24
    21fe:	4f c0       	rjmp	.+158    	; 0x229e <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2200:	e0 91 af 00 	lds	r30, 0x00AF
    2204:	f0 91 b0 00 	lds	r31, 0x00B0
    2208:	05 80       	ldd	r0, Z+5	; 0x05
    220a:	f6 81       	ldd	r31, Z+6	; 0x06
    220c:	e0 2d       	mov	r30, r0
    220e:	86 81       	ldd	r24, Z+6	; 0x06
    2210:	97 81       	ldd	r25, Z+7	; 0x07
    2212:	9c 83       	std	Y+4, r25	; 0x04
    2214:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2216:	eb 81       	ldd	r30, Y+3	; 0x03
    2218:	fc 81       	ldd	r31, Y+4	; 0x04
    221a:	22 81       	ldd	r18, Z+2	; 0x02
    221c:	33 81       	ldd	r19, Z+3	; 0x03
    221e:	80 91 85 00 	lds	r24, 0x0085
    2222:	90 91 86 00 	lds	r25, 0x0086
    2226:	82 17       	cp	r24, r18
    2228:	93 07       	cpc	r25, r19
    222a:	08 f4       	brcc	.+2      	; 0x222e <prvCheckDelayedList+0xb0>
    222c:	40 c0       	rjmp	.+128    	; 0x22ae <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    222e:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2230:	8b 81       	ldd	r24, Y+3	; 0x03
    2232:	9c 81       	ldd	r25, Y+4	; 0x04
    2234:	02 96       	adiw	r24, 0x02	; 2
    2236:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    223a:	eb 81       	ldd	r30, Y+3	; 0x03
    223c:	fc 81       	ldd	r31, Y+4	; 0x04
    223e:	84 89       	ldd	r24, Z+20	; 0x14
    2240:	95 89       	ldd	r25, Z+21	; 0x15
    2242:	00 97       	sbiw	r24, 0x00	; 0
    2244:	29 f0       	breq	.+10     	; 0x2250 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2246:	8b 81       	ldd	r24, Y+3	; 0x03
    2248:	9c 81       	ldd	r25, Y+4	; 0x04
    224a:	0c 96       	adiw	r24, 0x0c	; 12
    224c:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2250:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2252:	eb 81       	ldd	r30, Y+3	; 0x03
    2254:	fc 81       	ldd	r31, Y+4	; 0x04
    2256:	96 89       	ldd	r25, Z+22	; 0x16
    2258:	80 91 84 00 	lds	r24, 0x0084
    225c:	89 17       	cp	r24, r25
    225e:	28 f4       	brcc	.+10     	; 0x226a <prvCheckDelayedList+0xec>
    2260:	eb 81       	ldd	r30, Y+3	; 0x03
    2262:	fc 81       	ldd	r31, Y+4	; 0x04
    2264:	86 89       	ldd	r24, Z+22	; 0x16
    2266:	80 93 84 00 	sts	0x0084, r24
    226a:	eb 81       	ldd	r30, Y+3	; 0x03
    226c:	fc 81       	ldd	r31, Y+4	; 0x04
    226e:	86 89       	ldd	r24, Z+22	; 0x16
    2270:	28 2f       	mov	r18, r24
    2272:	30 e0       	ldi	r19, 0x00	; 0
    2274:	c9 01       	movw	r24, r18
    2276:	88 0f       	add	r24, r24
    2278:	99 1f       	adc	r25, r25
    227a:	88 0f       	add	r24, r24
    227c:	99 1f       	adc	r25, r25
    227e:	88 0f       	add	r24, r24
    2280:	99 1f       	adc	r25, r25
    2282:	82 0f       	add	r24, r18
    2284:	93 1f       	adc	r25, r19
    2286:	ac 01       	movw	r20, r24
    2288:	45 57       	subi	r20, 0x75	; 117
    228a:	5f 4f       	sbci	r21, 0xFF	; 255
    228c:	8b 81       	ldd	r24, Y+3	; 0x03
    228e:	9c 81       	ldd	r25, Y+4	; 0x04
    2290:	9c 01       	movw	r18, r24
    2292:	2e 5f       	subi	r18, 0xFE	; 254
    2294:	3f 4f       	sbci	r19, 0xFF	; 255
    2296:	ca 01       	movw	r24, r20
    2298:	b9 01       	movw	r22, r18
    229a:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    229e:	e0 91 af 00 	lds	r30, 0x00AF
    22a2:	f0 91 b0 00 	lds	r31, 0x00B0
    22a6:	80 81       	ld	r24, Z
    22a8:	88 23       	and	r24, r24
    22aa:	09 f0       	breq	.+2      	; 0x22ae <prvCheckDelayedList+0x130>
    22ac:	a9 cf       	rjmp	.-174    	; 0x2200 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    22ae:	80 91 89 00 	lds	r24, 0x0089
    22b2:	90 91 8a 00 	lds	r25, 0x008A
    22b6:	00 97       	sbiw	r24, 0x00	; 0
    22b8:	09 f0       	breq	.+2      	; 0x22bc <prvCheckDelayedList+0x13e>
    22ba:	74 cf       	rjmp	.-280    	; 0x21a4 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    22bc:	80 91 85 00 	lds	r24, 0x0085
    22c0:	90 91 86 00 	lds	r25, 0x0086
    22c4:	90 93 88 00 	sts	0x0088, r25
    22c8:	80 93 87 00 	sts	0x0087, r24
}
    22cc:	0f 90       	pop	r0
    22ce:	0f 90       	pop	r0
    22d0:	0f 90       	pop	r0
    22d2:	0f 90       	pop	r0
    22d4:	cf 91       	pop	r28
    22d6:	df 91       	pop	r29
    22d8:	08 95       	ret

000022da <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    22da:	df 93       	push	r29
    22dc:	cf 93       	push	r28
    22de:	00 d0       	rcall	.+0      	; 0x22e0 <vCoRoutineSchedule+0x6>
    22e0:	cd b7       	in	r28, 0x3d	; 61
    22e2:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    22e4:	0e 94 75 10 	call	0x20ea	; 0x20ea <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    22e8:	0e 94 bf 10 	call	0x217e	; 0x217e <prvCheckDelayedList>
    22ec:	0a c0       	rjmp	.+20     	; 0x2302 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    22ee:	80 91 84 00 	lds	r24, 0x0084
    22f2:	88 23       	and	r24, r24
    22f4:	09 f4       	brne	.+2      	; 0x22f8 <vCoRoutineSchedule+0x1e>
    22f6:	66 c0       	rjmp	.+204    	; 0x23c4 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    22f8:	80 91 84 00 	lds	r24, 0x0084
    22fc:	81 50       	subi	r24, 0x01	; 1
    22fe:	80 93 84 00 	sts	0x0084, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2302:	80 91 84 00 	lds	r24, 0x0084
    2306:	28 2f       	mov	r18, r24
    2308:	30 e0       	ldi	r19, 0x00	; 0
    230a:	c9 01       	movw	r24, r18
    230c:	88 0f       	add	r24, r24
    230e:	99 1f       	adc	r25, r25
    2310:	88 0f       	add	r24, r24
    2312:	99 1f       	adc	r25, r25
    2314:	88 0f       	add	r24, r24
    2316:	99 1f       	adc	r25, r25
    2318:	82 0f       	add	r24, r18
    231a:	93 1f       	adc	r25, r19
    231c:	fc 01       	movw	r30, r24
    231e:	e5 57       	subi	r30, 0x75	; 117
    2320:	ff 4f       	sbci	r31, 0xFF	; 255
    2322:	80 81       	ld	r24, Z
    2324:	88 23       	and	r24, r24
    2326:	19 f3       	breq	.-58     	; 0x22ee <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2328:	80 91 84 00 	lds	r24, 0x0084
    232c:	28 2f       	mov	r18, r24
    232e:	30 e0       	ldi	r19, 0x00	; 0
    2330:	c9 01       	movw	r24, r18
    2332:	88 0f       	add	r24, r24
    2334:	99 1f       	adc	r25, r25
    2336:	88 0f       	add	r24, r24
    2338:	99 1f       	adc	r25, r25
    233a:	88 0f       	add	r24, r24
    233c:	99 1f       	adc	r25, r25
    233e:	82 0f       	add	r24, r18
    2340:	93 1f       	adc	r25, r19
    2342:	85 57       	subi	r24, 0x75	; 117
    2344:	9f 4f       	sbci	r25, 0xFF	; 255
    2346:	9a 83       	std	Y+2, r25	; 0x02
    2348:	89 83       	std	Y+1, r24	; 0x01
    234a:	e9 81       	ldd	r30, Y+1	; 0x01
    234c:	fa 81       	ldd	r31, Y+2	; 0x02
    234e:	01 80       	ldd	r0, Z+1	; 0x01
    2350:	f2 81       	ldd	r31, Z+2	; 0x02
    2352:	e0 2d       	mov	r30, r0
    2354:	82 81       	ldd	r24, Z+2	; 0x02
    2356:	93 81       	ldd	r25, Z+3	; 0x03
    2358:	e9 81       	ldd	r30, Y+1	; 0x01
    235a:	fa 81       	ldd	r31, Y+2	; 0x02
    235c:	92 83       	std	Z+2, r25	; 0x02
    235e:	81 83       	std	Z+1, r24	; 0x01
    2360:	e9 81       	ldd	r30, Y+1	; 0x01
    2362:	fa 81       	ldd	r31, Y+2	; 0x02
    2364:	21 81       	ldd	r18, Z+1	; 0x01
    2366:	32 81       	ldd	r19, Z+2	; 0x02
    2368:	89 81       	ldd	r24, Y+1	; 0x01
    236a:	9a 81       	ldd	r25, Y+2	; 0x02
    236c:	03 96       	adiw	r24, 0x03	; 3
    236e:	28 17       	cp	r18, r24
    2370:	39 07       	cpc	r19, r25
    2372:	59 f4       	brne	.+22     	; 0x238a <vCoRoutineSchedule+0xb0>
    2374:	e9 81       	ldd	r30, Y+1	; 0x01
    2376:	fa 81       	ldd	r31, Y+2	; 0x02
    2378:	01 80       	ldd	r0, Z+1	; 0x01
    237a:	f2 81       	ldd	r31, Z+2	; 0x02
    237c:	e0 2d       	mov	r30, r0
    237e:	82 81       	ldd	r24, Z+2	; 0x02
    2380:	93 81       	ldd	r25, Z+3	; 0x03
    2382:	e9 81       	ldd	r30, Y+1	; 0x01
    2384:	fa 81       	ldd	r31, Y+2	; 0x02
    2386:	92 83       	std	Z+2, r25	; 0x02
    2388:	81 83       	std	Z+1, r24	; 0x01
    238a:	e9 81       	ldd	r30, Y+1	; 0x01
    238c:	fa 81       	ldd	r31, Y+2	; 0x02
    238e:	01 80       	ldd	r0, Z+1	; 0x01
    2390:	f2 81       	ldd	r31, Z+2	; 0x02
    2392:	e0 2d       	mov	r30, r0
    2394:	86 81       	ldd	r24, Z+6	; 0x06
    2396:	97 81       	ldd	r25, Z+7	; 0x07
    2398:	90 93 83 00 	sts	0x0083, r25
    239c:	80 93 82 00 	sts	0x0082, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    23a0:	e0 91 82 00 	lds	r30, 0x0082
    23a4:	f0 91 83 00 	lds	r31, 0x0083
    23a8:	40 81       	ld	r20, Z
    23aa:	51 81       	ldd	r21, Z+1	; 0x01
    23ac:	80 91 82 00 	lds	r24, 0x0082
    23b0:	90 91 83 00 	lds	r25, 0x0083
    23b4:	e0 91 82 00 	lds	r30, 0x0082
    23b8:	f0 91 83 00 	lds	r31, 0x0083
    23bc:	27 89       	ldd	r18, Z+23	; 0x17
    23be:	62 2f       	mov	r22, r18
    23c0:	fa 01       	movw	r30, r20
    23c2:	09 95       	icall

	return;
}
    23c4:	0f 90       	pop	r0
    23c6:	0f 90       	pop	r0
    23c8:	cf 91       	pop	r28
    23ca:	df 91       	pop	r29
    23cc:	08 95       	ret

000023ce <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    23ce:	df 93       	push	r29
    23d0:	cf 93       	push	r28
    23d2:	0f 92       	push	r0
    23d4:	cd b7       	in	r28, 0x3d	; 61
    23d6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    23d8:	19 82       	std	Y+1, r1	; 0x01
    23da:	13 c0       	rjmp	.+38     	; 0x2402 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    23dc:	89 81       	ldd	r24, Y+1	; 0x01
    23de:	28 2f       	mov	r18, r24
    23e0:	30 e0       	ldi	r19, 0x00	; 0
    23e2:	c9 01       	movw	r24, r18
    23e4:	88 0f       	add	r24, r24
    23e6:	99 1f       	adc	r25, r25
    23e8:	88 0f       	add	r24, r24
    23ea:	99 1f       	adc	r25, r25
    23ec:	88 0f       	add	r24, r24
    23ee:	99 1f       	adc	r25, r25
    23f0:	82 0f       	add	r24, r18
    23f2:	93 1f       	adc	r25, r19
    23f4:	85 57       	subi	r24, 0x75	; 117
    23f6:	9f 4f       	sbci	r25, 0xFF	; 255
    23f8:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    23fc:	89 81       	ldd	r24, Y+1	; 0x01
    23fe:	8f 5f       	subi	r24, 0xFF	; 255
    2400:	89 83       	std	Y+1, r24	; 0x01
    2402:	89 81       	ldd	r24, Y+1	; 0x01
    2404:	82 30       	cpi	r24, 0x02	; 2
    2406:	50 f3       	brcs	.-44     	; 0x23dc <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2408:	8d e9       	ldi	r24, 0x9D	; 157
    240a:	90 e0       	ldi	r25, 0x00	; 0
    240c:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2410:	86 ea       	ldi	r24, 0xA6	; 166
    2412:	90 e0       	ldi	r25, 0x00	; 0
    2414:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2418:	83 eb       	ldi	r24, 0xB3	; 179
    241a:	90 e0       	ldi	r25, 0x00	; 0
    241c:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2420:	8d e9       	ldi	r24, 0x9D	; 157
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	90 93 b0 00 	sts	0x00B0, r25
    2428:	80 93 af 00 	sts	0x00AF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    242c:	86 ea       	ldi	r24, 0xA6	; 166
    242e:	90 e0       	ldi	r25, 0x00	; 0
    2430:	90 93 b2 00 	sts	0x00B2, r25
    2434:	80 93 b1 00 	sts	0x00B1, r24
}
    2438:	0f 90       	pop	r0
    243a:	cf 91       	pop	r28
    243c:	df 91       	pop	r29
    243e:	08 95       	ret

00002440 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2440:	df 93       	push	r29
    2442:	cf 93       	push	r28
    2444:	00 d0       	rcall	.+0      	; 0x2446 <xCoRoutineRemoveFromEventList+0x6>
    2446:	00 d0       	rcall	.+0      	; 0x2448 <xCoRoutineRemoveFromEventList+0x8>
    2448:	0f 92       	push	r0
    244a:	cd b7       	in	r28, 0x3d	; 61
    244c:	de b7       	in	r29, 0x3e	; 62
    244e:	9d 83       	std	Y+5, r25	; 0x05
    2450:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2452:	ec 81       	ldd	r30, Y+4	; 0x04
    2454:	fd 81       	ldd	r31, Y+5	; 0x05
    2456:	05 80       	ldd	r0, Z+5	; 0x05
    2458:	f6 81       	ldd	r31, Z+6	; 0x06
    245a:	e0 2d       	mov	r30, r0
    245c:	86 81       	ldd	r24, Z+6	; 0x06
    245e:	97 81       	ldd	r25, Z+7	; 0x07
    2460:	9b 83       	std	Y+3, r25	; 0x03
    2462:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2464:	8a 81       	ldd	r24, Y+2	; 0x02
    2466:	9b 81       	ldd	r25, Y+3	; 0x03
    2468:	0c 96       	adiw	r24, 0x0c	; 12
    246a:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    246e:	8a 81       	ldd	r24, Y+2	; 0x02
    2470:	9b 81       	ldd	r25, Y+3	; 0x03
    2472:	9c 01       	movw	r18, r24
    2474:	24 5f       	subi	r18, 0xF4	; 244
    2476:	3f 4f       	sbci	r19, 0xFF	; 255
    2478:	83 eb       	ldi	r24, 0xB3	; 179
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	b9 01       	movw	r22, r18
    247e:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2482:	ea 81       	ldd	r30, Y+2	; 0x02
    2484:	fb 81       	ldd	r31, Y+3	; 0x03
    2486:	96 89       	ldd	r25, Z+22	; 0x16
    2488:	e0 91 82 00 	lds	r30, 0x0082
    248c:	f0 91 83 00 	lds	r31, 0x0083
    2490:	86 89       	ldd	r24, Z+22	; 0x16
    2492:	98 17       	cp	r25, r24
    2494:	18 f0       	brcs	.+6      	; 0x249c <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2496:	81 e0       	ldi	r24, 0x01	; 1
    2498:	89 83       	std	Y+1, r24	; 0x01
    249a:	01 c0       	rjmp	.+2      	; 0x249e <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    249c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    249e:	89 81       	ldd	r24, Y+1	; 0x01
}
    24a0:	0f 90       	pop	r0
    24a2:	0f 90       	pop	r0
    24a4:	0f 90       	pop	r0
    24a6:	0f 90       	pop	r0
    24a8:	0f 90       	pop	r0
    24aa:	cf 91       	pop	r28
    24ac:	df 91       	pop	r29
    24ae:	08 95       	ret

000024b0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    24b0:	df 93       	push	r29
    24b2:	cf 93       	push	r28
    24b4:	00 d0       	rcall	.+0      	; 0x24b6 <pvPortMalloc+0x6>
    24b6:	00 d0       	rcall	.+0      	; 0x24b8 <pvPortMalloc+0x8>
    24b8:	cd b7       	in	r28, 0x3d	; 61
    24ba:	de b7       	in	r29, 0x3e	; 62
    24bc:	9c 83       	std	Y+4, r25	; 0x04
    24be:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    24c0:	1a 82       	std	Y+2, r1	; 0x02
    24c2:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    24c4:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    24c8:	80 91 bc 00 	lds	r24, 0x00BC
    24cc:	90 91 bd 00 	lds	r25, 0x00BD
    24d0:	2b 81       	ldd	r18, Y+3	; 0x03
    24d2:	3c 81       	ldd	r19, Y+4	; 0x04
    24d4:	82 0f       	add	r24, r18
    24d6:	93 1f       	adc	r25, r19
    24d8:	24 e0       	ldi	r18, 0x04	; 4
    24da:	80 3b       	cpi	r24, 0xB0	; 176
    24dc:	92 07       	cpc	r25, r18
    24de:	18 f5       	brcc	.+70     	; 0x2526 <pvPortMalloc+0x76>
    24e0:	20 91 bc 00 	lds	r18, 0x00BC
    24e4:	30 91 bd 00 	lds	r19, 0x00BD
    24e8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ea:	9c 81       	ldd	r25, Y+4	; 0x04
    24ec:	28 0f       	add	r18, r24
    24ee:	39 1f       	adc	r19, r25
    24f0:	80 91 bc 00 	lds	r24, 0x00BC
    24f4:	90 91 bd 00 	lds	r25, 0x00BD
    24f8:	82 17       	cp	r24, r18
    24fa:	93 07       	cpc	r25, r19
    24fc:	a0 f4       	brcc	.+40     	; 0x2526 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    24fe:	80 91 bc 00 	lds	r24, 0x00BC
    2502:	90 91 bd 00 	lds	r25, 0x00BD
    2506:	82 54       	subi	r24, 0x42	; 66
    2508:	9f 4f       	sbci	r25, 0xFF	; 255
    250a:	9a 83       	std	Y+2, r25	; 0x02
    250c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    250e:	20 91 bc 00 	lds	r18, 0x00BC
    2512:	30 91 bd 00 	lds	r19, 0x00BD
    2516:	8b 81       	ldd	r24, Y+3	; 0x03
    2518:	9c 81       	ldd	r25, Y+4	; 0x04
    251a:	82 0f       	add	r24, r18
    251c:	93 1f       	adc	r25, r19
    251e:	90 93 bd 00 	sts	0x00BD, r25
    2522:	80 93 bc 00 	sts	0x00BC, r24
		}	
	}
	xTaskResumeAll();
    2526:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    252a:	89 81       	ldd	r24, Y+1	; 0x01
    252c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    252e:	0f 90       	pop	r0
    2530:	0f 90       	pop	r0
    2532:	0f 90       	pop	r0
    2534:	0f 90       	pop	r0
    2536:	cf 91       	pop	r28
    2538:	df 91       	pop	r29
    253a:	08 95       	ret

0000253c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    253c:	df 93       	push	r29
    253e:	cf 93       	push	r28
    2540:	00 d0       	rcall	.+0      	; 0x2542 <vPortFree+0x6>
    2542:	cd b7       	in	r28, 0x3d	; 61
    2544:	de b7       	in	r29, 0x3e	; 62
    2546:	9a 83       	std	Y+2, r25	; 0x02
    2548:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    254a:	0f 90       	pop	r0
    254c:	0f 90       	pop	r0
    254e:	cf 91       	pop	r28
    2550:	df 91       	pop	r29
    2552:	08 95       	ret

00002554 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2554:	df 93       	push	r29
    2556:	cf 93       	push	r28
    2558:	cd b7       	in	r28, 0x3d	; 61
    255a:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    255c:	10 92 bd 00 	sts	0x00BD, r1
    2560:	10 92 bc 00 	sts	0x00BC, r1
}
    2564:	cf 91       	pop	r28
    2566:	df 91       	pop	r29
    2568:	08 95       	ret

0000256a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    256a:	df 93       	push	r29
    256c:	cf 93       	push	r28
    256e:	cd b7       	in	r28, 0x3d	; 61
    2570:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2572:	20 91 bc 00 	lds	r18, 0x00BC
    2576:	30 91 bd 00 	lds	r19, 0x00BD
    257a:	80 eb       	ldi	r24, 0xB0	; 176
    257c:	94 e0       	ldi	r25, 0x04	; 4
    257e:	82 1b       	sub	r24, r18
    2580:	93 0b       	sbc	r25, r19
}
    2582:	cf 91       	pop	r28
    2584:	df 91       	pop	r29
    2586:	08 95       	ret

00002588 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2588:	df 93       	push	r29
    258a:	cf 93       	push	r28
    258c:	00 d0       	rcall	.+0      	; 0x258e <vListInitialise+0x6>
    258e:	cd b7       	in	r28, 0x3d	; 61
    2590:	de b7       	in	r29, 0x3e	; 62
    2592:	9a 83       	std	Y+2, r25	; 0x02
    2594:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2596:	89 81       	ldd	r24, Y+1	; 0x01
    2598:	9a 81       	ldd	r25, Y+2	; 0x02
    259a:	03 96       	adiw	r24, 0x03	; 3
    259c:	e9 81       	ldd	r30, Y+1	; 0x01
    259e:	fa 81       	ldd	r31, Y+2	; 0x02
    25a0:	92 83       	std	Z+2, r25	; 0x02
    25a2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    25a4:	e9 81       	ldd	r30, Y+1	; 0x01
    25a6:	fa 81       	ldd	r31, Y+2	; 0x02
    25a8:	8f ef       	ldi	r24, 0xFF	; 255
    25aa:	9f ef       	ldi	r25, 0xFF	; 255
    25ac:	94 83       	std	Z+4, r25	; 0x04
    25ae:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    25b0:	89 81       	ldd	r24, Y+1	; 0x01
    25b2:	9a 81       	ldd	r25, Y+2	; 0x02
    25b4:	03 96       	adiw	r24, 0x03	; 3
    25b6:	e9 81       	ldd	r30, Y+1	; 0x01
    25b8:	fa 81       	ldd	r31, Y+2	; 0x02
    25ba:	96 83       	std	Z+6, r25	; 0x06
    25bc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    25be:	89 81       	ldd	r24, Y+1	; 0x01
    25c0:	9a 81       	ldd	r25, Y+2	; 0x02
    25c2:	03 96       	adiw	r24, 0x03	; 3
    25c4:	e9 81       	ldd	r30, Y+1	; 0x01
    25c6:	fa 81       	ldd	r31, Y+2	; 0x02
    25c8:	90 87       	std	Z+8, r25	; 0x08
    25ca:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    25cc:	e9 81       	ldd	r30, Y+1	; 0x01
    25ce:	fa 81       	ldd	r31, Y+2	; 0x02
    25d0:	10 82       	st	Z, r1
}
    25d2:	0f 90       	pop	r0
    25d4:	0f 90       	pop	r0
    25d6:	cf 91       	pop	r28
    25d8:	df 91       	pop	r29
    25da:	08 95       	ret

000025dc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    25dc:	df 93       	push	r29
    25de:	cf 93       	push	r28
    25e0:	00 d0       	rcall	.+0      	; 0x25e2 <vListInitialiseItem+0x6>
    25e2:	cd b7       	in	r28, 0x3d	; 61
    25e4:	de b7       	in	r29, 0x3e	; 62
    25e6:	9a 83       	std	Y+2, r25	; 0x02
    25e8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    25ea:	e9 81       	ldd	r30, Y+1	; 0x01
    25ec:	fa 81       	ldd	r31, Y+2	; 0x02
    25ee:	11 86       	std	Z+9, r1	; 0x09
    25f0:	10 86       	std	Z+8, r1	; 0x08
}
    25f2:	0f 90       	pop	r0
    25f4:	0f 90       	pop	r0
    25f6:	cf 91       	pop	r28
    25f8:	df 91       	pop	r29
    25fa:	08 95       	ret

000025fc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    25fc:	df 93       	push	r29
    25fe:	cf 93       	push	r28
    2600:	00 d0       	rcall	.+0      	; 0x2602 <vListInsertEnd+0x6>
    2602:	00 d0       	rcall	.+0      	; 0x2604 <vListInsertEnd+0x8>
    2604:	00 d0       	rcall	.+0      	; 0x2606 <vListInsertEnd+0xa>
    2606:	cd b7       	in	r28, 0x3d	; 61
    2608:	de b7       	in	r29, 0x3e	; 62
    260a:	9c 83       	std	Y+4, r25	; 0x04
    260c:	8b 83       	std	Y+3, r24	; 0x03
    260e:	7e 83       	std	Y+6, r23	; 0x06
    2610:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2612:	eb 81       	ldd	r30, Y+3	; 0x03
    2614:	fc 81       	ldd	r31, Y+4	; 0x04
    2616:	81 81       	ldd	r24, Z+1	; 0x01
    2618:	92 81       	ldd	r25, Z+2	; 0x02
    261a:	9a 83       	std	Y+2, r25	; 0x02
    261c:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    261e:	e9 81       	ldd	r30, Y+1	; 0x01
    2620:	fa 81       	ldd	r31, Y+2	; 0x02
    2622:	82 81       	ldd	r24, Z+2	; 0x02
    2624:	93 81       	ldd	r25, Z+3	; 0x03
    2626:	ed 81       	ldd	r30, Y+5	; 0x05
    2628:	fe 81       	ldd	r31, Y+6	; 0x06
    262a:	93 83       	std	Z+3, r25	; 0x03
    262c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    262e:	eb 81       	ldd	r30, Y+3	; 0x03
    2630:	fc 81       	ldd	r31, Y+4	; 0x04
    2632:	81 81       	ldd	r24, Z+1	; 0x01
    2634:	92 81       	ldd	r25, Z+2	; 0x02
    2636:	ed 81       	ldd	r30, Y+5	; 0x05
    2638:	fe 81       	ldd	r31, Y+6	; 0x06
    263a:	95 83       	std	Z+5, r25	; 0x05
    263c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	02 80       	ldd	r0, Z+2	; 0x02
    2644:	f3 81       	ldd	r31, Z+3	; 0x03
    2646:	e0 2d       	mov	r30, r0
    2648:	8d 81       	ldd	r24, Y+5	; 0x05
    264a:	9e 81       	ldd	r25, Y+6	; 0x06
    264c:	95 83       	std	Z+5, r25	; 0x05
    264e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2650:	8d 81       	ldd	r24, Y+5	; 0x05
    2652:	9e 81       	ldd	r25, Y+6	; 0x06
    2654:	e9 81       	ldd	r30, Y+1	; 0x01
    2656:	fa 81       	ldd	r31, Y+2	; 0x02
    2658:	93 83       	std	Z+3, r25	; 0x03
    265a:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    265c:	8d 81       	ldd	r24, Y+5	; 0x05
    265e:	9e 81       	ldd	r25, Y+6	; 0x06
    2660:	eb 81       	ldd	r30, Y+3	; 0x03
    2662:	fc 81       	ldd	r31, Y+4	; 0x04
    2664:	92 83       	std	Z+2, r25	; 0x02
    2666:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2668:	ed 81       	ldd	r30, Y+5	; 0x05
    266a:	fe 81       	ldd	r31, Y+6	; 0x06
    266c:	8b 81       	ldd	r24, Y+3	; 0x03
    266e:	9c 81       	ldd	r25, Y+4	; 0x04
    2670:	91 87       	std	Z+9, r25	; 0x09
    2672:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2674:	eb 81       	ldd	r30, Y+3	; 0x03
    2676:	fc 81       	ldd	r31, Y+4	; 0x04
    2678:	80 81       	ld	r24, Z
    267a:	8f 5f       	subi	r24, 0xFF	; 255
    267c:	eb 81       	ldd	r30, Y+3	; 0x03
    267e:	fc 81       	ldd	r31, Y+4	; 0x04
    2680:	80 83       	st	Z, r24
}
    2682:	26 96       	adiw	r28, 0x06	; 6
    2684:	0f b6       	in	r0, 0x3f	; 63
    2686:	f8 94       	cli
    2688:	de bf       	out	0x3e, r29	; 62
    268a:	0f be       	out	0x3f, r0	; 63
    268c:	cd bf       	out	0x3d, r28	; 61
    268e:	cf 91       	pop	r28
    2690:	df 91       	pop	r29
    2692:	08 95       	ret

00002694 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2694:	df 93       	push	r29
    2696:	cf 93       	push	r28
    2698:	cd b7       	in	r28, 0x3d	; 61
    269a:	de b7       	in	r29, 0x3e	; 62
    269c:	28 97       	sbiw	r28, 0x08	; 8
    269e:	0f b6       	in	r0, 0x3f	; 63
    26a0:	f8 94       	cli
    26a2:	de bf       	out	0x3e, r29	; 62
    26a4:	0f be       	out	0x3f, r0	; 63
    26a6:	cd bf       	out	0x3d, r28	; 61
    26a8:	9e 83       	std	Y+6, r25	; 0x06
    26aa:	8d 83       	std	Y+5, r24	; 0x05
    26ac:	78 87       	std	Y+8, r23	; 0x08
    26ae:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    26b0:	ef 81       	ldd	r30, Y+7	; 0x07
    26b2:	f8 85       	ldd	r31, Y+8	; 0x08
    26b4:	80 81       	ld	r24, Z
    26b6:	91 81       	ldd	r25, Z+1	; 0x01
    26b8:	9a 83       	std	Y+2, r25	; 0x02
    26ba:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	9a 81       	ldd	r25, Y+2	; 0x02
    26c0:	2f ef       	ldi	r18, 0xFF	; 255
    26c2:	8f 3f       	cpi	r24, 0xFF	; 255
    26c4:	92 07       	cpc	r25, r18
    26c6:	39 f4       	brne	.+14     	; 0x26d6 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    26c8:	ed 81       	ldd	r30, Y+5	; 0x05
    26ca:	fe 81       	ldd	r31, Y+6	; 0x06
    26cc:	87 81       	ldd	r24, Z+7	; 0x07
    26ce:	90 85       	ldd	r25, Z+8	; 0x08
    26d0:	9c 83       	std	Y+4, r25	; 0x04
    26d2:	8b 83       	std	Y+3, r24	; 0x03
    26d4:	18 c0       	rjmp	.+48     	; 0x2706 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    26d6:	8d 81       	ldd	r24, Y+5	; 0x05
    26d8:	9e 81       	ldd	r25, Y+6	; 0x06
    26da:	03 96       	adiw	r24, 0x03	; 3
    26dc:	9c 83       	std	Y+4, r25	; 0x04
    26de:	8b 83       	std	Y+3, r24	; 0x03
    26e0:	06 c0       	rjmp	.+12     	; 0x26ee <vListInsert+0x5a>
    26e2:	eb 81       	ldd	r30, Y+3	; 0x03
    26e4:	fc 81       	ldd	r31, Y+4	; 0x04
    26e6:	82 81       	ldd	r24, Z+2	; 0x02
    26e8:	93 81       	ldd	r25, Z+3	; 0x03
    26ea:	9c 83       	std	Y+4, r25	; 0x04
    26ec:	8b 83       	std	Y+3, r24	; 0x03
    26ee:	eb 81       	ldd	r30, Y+3	; 0x03
    26f0:	fc 81       	ldd	r31, Y+4	; 0x04
    26f2:	02 80       	ldd	r0, Z+2	; 0x02
    26f4:	f3 81       	ldd	r31, Z+3	; 0x03
    26f6:	e0 2d       	mov	r30, r0
    26f8:	20 81       	ld	r18, Z
    26fa:	31 81       	ldd	r19, Z+1	; 0x01
    26fc:	89 81       	ldd	r24, Y+1	; 0x01
    26fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2700:	82 17       	cp	r24, r18
    2702:	93 07       	cpc	r25, r19
    2704:	70 f7       	brcc	.-36     	; 0x26e2 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2706:	eb 81       	ldd	r30, Y+3	; 0x03
    2708:	fc 81       	ldd	r31, Y+4	; 0x04
    270a:	82 81       	ldd	r24, Z+2	; 0x02
    270c:	93 81       	ldd	r25, Z+3	; 0x03
    270e:	ef 81       	ldd	r30, Y+7	; 0x07
    2710:	f8 85       	ldd	r31, Y+8	; 0x08
    2712:	93 83       	std	Z+3, r25	; 0x03
    2714:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2716:	ef 81       	ldd	r30, Y+7	; 0x07
    2718:	f8 85       	ldd	r31, Y+8	; 0x08
    271a:	02 80       	ldd	r0, Z+2	; 0x02
    271c:	f3 81       	ldd	r31, Z+3	; 0x03
    271e:	e0 2d       	mov	r30, r0
    2720:	8f 81       	ldd	r24, Y+7	; 0x07
    2722:	98 85       	ldd	r25, Y+8	; 0x08
    2724:	95 83       	std	Z+5, r25	; 0x05
    2726:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2728:	ef 81       	ldd	r30, Y+7	; 0x07
    272a:	f8 85       	ldd	r31, Y+8	; 0x08
    272c:	8b 81       	ldd	r24, Y+3	; 0x03
    272e:	9c 81       	ldd	r25, Y+4	; 0x04
    2730:	95 83       	std	Z+5, r25	; 0x05
    2732:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2734:	8f 81       	ldd	r24, Y+7	; 0x07
    2736:	98 85       	ldd	r25, Y+8	; 0x08
    2738:	eb 81       	ldd	r30, Y+3	; 0x03
    273a:	fc 81       	ldd	r31, Y+4	; 0x04
    273c:	93 83       	std	Z+3, r25	; 0x03
    273e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2740:	ef 81       	ldd	r30, Y+7	; 0x07
    2742:	f8 85       	ldd	r31, Y+8	; 0x08
    2744:	8d 81       	ldd	r24, Y+5	; 0x05
    2746:	9e 81       	ldd	r25, Y+6	; 0x06
    2748:	91 87       	std	Z+9, r25	; 0x09
    274a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    274c:	ed 81       	ldd	r30, Y+5	; 0x05
    274e:	fe 81       	ldd	r31, Y+6	; 0x06
    2750:	80 81       	ld	r24, Z
    2752:	8f 5f       	subi	r24, 0xFF	; 255
    2754:	ed 81       	ldd	r30, Y+5	; 0x05
    2756:	fe 81       	ldd	r31, Y+6	; 0x06
    2758:	80 83       	st	Z, r24
}
    275a:	28 96       	adiw	r28, 0x08	; 8
    275c:	0f b6       	in	r0, 0x3f	; 63
    275e:	f8 94       	cli
    2760:	de bf       	out	0x3e, r29	; 62
    2762:	0f be       	out	0x3f, r0	; 63
    2764:	cd bf       	out	0x3d, r28	; 61
    2766:	cf 91       	pop	r28
    2768:	df 91       	pop	r29
    276a:	08 95       	ret

0000276c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    276c:	df 93       	push	r29
    276e:	cf 93       	push	r28
    2770:	00 d0       	rcall	.+0      	; 0x2772 <vListRemove+0x6>
    2772:	00 d0       	rcall	.+0      	; 0x2774 <vListRemove+0x8>
    2774:	cd b7       	in	r28, 0x3d	; 61
    2776:	de b7       	in	r29, 0x3e	; 62
    2778:	9c 83       	std	Y+4, r25	; 0x04
    277a:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    277c:	eb 81       	ldd	r30, Y+3	; 0x03
    277e:	fc 81       	ldd	r31, Y+4	; 0x04
    2780:	a2 81       	ldd	r26, Z+2	; 0x02
    2782:	b3 81       	ldd	r27, Z+3	; 0x03
    2784:	eb 81       	ldd	r30, Y+3	; 0x03
    2786:	fc 81       	ldd	r31, Y+4	; 0x04
    2788:	84 81       	ldd	r24, Z+4	; 0x04
    278a:	95 81       	ldd	r25, Z+5	; 0x05
    278c:	15 96       	adiw	r26, 0x05	; 5
    278e:	9c 93       	st	X, r25
    2790:	8e 93       	st	-X, r24
    2792:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2794:	eb 81       	ldd	r30, Y+3	; 0x03
    2796:	fc 81       	ldd	r31, Y+4	; 0x04
    2798:	a4 81       	ldd	r26, Z+4	; 0x04
    279a:	b5 81       	ldd	r27, Z+5	; 0x05
    279c:	eb 81       	ldd	r30, Y+3	; 0x03
    279e:	fc 81       	ldd	r31, Y+4	; 0x04
    27a0:	82 81       	ldd	r24, Z+2	; 0x02
    27a2:	93 81       	ldd	r25, Z+3	; 0x03
    27a4:	13 96       	adiw	r26, 0x03	; 3
    27a6:	9c 93       	st	X, r25
    27a8:	8e 93       	st	-X, r24
    27aa:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    27ac:	eb 81       	ldd	r30, Y+3	; 0x03
    27ae:	fc 81       	ldd	r31, Y+4	; 0x04
    27b0:	80 85       	ldd	r24, Z+8	; 0x08
    27b2:	91 85       	ldd	r25, Z+9	; 0x09
    27b4:	9a 83       	std	Y+2, r25	; 0x02
    27b6:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    27b8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ba:	fa 81       	ldd	r31, Y+2	; 0x02
    27bc:	21 81       	ldd	r18, Z+1	; 0x01
    27be:	32 81       	ldd	r19, Z+2	; 0x02
    27c0:	8b 81       	ldd	r24, Y+3	; 0x03
    27c2:	9c 81       	ldd	r25, Y+4	; 0x04
    27c4:	28 17       	cp	r18, r24
    27c6:	39 07       	cpc	r19, r25
    27c8:	41 f4       	brne	.+16     	; 0x27da <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    27ca:	eb 81       	ldd	r30, Y+3	; 0x03
    27cc:	fc 81       	ldd	r31, Y+4	; 0x04
    27ce:	84 81       	ldd	r24, Z+4	; 0x04
    27d0:	95 81       	ldd	r25, Z+5	; 0x05
    27d2:	e9 81       	ldd	r30, Y+1	; 0x01
    27d4:	fa 81       	ldd	r31, Y+2	; 0x02
    27d6:	92 83       	std	Z+2, r25	; 0x02
    27d8:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    27da:	eb 81       	ldd	r30, Y+3	; 0x03
    27dc:	fc 81       	ldd	r31, Y+4	; 0x04
    27de:	11 86       	std	Z+9, r1	; 0x09
    27e0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    27e2:	e9 81       	ldd	r30, Y+1	; 0x01
    27e4:	fa 81       	ldd	r31, Y+2	; 0x02
    27e6:	80 81       	ld	r24, Z
    27e8:	81 50       	subi	r24, 0x01	; 1
    27ea:	e9 81       	ldd	r30, Y+1	; 0x01
    27ec:	fa 81       	ldd	r31, Y+2	; 0x02
    27ee:	80 83       	st	Z, r24
}
    27f0:	0f 90       	pop	r0
    27f2:	0f 90       	pop	r0
    27f4:	0f 90       	pop	r0
    27f6:	0f 90       	pop	r0
    27f8:	cf 91       	pop	r28
    27fa:	df 91       	pop	r29
    27fc:	08 95       	ret

000027fe <main>:
//void LED_1(void *pv);
//void LED_2(void *pv);
//void LED_3(void *pv);

void main(void)
{
    27fe:	af 92       	push	r10
    2800:	bf 92       	push	r11
    2802:	cf 92       	push	r12
    2804:	df 92       	push	r13
    2806:	ef 92       	push	r14
    2808:	ff 92       	push	r15
    280a:	0f 93       	push	r16
    280c:	df 93       	push	r29
    280e:	cf 93       	push	r28
    2810:	cd b7       	in	r28, 0x3d	; 61
    2812:	de b7       	in	r29, 0x3e	; 62
	PORT_VoidInit();
    2814:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <PORT_VoidInit>
	CLCD_voidInit();
    2818:	0e 94 d5 09 	call	0x13aa	; 0x13aa <CLCD_voidInit>

//	xTaskCreate(&LED_1,NULL,100,NULL,0,NULL);
//	xTaskCreate(&LED_2,NULL,100,NULL,1,NULL);
//	xTaskCreate(&LED_3,NULL,100,NULL,2,NULL);

		xTaskCreate(&LCD1,NULL,250,NULL,1,NULL);
    281c:	83 e3       	ldi	r24, 0x33	; 51
    281e:	94 e1       	ldi	r25, 0x14	; 20
    2820:	60 e0       	ldi	r22, 0x00	; 0
    2822:	70 e0       	ldi	r23, 0x00	; 0
    2824:	4a ef       	ldi	r20, 0xFA	; 250
    2826:	50 e0       	ldi	r21, 0x00	; 0
    2828:	20 e0       	ldi	r18, 0x00	; 0
    282a:	30 e0       	ldi	r19, 0x00	; 0
    282c:	01 e0       	ldi	r16, 0x01	; 1
    282e:	ee 24       	eor	r14, r14
    2830:	ff 24       	eor	r15, r15
    2832:	cc 24       	eor	r12, r12
    2834:	dd 24       	eor	r13, r13
    2836:	aa 24       	eor	r10, r10
    2838:	bb 24       	eor	r11, r11
    283a:	0e 94 cd 1b 	call	0x379a	; 0x379a <xTaskGenericCreate>
		xTaskCreate(&LCD2,NULL,250,NULL,0,NULL);
    283e:	87 e4       	ldi	r24, 0x47	; 71
    2840:	94 e1       	ldi	r25, 0x14	; 20
    2842:	60 e0       	ldi	r22, 0x00	; 0
    2844:	70 e0       	ldi	r23, 0x00	; 0
    2846:	4a ef       	ldi	r20, 0xFA	; 250
    2848:	50 e0       	ldi	r21, 0x00	; 0
    284a:	20 e0       	ldi	r18, 0x00	; 0
    284c:	30 e0       	ldi	r19, 0x00	; 0
    284e:	00 e0       	ldi	r16, 0x00	; 0
    2850:	ee 24       	eor	r14, r14
    2852:	ff 24       	eor	r15, r15
    2854:	cc 24       	eor	r12, r12
    2856:	dd 24       	eor	r13, r13
    2858:	aa 24       	eor	r10, r10
    285a:	bb 24       	eor	r11, r11
    285c:	0e 94 cd 1b 	call	0x379a	; 0x379a <xTaskGenericCreate>

	vTaskStartScheduler();
    2860:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <vTaskStartScheduler>
    2864:	ff cf       	rjmp	.-2      	; 0x2864 <main+0x66>

00002866 <LCD1>:
	}
}


void LCD1(void *pv)
{
    2866:	df 93       	push	r29
    2868:	cf 93       	push	r28
    286a:	00 d0       	rcall	.+0      	; 0x286c <LCD1+0x6>
    286c:	cd b7       	in	r28, 0x3d	; 61
    286e:	de b7       	in	r29, 0x3e	; 62
    2870:	9a 83       	std	Y+2, r25	; 0x02
    2872:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		CLCD_voidGoToXY(0,0);
    2874:	80 e0       	ldi	r24, 0x00	; 0
    2876:	60 e0       	ldi	r22, 0x00	; 0
    2878:	0e 94 b6 0a 	call	0x156c	; 0x156c <CLCD_voidGoToXY>
		CLCD_voidSendString("iamtask1");
    287c:	80 e6       	ldi	r24, 0x60	; 96
    287e:	90 e0       	ldi	r25, 0x00	; 0
    2880:	0e 94 8d 0a 	call	0x151a	; 0x151a <CLCD_voidSendString>
		vTaskDelay(1000);
    2884:	88 ee       	ldi	r24, 0xE8	; 232
    2886:	93 e0       	ldi	r25, 0x03	; 3
    2888:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <vTaskDelay>
    288c:	f3 cf       	rjmp	.-26     	; 0x2874 <LCD1+0xe>

0000288e <LCD2>:
	}

}
void LCD2(void *pv)
{
    288e:	df 93       	push	r29
    2890:	cf 93       	push	r28
    2892:	00 d0       	rcall	.+0      	; 0x2894 <LCD2+0x6>
    2894:	cd b7       	in	r28, 0x3d	; 61
    2896:	de b7       	in	r29, 0x3e	; 62
    2898:	9a 83       	std	Y+2, r25	; 0x02
    289a:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		CLCD_voidGoToXY(1,0);
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	60 e0       	ldi	r22, 0x00	; 0
    28a0:	0e 94 b6 0a 	call	0x156c	; 0x156c <CLCD_voidGoToXY>
		CLCD_voidSendString("iamtask2");
    28a4:	89 e6       	ldi	r24, 0x69	; 105
    28a6:	90 e0       	ldi	r25, 0x00	; 0
    28a8:	0e 94 8d 0a 	call	0x151a	; 0x151a <CLCD_voidSendString>
		vTaskDelay(1000);
    28ac:	88 ee       	ldi	r24, 0xE8	; 232
    28ae:	93 e0       	ldi	r25, 0x03	; 3
    28b0:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <vTaskDelay>
    28b4:	f3 cf       	rjmp	.-26     	; 0x289c <LCD2+0xe>

000028b6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    28b6:	df 93       	push	r29
    28b8:	cf 93       	push	r28
    28ba:	cd b7       	in	r28, 0x3d	; 61
    28bc:	de b7       	in	r29, 0x3e	; 62
    28be:	28 97       	sbiw	r28, 0x08	; 8
    28c0:	0f b6       	in	r0, 0x3f	; 63
    28c2:	f8 94       	cli
    28c4:	de bf       	out	0x3e, r29	; 62
    28c6:	0f be       	out	0x3f, r0	; 63
    28c8:	cd bf       	out	0x3d, r28	; 61
    28ca:	9c 83       	std	Y+4, r25	; 0x04
    28cc:	8b 83       	std	Y+3, r24	; 0x03
    28ce:	7e 83       	std	Y+6, r23	; 0x06
    28d0:	6d 83       	std	Y+5, r22	; 0x05
    28d2:	58 87       	std	Y+8, r21	; 0x08
    28d4:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    28d6:	eb 81       	ldd	r30, Y+3	; 0x03
    28d8:	fc 81       	ldd	r31, Y+4	; 0x04
    28da:	81 e1       	ldi	r24, 0x11	; 17
    28dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    28de:	8b 81       	ldd	r24, Y+3	; 0x03
    28e0:	9c 81       	ldd	r25, Y+4	; 0x04
    28e2:	01 97       	sbiw	r24, 0x01	; 1
    28e4:	9c 83       	std	Y+4, r25	; 0x04
    28e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    28e8:	eb 81       	ldd	r30, Y+3	; 0x03
    28ea:	fc 81       	ldd	r31, Y+4	; 0x04
    28ec:	82 e2       	ldi	r24, 0x22	; 34
    28ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    28f0:	8b 81       	ldd	r24, Y+3	; 0x03
    28f2:	9c 81       	ldd	r25, Y+4	; 0x04
    28f4:	01 97       	sbiw	r24, 0x01	; 1
    28f6:	9c 83       	std	Y+4, r25	; 0x04
    28f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    28fa:	eb 81       	ldd	r30, Y+3	; 0x03
    28fc:	fc 81       	ldd	r31, Y+4	; 0x04
    28fe:	83 e3       	ldi	r24, 0x33	; 51
    2900:	80 83       	st	Z, r24
	pxTopOfStack--;
    2902:	8b 81       	ldd	r24, Y+3	; 0x03
    2904:	9c 81       	ldd	r25, Y+4	; 0x04
    2906:	01 97       	sbiw	r24, 0x01	; 1
    2908:	9c 83       	std	Y+4, r25	; 0x04
    290a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    290c:	8d 81       	ldd	r24, Y+5	; 0x05
    290e:	9e 81       	ldd	r25, Y+6	; 0x06
    2910:	9a 83       	std	Y+2, r25	; 0x02
    2912:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2914:	89 81       	ldd	r24, Y+1	; 0x01
    2916:	eb 81       	ldd	r30, Y+3	; 0x03
    2918:	fc 81       	ldd	r31, Y+4	; 0x04
    291a:	80 83       	st	Z, r24
	pxTopOfStack--;
    291c:	8b 81       	ldd	r24, Y+3	; 0x03
    291e:	9c 81       	ldd	r25, Y+4	; 0x04
    2920:	01 97       	sbiw	r24, 0x01	; 1
    2922:	9c 83       	std	Y+4, r25	; 0x04
    2924:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2926:	89 81       	ldd	r24, Y+1	; 0x01
    2928:	9a 81       	ldd	r25, Y+2	; 0x02
    292a:	89 2f       	mov	r24, r25
    292c:	99 27       	eor	r25, r25
    292e:	9a 83       	std	Y+2, r25	; 0x02
    2930:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2932:	89 81       	ldd	r24, Y+1	; 0x01
    2934:	eb 81       	ldd	r30, Y+3	; 0x03
    2936:	fc 81       	ldd	r31, Y+4	; 0x04
    2938:	80 83       	st	Z, r24
	pxTopOfStack--;
    293a:	8b 81       	ldd	r24, Y+3	; 0x03
    293c:	9c 81       	ldd	r25, Y+4	; 0x04
    293e:	01 97       	sbiw	r24, 0x01	; 1
    2940:	9c 83       	std	Y+4, r25	; 0x04
    2942:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2944:	eb 81       	ldd	r30, Y+3	; 0x03
    2946:	fc 81       	ldd	r31, Y+4	; 0x04
    2948:	10 82       	st	Z, r1
	pxTopOfStack--;
    294a:	8b 81       	ldd	r24, Y+3	; 0x03
    294c:	9c 81       	ldd	r25, Y+4	; 0x04
    294e:	01 97       	sbiw	r24, 0x01	; 1
    2950:	9c 83       	std	Y+4, r25	; 0x04
    2952:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2954:	eb 81       	ldd	r30, Y+3	; 0x03
    2956:	fc 81       	ldd	r31, Y+4	; 0x04
    2958:	80 e8       	ldi	r24, 0x80	; 128
    295a:	80 83       	st	Z, r24
	pxTopOfStack--;
    295c:	8b 81       	ldd	r24, Y+3	; 0x03
    295e:	9c 81       	ldd	r25, Y+4	; 0x04
    2960:	01 97       	sbiw	r24, 0x01	; 1
    2962:	9c 83       	std	Y+4, r25	; 0x04
    2964:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2966:	eb 81       	ldd	r30, Y+3	; 0x03
    2968:	fc 81       	ldd	r31, Y+4	; 0x04
    296a:	10 82       	st	Z, r1
	pxTopOfStack--;
    296c:	8b 81       	ldd	r24, Y+3	; 0x03
    296e:	9c 81       	ldd	r25, Y+4	; 0x04
    2970:	01 97       	sbiw	r24, 0x01	; 1
    2972:	9c 83       	std	Y+4, r25	; 0x04
    2974:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2976:	eb 81       	ldd	r30, Y+3	; 0x03
    2978:	fc 81       	ldd	r31, Y+4	; 0x04
    297a:	82 e0       	ldi	r24, 0x02	; 2
    297c:	80 83       	st	Z, r24
	pxTopOfStack--;
    297e:	8b 81       	ldd	r24, Y+3	; 0x03
    2980:	9c 81       	ldd	r25, Y+4	; 0x04
    2982:	01 97       	sbiw	r24, 0x01	; 1
    2984:	9c 83       	std	Y+4, r25	; 0x04
    2986:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2988:	eb 81       	ldd	r30, Y+3	; 0x03
    298a:	fc 81       	ldd	r31, Y+4	; 0x04
    298c:	83 e0       	ldi	r24, 0x03	; 3
    298e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2990:	8b 81       	ldd	r24, Y+3	; 0x03
    2992:	9c 81       	ldd	r25, Y+4	; 0x04
    2994:	01 97       	sbiw	r24, 0x01	; 1
    2996:	9c 83       	std	Y+4, r25	; 0x04
    2998:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    299a:	eb 81       	ldd	r30, Y+3	; 0x03
    299c:	fc 81       	ldd	r31, Y+4	; 0x04
    299e:	84 e0       	ldi	r24, 0x04	; 4
    29a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    29a2:	8b 81       	ldd	r24, Y+3	; 0x03
    29a4:	9c 81       	ldd	r25, Y+4	; 0x04
    29a6:	01 97       	sbiw	r24, 0x01	; 1
    29a8:	9c 83       	std	Y+4, r25	; 0x04
    29aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    29ac:	eb 81       	ldd	r30, Y+3	; 0x03
    29ae:	fc 81       	ldd	r31, Y+4	; 0x04
    29b0:	85 e0       	ldi	r24, 0x05	; 5
    29b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    29b4:	8b 81       	ldd	r24, Y+3	; 0x03
    29b6:	9c 81       	ldd	r25, Y+4	; 0x04
    29b8:	01 97       	sbiw	r24, 0x01	; 1
    29ba:	9c 83       	std	Y+4, r25	; 0x04
    29bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    29be:	eb 81       	ldd	r30, Y+3	; 0x03
    29c0:	fc 81       	ldd	r31, Y+4	; 0x04
    29c2:	86 e0       	ldi	r24, 0x06	; 6
    29c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    29c6:	8b 81       	ldd	r24, Y+3	; 0x03
    29c8:	9c 81       	ldd	r25, Y+4	; 0x04
    29ca:	01 97       	sbiw	r24, 0x01	; 1
    29cc:	9c 83       	std	Y+4, r25	; 0x04
    29ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    29d0:	eb 81       	ldd	r30, Y+3	; 0x03
    29d2:	fc 81       	ldd	r31, Y+4	; 0x04
    29d4:	87 e0       	ldi	r24, 0x07	; 7
    29d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    29d8:	8b 81       	ldd	r24, Y+3	; 0x03
    29da:	9c 81       	ldd	r25, Y+4	; 0x04
    29dc:	01 97       	sbiw	r24, 0x01	; 1
    29de:	9c 83       	std	Y+4, r25	; 0x04
    29e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    29e2:	eb 81       	ldd	r30, Y+3	; 0x03
    29e4:	fc 81       	ldd	r31, Y+4	; 0x04
    29e6:	88 e0       	ldi	r24, 0x08	; 8
    29e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    29ea:	8b 81       	ldd	r24, Y+3	; 0x03
    29ec:	9c 81       	ldd	r25, Y+4	; 0x04
    29ee:	01 97       	sbiw	r24, 0x01	; 1
    29f0:	9c 83       	std	Y+4, r25	; 0x04
    29f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    29f4:	eb 81       	ldd	r30, Y+3	; 0x03
    29f6:	fc 81       	ldd	r31, Y+4	; 0x04
    29f8:	89 e0       	ldi	r24, 0x09	; 9
    29fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    29fc:	8b 81       	ldd	r24, Y+3	; 0x03
    29fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2a00:	01 97       	sbiw	r24, 0x01	; 1
    2a02:	9c 83       	std	Y+4, r25	; 0x04
    2a04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2a06:	eb 81       	ldd	r30, Y+3	; 0x03
    2a08:	fc 81       	ldd	r31, Y+4	; 0x04
    2a0a:	80 e1       	ldi	r24, 0x10	; 16
    2a0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a10:	9c 81       	ldd	r25, Y+4	; 0x04
    2a12:	01 97       	sbiw	r24, 0x01	; 1
    2a14:	9c 83       	std	Y+4, r25	; 0x04
    2a16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2a18:	eb 81       	ldd	r30, Y+3	; 0x03
    2a1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a1c:	81 e1       	ldi	r24, 0x11	; 17
    2a1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a20:	8b 81       	ldd	r24, Y+3	; 0x03
    2a22:	9c 81       	ldd	r25, Y+4	; 0x04
    2a24:	01 97       	sbiw	r24, 0x01	; 1
    2a26:	9c 83       	std	Y+4, r25	; 0x04
    2a28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2a2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a2e:	82 e1       	ldi	r24, 0x12	; 18
    2a30:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a32:	8b 81       	ldd	r24, Y+3	; 0x03
    2a34:	9c 81       	ldd	r25, Y+4	; 0x04
    2a36:	01 97       	sbiw	r24, 0x01	; 1
    2a38:	9c 83       	std	Y+4, r25	; 0x04
    2a3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2a3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a40:	83 e1       	ldi	r24, 0x13	; 19
    2a42:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a44:	8b 81       	ldd	r24, Y+3	; 0x03
    2a46:	9c 81       	ldd	r25, Y+4	; 0x04
    2a48:	01 97       	sbiw	r24, 0x01	; 1
    2a4a:	9c 83       	std	Y+4, r25	; 0x04
    2a4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2a4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a50:	fc 81       	ldd	r31, Y+4	; 0x04
    2a52:	84 e1       	ldi	r24, 0x14	; 20
    2a54:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a56:	8b 81       	ldd	r24, Y+3	; 0x03
    2a58:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5a:	01 97       	sbiw	r24, 0x01	; 1
    2a5c:	9c 83       	std	Y+4, r25	; 0x04
    2a5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2a60:	eb 81       	ldd	r30, Y+3	; 0x03
    2a62:	fc 81       	ldd	r31, Y+4	; 0x04
    2a64:	85 e1       	ldi	r24, 0x15	; 21
    2a66:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a68:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6c:	01 97       	sbiw	r24, 0x01	; 1
    2a6e:	9c 83       	std	Y+4, r25	; 0x04
    2a70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2a72:	eb 81       	ldd	r30, Y+3	; 0x03
    2a74:	fc 81       	ldd	r31, Y+4	; 0x04
    2a76:	86 e1       	ldi	r24, 0x16	; 22
    2a78:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a7e:	01 97       	sbiw	r24, 0x01	; 1
    2a80:	9c 83       	std	Y+4, r25	; 0x04
    2a82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2a84:	eb 81       	ldd	r30, Y+3	; 0x03
    2a86:	fc 81       	ldd	r31, Y+4	; 0x04
    2a88:	87 e1       	ldi	r24, 0x17	; 23
    2a8a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a90:	01 97       	sbiw	r24, 0x01	; 1
    2a92:	9c 83       	std	Y+4, r25	; 0x04
    2a94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2a96:	eb 81       	ldd	r30, Y+3	; 0x03
    2a98:	fc 81       	ldd	r31, Y+4	; 0x04
    2a9a:	88 e1       	ldi	r24, 0x18	; 24
    2a9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa2:	01 97       	sbiw	r24, 0x01	; 1
    2aa4:	9c 83       	std	Y+4, r25	; 0x04
    2aa6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2aa8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aaa:	fc 81       	ldd	r31, Y+4	; 0x04
    2aac:	89 e1       	ldi	r24, 0x19	; 25
    2aae:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab4:	01 97       	sbiw	r24, 0x01	; 1
    2ab6:	9c 83       	std	Y+4, r25	; 0x04
    2ab8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2aba:	eb 81       	ldd	r30, Y+3	; 0x03
    2abc:	fc 81       	ldd	r31, Y+4	; 0x04
    2abe:	80 e2       	ldi	r24, 0x20	; 32
    2ac0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac6:	01 97       	sbiw	r24, 0x01	; 1
    2ac8:	9c 83       	std	Y+4, r25	; 0x04
    2aca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2acc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ace:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad0:	81 e2       	ldi	r24, 0x21	; 33
    2ad2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad8:	01 97       	sbiw	r24, 0x01	; 1
    2ada:	9c 83       	std	Y+4, r25	; 0x04
    2adc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2ade:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae2:	82 e2       	ldi	r24, 0x22	; 34
    2ae4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aea:	01 97       	sbiw	r24, 0x01	; 1
    2aec:	9c 83       	std	Y+4, r25	; 0x04
    2aee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2af0:	eb 81       	ldd	r30, Y+3	; 0x03
    2af2:	fc 81       	ldd	r31, Y+4	; 0x04
    2af4:	83 e2       	ldi	r24, 0x23	; 35
    2af6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2af8:	8b 81       	ldd	r24, Y+3	; 0x03
    2afa:	9c 81       	ldd	r25, Y+4	; 0x04
    2afc:	01 97       	sbiw	r24, 0x01	; 1
    2afe:	9c 83       	std	Y+4, r25	; 0x04
    2b00:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2b02:	8f 81       	ldd	r24, Y+7	; 0x07
    2b04:	98 85       	ldd	r25, Y+8	; 0x08
    2b06:	9a 83       	std	Y+2, r25	; 0x02
    2b08:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2b0a:	89 81       	ldd	r24, Y+1	; 0x01
    2b0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b10:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b12:	8b 81       	ldd	r24, Y+3	; 0x03
    2b14:	9c 81       	ldd	r25, Y+4	; 0x04
    2b16:	01 97       	sbiw	r24, 0x01	; 1
    2b18:	9c 83       	std	Y+4, r25	; 0x04
    2b1a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2b1c:	89 81       	ldd	r24, Y+1	; 0x01
    2b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b20:	89 2f       	mov	r24, r25
    2b22:	99 27       	eor	r25, r25
    2b24:	9a 83       	std	Y+2, r25	; 0x02
    2b26:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2b28:	89 81       	ldd	r24, Y+1	; 0x01
    2b2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b30:	8b 81       	ldd	r24, Y+3	; 0x03
    2b32:	9c 81       	ldd	r25, Y+4	; 0x04
    2b34:	01 97       	sbiw	r24, 0x01	; 1
    2b36:	9c 83       	std	Y+4, r25	; 0x04
    2b38:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2b3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b3e:	86 e2       	ldi	r24, 0x26	; 38
    2b40:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b42:	8b 81       	ldd	r24, Y+3	; 0x03
    2b44:	9c 81       	ldd	r25, Y+4	; 0x04
    2b46:	01 97       	sbiw	r24, 0x01	; 1
    2b48:	9c 83       	std	Y+4, r25	; 0x04
    2b4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2b4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b50:	87 e2       	ldi	r24, 0x27	; 39
    2b52:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b54:	8b 81       	ldd	r24, Y+3	; 0x03
    2b56:	9c 81       	ldd	r25, Y+4	; 0x04
    2b58:	01 97       	sbiw	r24, 0x01	; 1
    2b5a:	9c 83       	std	Y+4, r25	; 0x04
    2b5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2b5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b60:	fc 81       	ldd	r31, Y+4	; 0x04
    2b62:	88 e2       	ldi	r24, 0x28	; 40
    2b64:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b66:	8b 81       	ldd	r24, Y+3	; 0x03
    2b68:	9c 81       	ldd	r25, Y+4	; 0x04
    2b6a:	01 97       	sbiw	r24, 0x01	; 1
    2b6c:	9c 83       	std	Y+4, r25	; 0x04
    2b6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2b70:	eb 81       	ldd	r30, Y+3	; 0x03
    2b72:	fc 81       	ldd	r31, Y+4	; 0x04
    2b74:	89 e2       	ldi	r24, 0x29	; 41
    2b76:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b78:	8b 81       	ldd	r24, Y+3	; 0x03
    2b7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b7c:	01 97       	sbiw	r24, 0x01	; 1
    2b7e:	9c 83       	std	Y+4, r25	; 0x04
    2b80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2b82:	eb 81       	ldd	r30, Y+3	; 0x03
    2b84:	fc 81       	ldd	r31, Y+4	; 0x04
    2b86:	80 e3       	ldi	r24, 0x30	; 48
    2b88:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b8e:	01 97       	sbiw	r24, 0x01	; 1
    2b90:	9c 83       	std	Y+4, r25	; 0x04
    2b92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2b94:	eb 81       	ldd	r30, Y+3	; 0x03
    2b96:	fc 81       	ldd	r31, Y+4	; 0x04
    2b98:	81 e3       	ldi	r24, 0x31	; 49
    2b9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba0:	01 97       	sbiw	r24, 0x01	; 1
    2ba2:	9c 83       	std	Y+4, r25	; 0x04
    2ba4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2baa:	28 96       	adiw	r28, 0x08	; 8
    2bac:	0f b6       	in	r0, 0x3f	; 63
    2bae:	f8 94       	cli
    2bb0:	de bf       	out	0x3e, r29	; 62
    2bb2:	0f be       	out	0x3f, r0	; 63
    2bb4:	cd bf       	out	0x3d, r28	; 61
    2bb6:	cf 91       	pop	r28
    2bb8:	df 91       	pop	r29
    2bba:	08 95       	ret

00002bbc <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    2bbc:	df 93       	push	r29
    2bbe:	cf 93       	push	r28
    2bc0:	cd b7       	in	r28, 0x3d	; 61
    2bc2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2bc4:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2bc8:	a0 91 6e 05 	lds	r26, 0x056E
    2bcc:	b0 91 6f 05 	lds	r27, 0x056F
    2bd0:	cd 91       	ld	r28, X+
    2bd2:	cd bf       	out	0x3d, r28	; 61
    2bd4:	dd 91       	ld	r29, X+
    2bd6:	de bf       	out	0x3e, r29	; 62
    2bd8:	ff 91       	pop	r31
    2bda:	ef 91       	pop	r30
    2bdc:	df 91       	pop	r29
    2bde:	cf 91       	pop	r28
    2be0:	bf 91       	pop	r27
    2be2:	af 91       	pop	r26
    2be4:	9f 91       	pop	r25
    2be6:	8f 91       	pop	r24
    2be8:	7f 91       	pop	r23
    2bea:	6f 91       	pop	r22
    2bec:	5f 91       	pop	r21
    2bee:	4f 91       	pop	r20
    2bf0:	3f 91       	pop	r19
    2bf2:	2f 91       	pop	r18
    2bf4:	1f 91       	pop	r17
    2bf6:	0f 91       	pop	r16
    2bf8:	ff 90       	pop	r15
    2bfa:	ef 90       	pop	r14
    2bfc:	df 90       	pop	r13
    2bfe:	cf 90       	pop	r12
    2c00:	bf 90       	pop	r11
    2c02:	af 90       	pop	r10
    2c04:	9f 90       	pop	r9
    2c06:	8f 90       	pop	r8
    2c08:	7f 90       	pop	r7
    2c0a:	6f 90       	pop	r6
    2c0c:	5f 90       	pop	r5
    2c0e:	4f 90       	pop	r4
    2c10:	3f 90       	pop	r3
    2c12:	2f 90       	pop	r2
    2c14:	1f 90       	pop	r1
    2c16:	0f 90       	pop	r0
    2c18:	0f be       	out	0x3f, r0	; 63
    2c1a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2c1c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2c1e:	81 e0       	ldi	r24, 0x01	; 1
}
    2c20:	cf 91       	pop	r28
    2c22:	df 91       	pop	r29
    2c24:	08 95       	ret

00002c26 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2c26:	df 93       	push	r29
    2c28:	cf 93       	push	r28
    2c2a:	cd b7       	in	r28, 0x3d	; 61
    2c2c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2c2e:	cf 91       	pop	r28
    2c30:	df 91       	pop	r29
    2c32:	08 95       	ret

00002c34 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2c34:	0f 92       	push	r0
    2c36:	0f b6       	in	r0, 0x3f	; 63
    2c38:	f8 94       	cli
    2c3a:	0f 92       	push	r0
    2c3c:	1f 92       	push	r1
    2c3e:	11 24       	eor	r1, r1
    2c40:	2f 92       	push	r2
    2c42:	3f 92       	push	r3
    2c44:	4f 92       	push	r4
    2c46:	5f 92       	push	r5
    2c48:	6f 92       	push	r6
    2c4a:	7f 92       	push	r7
    2c4c:	8f 92       	push	r8
    2c4e:	9f 92       	push	r9
    2c50:	af 92       	push	r10
    2c52:	bf 92       	push	r11
    2c54:	cf 92       	push	r12
    2c56:	df 92       	push	r13
    2c58:	ef 92       	push	r14
    2c5a:	ff 92       	push	r15
    2c5c:	0f 93       	push	r16
    2c5e:	1f 93       	push	r17
    2c60:	2f 93       	push	r18
    2c62:	3f 93       	push	r19
    2c64:	4f 93       	push	r20
    2c66:	5f 93       	push	r21
    2c68:	6f 93       	push	r22
    2c6a:	7f 93       	push	r23
    2c6c:	8f 93       	push	r24
    2c6e:	9f 93       	push	r25
    2c70:	af 93       	push	r26
    2c72:	bf 93       	push	r27
    2c74:	cf 93       	push	r28
    2c76:	df 93       	push	r29
    2c78:	ef 93       	push	r30
    2c7a:	ff 93       	push	r31
    2c7c:	a0 91 6e 05 	lds	r26, 0x056E
    2c80:	b0 91 6f 05 	lds	r27, 0x056F
    2c84:	0d b6       	in	r0, 0x3d	; 61
    2c86:	0d 92       	st	X+, r0
    2c88:	0e b6       	in	r0, 0x3e	; 62
    2c8a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2c8c:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2c90:	a0 91 6e 05 	lds	r26, 0x056E
    2c94:	b0 91 6f 05 	lds	r27, 0x056F
    2c98:	cd 91       	ld	r28, X+
    2c9a:	cd bf       	out	0x3d, r28	; 61
    2c9c:	dd 91       	ld	r29, X+
    2c9e:	de bf       	out	0x3e, r29	; 62
    2ca0:	ff 91       	pop	r31
    2ca2:	ef 91       	pop	r30
    2ca4:	df 91       	pop	r29
    2ca6:	cf 91       	pop	r28
    2ca8:	bf 91       	pop	r27
    2caa:	af 91       	pop	r26
    2cac:	9f 91       	pop	r25
    2cae:	8f 91       	pop	r24
    2cb0:	7f 91       	pop	r23
    2cb2:	6f 91       	pop	r22
    2cb4:	5f 91       	pop	r21
    2cb6:	4f 91       	pop	r20
    2cb8:	3f 91       	pop	r19
    2cba:	2f 91       	pop	r18
    2cbc:	1f 91       	pop	r17
    2cbe:	0f 91       	pop	r16
    2cc0:	ff 90       	pop	r15
    2cc2:	ef 90       	pop	r14
    2cc4:	df 90       	pop	r13
    2cc6:	cf 90       	pop	r12
    2cc8:	bf 90       	pop	r11
    2cca:	af 90       	pop	r10
    2ccc:	9f 90       	pop	r9
    2cce:	8f 90       	pop	r8
    2cd0:	7f 90       	pop	r7
    2cd2:	6f 90       	pop	r6
    2cd4:	5f 90       	pop	r5
    2cd6:	4f 90       	pop	r4
    2cd8:	3f 90       	pop	r3
    2cda:	2f 90       	pop	r2
    2cdc:	1f 90       	pop	r1
    2cde:	0f 90       	pop	r0
    2ce0:	0f be       	out	0x3f, r0	; 63
    2ce2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2ce4:	08 95       	ret

00002ce6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2ce6:	0f 92       	push	r0
    2ce8:	0f b6       	in	r0, 0x3f	; 63
    2cea:	f8 94       	cli
    2cec:	0f 92       	push	r0
    2cee:	1f 92       	push	r1
    2cf0:	11 24       	eor	r1, r1
    2cf2:	2f 92       	push	r2
    2cf4:	3f 92       	push	r3
    2cf6:	4f 92       	push	r4
    2cf8:	5f 92       	push	r5
    2cfa:	6f 92       	push	r6
    2cfc:	7f 92       	push	r7
    2cfe:	8f 92       	push	r8
    2d00:	9f 92       	push	r9
    2d02:	af 92       	push	r10
    2d04:	bf 92       	push	r11
    2d06:	cf 92       	push	r12
    2d08:	df 92       	push	r13
    2d0a:	ef 92       	push	r14
    2d0c:	ff 92       	push	r15
    2d0e:	0f 93       	push	r16
    2d10:	1f 93       	push	r17
    2d12:	2f 93       	push	r18
    2d14:	3f 93       	push	r19
    2d16:	4f 93       	push	r20
    2d18:	5f 93       	push	r21
    2d1a:	6f 93       	push	r22
    2d1c:	7f 93       	push	r23
    2d1e:	8f 93       	push	r24
    2d20:	9f 93       	push	r25
    2d22:	af 93       	push	r26
    2d24:	bf 93       	push	r27
    2d26:	cf 93       	push	r28
    2d28:	df 93       	push	r29
    2d2a:	ef 93       	push	r30
    2d2c:	ff 93       	push	r31
    2d2e:	a0 91 6e 05 	lds	r26, 0x056E
    2d32:	b0 91 6f 05 	lds	r27, 0x056F
    2d36:	0d b6       	in	r0, 0x3d	; 61
    2d38:	0d 92       	st	X+, r0
    2d3a:	0e b6       	in	r0, 0x3e	; 62
    2d3c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2d3e:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <vTaskIncrementTick>
	vTaskSwitchContext();
    2d42:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2d46:	a0 91 6e 05 	lds	r26, 0x056E
    2d4a:	b0 91 6f 05 	lds	r27, 0x056F
    2d4e:	cd 91       	ld	r28, X+
    2d50:	cd bf       	out	0x3d, r28	; 61
    2d52:	dd 91       	ld	r29, X+
    2d54:	de bf       	out	0x3e, r29	; 62
    2d56:	ff 91       	pop	r31
    2d58:	ef 91       	pop	r30
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	bf 91       	pop	r27
    2d60:	af 91       	pop	r26
    2d62:	9f 91       	pop	r25
    2d64:	8f 91       	pop	r24
    2d66:	7f 91       	pop	r23
    2d68:	6f 91       	pop	r22
    2d6a:	5f 91       	pop	r21
    2d6c:	4f 91       	pop	r20
    2d6e:	3f 91       	pop	r19
    2d70:	2f 91       	pop	r18
    2d72:	1f 91       	pop	r17
    2d74:	0f 91       	pop	r16
    2d76:	ff 90       	pop	r15
    2d78:	ef 90       	pop	r14
    2d7a:	df 90       	pop	r13
    2d7c:	cf 90       	pop	r12
    2d7e:	bf 90       	pop	r11
    2d80:	af 90       	pop	r10
    2d82:	9f 90       	pop	r9
    2d84:	8f 90       	pop	r8
    2d86:	7f 90       	pop	r7
    2d88:	6f 90       	pop	r6
    2d8a:	5f 90       	pop	r5
    2d8c:	4f 90       	pop	r4
    2d8e:	3f 90       	pop	r3
    2d90:	2f 90       	pop	r2
    2d92:	1f 90       	pop	r1
    2d94:	0f 90       	pop	r0
    2d96:	0f be       	out	0x3f, r0	; 63
    2d98:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2d9a:	08 95       	ret

00002d9c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2d9c:	df 93       	push	r29
    2d9e:	cf 93       	push	r28
    2da0:	00 d0       	rcall	.+0      	; 0x2da2 <prvSetupTimerInterrupt+0x6>
    2da2:	00 d0       	rcall	.+0      	; 0x2da4 <prvSetupTimerInterrupt+0x8>
    2da4:	00 d0       	rcall	.+0      	; 0x2da6 <prvSetupTimerInterrupt+0xa>
    2da6:	cd b7       	in	r28, 0x3d	; 61
    2da8:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2daa:	85 e1       	ldi	r24, 0x15	; 21
    2dac:	94 e3       	ldi	r25, 0x34	; 52
    2dae:	a0 e0       	ldi	r26, 0x00	; 0
    2db0:	b0 e0       	ldi	r27, 0x00	; 0
    2db2:	8b 83       	std	Y+3, r24	; 0x03
    2db4:	9c 83       	std	Y+4, r25	; 0x04
    2db6:	ad 83       	std	Y+5, r26	; 0x05
    2db8:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2dba:	8b 81       	ldd	r24, Y+3	; 0x03
    2dbc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbe:	ad 81       	ldd	r26, Y+5	; 0x05
    2dc0:	be 81       	ldd	r27, Y+6	; 0x06
    2dc2:	68 94       	set
    2dc4:	15 f8       	bld	r1, 5
    2dc6:	b6 95       	lsr	r27
    2dc8:	a7 95       	ror	r26
    2dca:	97 95       	ror	r25
    2dcc:	87 95       	ror	r24
    2dce:	16 94       	lsr	r1
    2dd0:	d1 f7       	brne	.-12     	; 0x2dc6 <prvSetupTimerInterrupt+0x2a>
    2dd2:	8b 83       	std	Y+3, r24	; 0x03
    2dd4:	9c 83       	std	Y+4, r25	; 0x04
    2dd6:	ad 83       	std	Y+5, r26	; 0x05
    2dd8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    2dda:	8b 81       	ldd	r24, Y+3	; 0x03
    2ddc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dde:	ad 81       	ldd	r26, Y+5	; 0x05
    2de0:	be 81       	ldd	r27, Y+6	; 0x06
    2de2:	01 97       	sbiw	r24, 0x01	; 1
    2de4:	a1 09       	sbc	r26, r1
    2de6:	b1 09       	sbc	r27, r1
    2de8:	8b 83       	std	Y+3, r24	; 0x03
    2dea:	9c 83       	std	Y+4, r25	; 0x04
    2dec:	ad 83       	std	Y+5, r26	; 0x05
    2dee:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2df0:	8b 81       	ldd	r24, Y+3	; 0x03
    2df2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2df4:	8b 81       	ldd	r24, Y+3	; 0x03
    2df6:	9c 81       	ldd	r25, Y+4	; 0x04
    2df8:	ad 81       	ldd	r26, Y+5	; 0x05
    2dfa:	be 81       	ldd	r27, Y+6	; 0x06
    2dfc:	89 2f       	mov	r24, r25
    2dfe:	9a 2f       	mov	r25, r26
    2e00:	ab 2f       	mov	r26, r27
    2e02:	bb 27       	eor	r27, r27
    2e04:	8b 83       	std	Y+3, r24	; 0x03
    2e06:	9c 83       	std	Y+4, r25	; 0x04
    2e08:	ad 83       	std	Y+5, r26	; 0x05
    2e0a:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2e0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e0e:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2e10:	eb e4       	ldi	r30, 0x4B	; 75
    2e12:	f0 e0       	ldi	r31, 0x00	; 0
    2e14:	8a 81       	ldd	r24, Y+2	; 0x02
    2e16:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2e18:	ea e4       	ldi	r30, 0x4A	; 74
    2e1a:	f0 e0       	ldi	r31, 0x00	; 0
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2e20:	8b e0       	ldi	r24, 0x0B	; 11
    2e22:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2e24:	ee e4       	ldi	r30, 0x4E	; 78
    2e26:	f0 e0       	ldi	r31, 0x00	; 0
    2e28:	89 81       	ldd	r24, Y+1	; 0x01
    2e2a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2e2c:	e9 e5       	ldi	r30, 0x59	; 89
    2e2e:	f0 e0       	ldi	r31, 0x00	; 0
    2e30:	80 81       	ld	r24, Z
    2e32:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2e34:	89 81       	ldd	r24, Y+1	; 0x01
    2e36:	80 61       	ori	r24, 0x10	; 16
    2e38:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2e3a:	e9 e5       	ldi	r30, 0x59	; 89
    2e3c:	f0 e0       	ldi	r31, 0x00	; 0
    2e3e:	89 81       	ldd	r24, Y+1	; 0x01
    2e40:	80 83       	st	Z, r24
}
    2e42:	26 96       	adiw	r28, 0x06	; 6
    2e44:	0f b6       	in	r0, 0x3f	; 63
    2e46:	f8 94       	cli
    2e48:	de bf       	out	0x3e, r29	; 62
    2e4a:	0f be       	out	0x3f, r0	; 63
    2e4c:	cd bf       	out	0x3d, r28	; 61
    2e4e:	cf 91       	pop	r28
    2e50:	df 91       	pop	r29
    2e52:	08 95       	ret

00002e54 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2e54:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2e58:	18 95       	reti

00002e5a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2e5a:	df 93       	push	r29
    2e5c:	cf 93       	push	r28
    2e5e:	cd b7       	in	r28, 0x3d	; 61
    2e60:	de b7       	in	r29, 0x3e	; 62
    2e62:	28 97       	sbiw	r28, 0x08	; 8
    2e64:	0f b6       	in	r0, 0x3f	; 63
    2e66:	f8 94       	cli
    2e68:	de bf       	out	0x3e, r29	; 62
    2e6a:	0f be       	out	0x3f, r0	; 63
    2e6c:	cd bf       	out	0x3d, r28	; 61
    2e6e:	8f 83       	std	Y+7, r24	; 0x07
    2e70:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2e72:	1a 82       	std	Y+2, r1	; 0x02
    2e74:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2e76:	8f 81       	ldd	r24, Y+7	; 0x07
    2e78:	88 23       	and	r24, r24
    2e7a:	09 f4       	brne	.+2      	; 0x2e7e <xQueueCreate+0x24>
    2e7c:	8c c0       	rjmp	.+280    	; 0x2f96 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2e7e:	8f e1       	ldi	r24, 0x1F	; 31
    2e80:	90 e0       	ldi	r25, 0x00	; 0
    2e82:	0e 94 58 12 	call	0x24b0	; 0x24b0 <pvPortMalloc>
    2e86:	9e 83       	std	Y+6, r25	; 0x06
    2e88:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2e8a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e8c:	9e 81       	ldd	r25, Y+6	; 0x06
    2e8e:	00 97       	sbiw	r24, 0x00	; 0
    2e90:	09 f4       	brne	.+2      	; 0x2e94 <xQueueCreate+0x3a>
    2e92:	81 c0       	rjmp	.+258    	; 0x2f96 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2e94:	8f 81       	ldd	r24, Y+7	; 0x07
    2e96:	28 2f       	mov	r18, r24
    2e98:	30 e0       	ldi	r19, 0x00	; 0
    2e9a:	88 85       	ldd	r24, Y+8	; 0x08
    2e9c:	88 2f       	mov	r24, r24
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
    2ea0:	ac 01       	movw	r20, r24
    2ea2:	24 9f       	mul	r18, r20
    2ea4:	c0 01       	movw	r24, r0
    2ea6:	25 9f       	mul	r18, r21
    2ea8:	90 0d       	add	r25, r0
    2eaa:	34 9f       	mul	r19, r20
    2eac:	90 0d       	add	r25, r0
    2eae:	11 24       	eor	r1, r1
    2eb0:	01 96       	adiw	r24, 0x01	; 1
    2eb2:	9c 83       	std	Y+4, r25	; 0x04
    2eb4:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2eb6:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eba:	0e 94 58 12 	call	0x24b0	; 0x24b0 <pvPortMalloc>
    2ebe:	ed 81       	ldd	r30, Y+5	; 0x05
    2ec0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ec2:	91 83       	std	Z+1, r25	; 0x01
    2ec4:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    2ec6:	ed 81       	ldd	r30, Y+5	; 0x05
    2ec8:	fe 81       	ldd	r31, Y+6	; 0x06
    2eca:	80 81       	ld	r24, Z
    2ecc:	91 81       	ldd	r25, Z+1	; 0x01
    2ece:	00 97       	sbiw	r24, 0x00	; 0
    2ed0:	09 f4       	brne	.+2      	; 0x2ed4 <xQueueCreate+0x7a>
    2ed2:	5d c0       	rjmp	.+186    	; 0x2f8e <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2ed4:	ed 81       	ldd	r30, Y+5	; 0x05
    2ed6:	fe 81       	ldd	r31, Y+6	; 0x06
    2ed8:	40 81       	ld	r20, Z
    2eda:	51 81       	ldd	r21, Z+1	; 0x01
    2edc:	8f 81       	ldd	r24, Y+7	; 0x07
    2ede:	28 2f       	mov	r18, r24
    2ee0:	30 e0       	ldi	r19, 0x00	; 0
    2ee2:	88 85       	ldd	r24, Y+8	; 0x08
    2ee4:	88 2f       	mov	r24, r24
    2ee6:	90 e0       	ldi	r25, 0x00	; 0
    2ee8:	bc 01       	movw	r22, r24
    2eea:	26 9f       	mul	r18, r22
    2eec:	c0 01       	movw	r24, r0
    2eee:	27 9f       	mul	r18, r23
    2ef0:	90 0d       	add	r25, r0
    2ef2:	36 9f       	mul	r19, r22
    2ef4:	90 0d       	add	r25, r0
    2ef6:	11 24       	eor	r1, r1
    2ef8:	84 0f       	add	r24, r20
    2efa:	95 1f       	adc	r25, r21
    2efc:	ed 81       	ldd	r30, Y+5	; 0x05
    2efe:	fe 81       	ldd	r31, Y+6	; 0x06
    2f00:	93 83       	std	Z+3, r25	; 0x03
    2f02:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2f04:	ed 81       	ldd	r30, Y+5	; 0x05
    2f06:	fe 81       	ldd	r31, Y+6	; 0x06
    2f08:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2f0a:	ed 81       	ldd	r30, Y+5	; 0x05
    2f0c:	fe 81       	ldd	r31, Y+6	; 0x06
    2f0e:	80 81       	ld	r24, Z
    2f10:	91 81       	ldd	r25, Z+1	; 0x01
    2f12:	ed 81       	ldd	r30, Y+5	; 0x05
    2f14:	fe 81       	ldd	r31, Y+6	; 0x06
    2f16:	95 83       	std	Z+5, r25	; 0x05
    2f18:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    2f1a:	ed 81       	ldd	r30, Y+5	; 0x05
    2f1c:	fe 81       	ldd	r31, Y+6	; 0x06
    2f1e:	40 81       	ld	r20, Z
    2f20:	51 81       	ldd	r21, Z+1	; 0x01
    2f22:	8f 81       	ldd	r24, Y+7	; 0x07
    2f24:	88 2f       	mov	r24, r24
    2f26:	90 e0       	ldi	r25, 0x00	; 0
    2f28:	9c 01       	movw	r18, r24
    2f2a:	21 50       	subi	r18, 0x01	; 1
    2f2c:	30 40       	sbci	r19, 0x00	; 0
    2f2e:	88 85       	ldd	r24, Y+8	; 0x08
    2f30:	88 2f       	mov	r24, r24
    2f32:	90 e0       	ldi	r25, 0x00	; 0
    2f34:	bc 01       	movw	r22, r24
    2f36:	26 9f       	mul	r18, r22
    2f38:	c0 01       	movw	r24, r0
    2f3a:	27 9f       	mul	r18, r23
    2f3c:	90 0d       	add	r25, r0
    2f3e:	36 9f       	mul	r19, r22
    2f40:	90 0d       	add	r25, r0
    2f42:	11 24       	eor	r1, r1
    2f44:	84 0f       	add	r24, r20
    2f46:	95 1f       	adc	r25, r21
    2f48:	ed 81       	ldd	r30, Y+5	; 0x05
    2f4a:	fe 81       	ldd	r31, Y+6	; 0x06
    2f4c:	97 83       	std	Z+7, r25	; 0x07
    2f4e:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2f50:	ed 81       	ldd	r30, Y+5	; 0x05
    2f52:	fe 81       	ldd	r31, Y+6	; 0x06
    2f54:	8f 81       	ldd	r24, Y+7	; 0x07
    2f56:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2f58:	ed 81       	ldd	r30, Y+5	; 0x05
    2f5a:	fe 81       	ldd	r31, Y+6	; 0x06
    2f5c:	88 85       	ldd	r24, Y+8	; 0x08
    2f5e:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2f60:	ed 81       	ldd	r30, Y+5	; 0x05
    2f62:	fe 81       	ldd	r31, Y+6	; 0x06
    2f64:	8f ef       	ldi	r24, 0xFF	; 255
    2f66:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2f68:	ed 81       	ldd	r30, Y+5	; 0x05
    2f6a:	fe 81       	ldd	r31, Y+6	; 0x06
    2f6c:	8f ef       	ldi	r24, 0xFF	; 255
    2f6e:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2f70:	8d 81       	ldd	r24, Y+5	; 0x05
    2f72:	9e 81       	ldd	r25, Y+6	; 0x06
    2f74:	08 96       	adiw	r24, 0x08	; 8
    2f76:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2f7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2f7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2f7e:	41 96       	adiw	r24, 0x11	; 17
    2f80:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2f84:	8d 81       	ldd	r24, Y+5	; 0x05
    2f86:	9e 81       	ldd	r25, Y+6	; 0x06
    2f88:	9a 83       	std	Y+2, r25	; 0x02
    2f8a:	89 83       	std	Y+1, r24	; 0x01
    2f8c:	04 c0       	rjmp	.+8      	; 0x2f96 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2f8e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f90:	9e 81       	ldd	r25, Y+6	; 0x06
    2f92:	0e 94 9e 12 	call	0x253c	; 0x253c <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2f96:	89 81       	ldd	r24, Y+1	; 0x01
    2f98:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f9a:	28 96       	adiw	r28, 0x08	; 8
    2f9c:	0f b6       	in	r0, 0x3f	; 63
    2f9e:	f8 94       	cli
    2fa0:	de bf       	out	0x3e, r29	; 62
    2fa2:	0f be       	out	0x3f, r0	; 63
    2fa4:	cd bf       	out	0x3d, r28	; 61
    2fa6:	cf 91       	pop	r28
    2fa8:	df 91       	pop	r29
    2faa:	08 95       	ret

00002fac <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    2fac:	df 93       	push	r29
    2fae:	cf 93       	push	r28
    2fb0:	00 d0       	rcall	.+0      	; 0x2fb2 <xQueueCreateCountingSemaphore+0x6>
    2fb2:	00 d0       	rcall	.+0      	; 0x2fb4 <xQueueCreateCountingSemaphore+0x8>
    2fb4:	cd b7       	in	r28, 0x3d	; 61
    2fb6:	de b7       	in	r29, 0x3e	; 62
    2fb8:	8b 83       	std	Y+3, r24	; 0x03
    2fba:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    2fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fbe:	60 e0       	ldi	r22, 0x00	; 0
    2fc0:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <xQueueCreate>
    2fc4:	9a 83       	std	Y+2, r25	; 0x02
    2fc6:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    2fc8:	89 81       	ldd	r24, Y+1	; 0x01
    2fca:	9a 81       	ldd	r25, Y+2	; 0x02
    2fcc:	00 97       	sbiw	r24, 0x00	; 0
    2fce:	21 f0       	breq	.+8      	; 0x2fd8 <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    2fd0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd4:	8c 81       	ldd	r24, Y+4	; 0x04
    2fd6:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    2fd8:	89 81       	ldd	r24, Y+1	; 0x01
    2fda:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    2fdc:	0f 90       	pop	r0
    2fde:	0f 90       	pop	r0
    2fe0:	0f 90       	pop	r0
    2fe2:	0f 90       	pop	r0
    2fe4:	cf 91       	pop	r28
    2fe6:	df 91       	pop	r29
    2fe8:	08 95       	ret

00002fea <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2fea:	df 93       	push	r29
    2fec:	cf 93       	push	r28
    2fee:	cd b7       	in	r28, 0x3d	; 61
    2ff0:	de b7       	in	r29, 0x3e	; 62
    2ff2:	2c 97       	sbiw	r28, 0x0c	; 12
    2ff4:	0f b6       	in	r0, 0x3f	; 63
    2ff6:	f8 94       	cli
    2ff8:	de bf       	out	0x3e, r29	; 62
    2ffa:	0f be       	out	0x3f, r0	; 63
    2ffc:	cd bf       	out	0x3d, r28	; 61
    2ffe:	9e 83       	std	Y+6, r25	; 0x06
    3000:	8d 83       	std	Y+5, r24	; 0x05
    3002:	78 87       	std	Y+8, r23	; 0x08
    3004:	6f 83       	std	Y+7, r22	; 0x07
    3006:	5a 87       	std	Y+10, r21	; 0x0a
    3008:	49 87       	std	Y+9, r20	; 0x09
    300a:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    300c:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    300e:	0f b6       	in	r0, 0x3f	; 63
    3010:	f8 94       	cli
    3012:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3014:	ed 81       	ldd	r30, Y+5	; 0x05
    3016:	fe 81       	ldd	r31, Y+6	; 0x06
    3018:	92 8d       	ldd	r25, Z+26	; 0x1a
    301a:	ed 81       	ldd	r30, Y+5	; 0x05
    301c:	fe 81       	ldd	r31, Y+6	; 0x06
    301e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3020:	98 17       	cp	r25, r24
    3022:	d8 f4       	brcc	.+54     	; 0x305a <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3024:	8d 81       	ldd	r24, Y+5	; 0x05
    3026:	9e 81       	ldd	r25, Y+6	; 0x06
    3028:	2f 81       	ldd	r18, Y+7	; 0x07
    302a:	38 85       	ldd	r19, Y+8	; 0x08
    302c:	b9 01       	movw	r22, r18
    302e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3030:	0e 94 30 1a 	call	0x3460	; 0x3460 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3034:	ed 81       	ldd	r30, Y+5	; 0x05
    3036:	fe 81       	ldd	r31, Y+6	; 0x06
    3038:	81 89       	ldd	r24, Z+17	; 0x11
    303a:	88 23       	and	r24, r24
    303c:	49 f0       	breq	.+18     	; 0x3050 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    303e:	8d 81       	ldd	r24, Y+5	; 0x05
    3040:	9e 81       	ldd	r25, Y+6	; 0x06
    3042:	41 96       	adiw	r24, 0x11	; 17
    3044:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskRemoveFromEventList>
    3048:	81 30       	cpi	r24, 0x01	; 1
    304a:	11 f4       	brne	.+4      	; 0x3050 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    304c:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3050:	0f 90       	pop	r0
    3052:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3054:	81 e0       	ldi	r24, 0x01	; 1
    3056:	8c 87       	std	Y+12, r24	; 0x0c
    3058:	5c c0       	rjmp	.+184    	; 0x3112 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    305a:	89 85       	ldd	r24, Y+9	; 0x09
    305c:	9a 85       	ldd	r25, Y+10	; 0x0a
    305e:	00 97       	sbiw	r24, 0x00	; 0
    3060:	21 f4       	brne	.+8      	; 0x306a <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3062:	0f 90       	pop	r0
    3064:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3066:	1c 86       	std	Y+12, r1	; 0x0c
    3068:	54 c0       	rjmp	.+168    	; 0x3112 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    306a:	89 81       	ldd	r24, Y+1	; 0x01
    306c:	88 23       	and	r24, r24
    306e:	31 f4       	brne	.+12     	; 0x307c <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3070:	ce 01       	movw	r24, r28
    3072:	02 96       	adiw	r24, 0x02	; 2
    3074:	0e 94 ad 20 	call	0x415a	; 0x415a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3078:	81 e0       	ldi	r24, 0x01	; 1
    307a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    307c:	0f 90       	pop	r0
    307e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3080:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3084:	0f b6       	in	r0, 0x3f	; 63
    3086:	f8 94       	cli
    3088:	0f 92       	push	r0
    308a:	ed 81       	ldd	r30, Y+5	; 0x05
    308c:	fe 81       	ldd	r31, Y+6	; 0x06
    308e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3090:	8f 3f       	cpi	r24, 0xFF	; 255
    3092:	19 f4       	brne	.+6      	; 0x309a <xQueueGenericSend+0xb0>
    3094:	ed 81       	ldd	r30, Y+5	; 0x05
    3096:	fe 81       	ldd	r31, Y+6	; 0x06
    3098:	15 8e       	std	Z+29, r1	; 0x1d
    309a:	ed 81       	ldd	r30, Y+5	; 0x05
    309c:	fe 81       	ldd	r31, Y+6	; 0x06
    309e:	86 8d       	ldd	r24, Z+30	; 0x1e
    30a0:	8f 3f       	cpi	r24, 0xFF	; 255
    30a2:	19 f4       	brne	.+6      	; 0x30aa <xQueueGenericSend+0xc0>
    30a4:	ed 81       	ldd	r30, Y+5	; 0x05
    30a6:	fe 81       	ldd	r31, Y+6	; 0x06
    30a8:	16 8e       	std	Z+30, r1	; 0x1e
    30aa:	0f 90       	pop	r0
    30ac:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    30ae:	ce 01       	movw	r24, r28
    30b0:	02 96       	adiw	r24, 0x02	; 2
    30b2:	9e 01       	movw	r18, r28
    30b4:	27 5f       	subi	r18, 0xF7	; 247
    30b6:	3f 4f       	sbci	r19, 0xFF	; 255
    30b8:	b9 01       	movw	r22, r18
    30ba:	0e 94 c6 20 	call	0x418c	; 0x418c <xTaskCheckForTimeOut>
    30be:	88 23       	and	r24, r24
    30c0:	09 f5       	brne	.+66     	; 0x3104 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    30c2:	8d 81       	ldd	r24, Y+5	; 0x05
    30c4:	9e 81       	ldd	r25, Y+6	; 0x06
    30c6:	0e 94 94 1b 	call	0x3728	; 0x3728 <prvIsQueueFull>
    30ca:	88 23       	and	r24, r24
    30cc:	a1 f0       	breq	.+40     	; 0x30f6 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    30ce:	8d 81       	ldd	r24, Y+5	; 0x05
    30d0:	9e 81       	ldd	r25, Y+6	; 0x06
    30d2:	08 96       	adiw	r24, 0x08	; 8
    30d4:	29 85       	ldd	r18, Y+9	; 0x09
    30d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    30d8:	b9 01       	movw	r22, r18
    30da:	0e 94 0f 20 	call	0x401e	; 0x401e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    30de:	8d 81       	ldd	r24, Y+5	; 0x05
    30e0:	9e 81       	ldd	r25, Y+6	; 0x06
    30e2:	0e 94 0d 1b 	call	0x361a	; 0x361a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    30e6:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>
    30ea:	88 23       	and	r24, r24
    30ec:	09 f0       	breq	.+2      	; 0x30f0 <xQueueGenericSend+0x106>
    30ee:	8f cf       	rjmp	.-226    	; 0x300e <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    30f0:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
    30f4:	8c cf       	rjmp	.-232    	; 0x300e <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    30f6:	8d 81       	ldd	r24, Y+5	; 0x05
    30f8:	9e 81       	ldd	r25, Y+6	; 0x06
    30fa:	0e 94 0d 1b 	call	0x361a	; 0x361a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    30fe:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>
    3102:	85 cf       	rjmp	.-246    	; 0x300e <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3104:	8d 81       	ldd	r24, Y+5	; 0x05
    3106:	9e 81       	ldd	r25, Y+6	; 0x06
    3108:	0e 94 0d 1b 	call	0x361a	; 0x361a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    310c:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3110:	1c 86       	std	Y+12, r1	; 0x0c
    3112:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    3114:	2c 96       	adiw	r28, 0x0c	; 12
    3116:	0f b6       	in	r0, 0x3f	; 63
    3118:	f8 94       	cli
    311a:	de bf       	out	0x3e, r29	; 62
    311c:	0f be       	out	0x3f, r0	; 63
    311e:	cd bf       	out	0x3d, r28	; 61
    3120:	cf 91       	pop	r28
    3122:	df 91       	pop	r29
    3124:	08 95       	ret

00003126 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3126:	df 93       	push	r29
    3128:	cf 93       	push	r28
    312a:	cd b7       	in	r28, 0x3d	; 61
    312c:	de b7       	in	r29, 0x3e	; 62
    312e:	29 97       	sbiw	r28, 0x09	; 9
    3130:	0f b6       	in	r0, 0x3f	; 63
    3132:	f8 94       	cli
    3134:	de bf       	out	0x3e, r29	; 62
    3136:	0f be       	out	0x3f, r0	; 63
    3138:	cd bf       	out	0x3d, r28	; 61
    313a:	9c 83       	std	Y+4, r25	; 0x04
    313c:	8b 83       	std	Y+3, r24	; 0x03
    313e:	7e 83       	std	Y+6, r23	; 0x06
    3140:	6d 83       	std	Y+5, r22	; 0x05
    3142:	58 87       	std	Y+8, r21	; 0x08
    3144:	4f 83       	std	Y+7, r20	; 0x07
    3146:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3148:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    314a:	eb 81       	ldd	r30, Y+3	; 0x03
    314c:	fc 81       	ldd	r31, Y+4	; 0x04
    314e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3150:	eb 81       	ldd	r30, Y+3	; 0x03
    3152:	fc 81       	ldd	r31, Y+4	; 0x04
    3154:	83 8d       	ldd	r24, Z+27	; 0x1b
    3156:	98 17       	cp	r25, r24
    3158:	40 f5       	brcc	.+80     	; 0x31aa <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    315a:	8b 81       	ldd	r24, Y+3	; 0x03
    315c:	9c 81       	ldd	r25, Y+4	; 0x04
    315e:	2d 81       	ldd	r18, Y+5	; 0x05
    3160:	3e 81       	ldd	r19, Y+6	; 0x06
    3162:	b9 01       	movw	r22, r18
    3164:	49 85       	ldd	r20, Y+9	; 0x09
    3166:	0e 94 30 1a 	call	0x3460	; 0x3460 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    316a:	eb 81       	ldd	r30, Y+3	; 0x03
    316c:	fc 81       	ldd	r31, Y+4	; 0x04
    316e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3170:	8f 3f       	cpi	r24, 0xFF	; 255
    3172:	89 f4       	brne	.+34     	; 0x3196 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3174:	eb 81       	ldd	r30, Y+3	; 0x03
    3176:	fc 81       	ldd	r31, Y+4	; 0x04
    3178:	81 89       	ldd	r24, Z+17	; 0x11
    317a:	88 23       	and	r24, r24
    317c:	99 f0       	breq	.+38     	; 0x31a4 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    317e:	8b 81       	ldd	r24, Y+3	; 0x03
    3180:	9c 81       	ldd	r25, Y+4	; 0x04
    3182:	41 96       	adiw	r24, 0x11	; 17
    3184:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskRemoveFromEventList>
    3188:	88 23       	and	r24, r24
    318a:	61 f0       	breq	.+24     	; 0x31a4 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    318c:	ef 81       	ldd	r30, Y+7	; 0x07
    318e:	f8 85       	ldd	r31, Y+8	; 0x08
    3190:	81 e0       	ldi	r24, 0x01	; 1
    3192:	80 83       	st	Z, r24
    3194:	07 c0       	rjmp	.+14     	; 0x31a4 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3196:	eb 81       	ldd	r30, Y+3	; 0x03
    3198:	fc 81       	ldd	r31, Y+4	; 0x04
    319a:	86 8d       	ldd	r24, Z+30	; 0x1e
    319c:	8f 5f       	subi	r24, 0xFF	; 255
    319e:	eb 81       	ldd	r30, Y+3	; 0x03
    31a0:	fc 81       	ldd	r31, Y+4	; 0x04
    31a2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    31a4:	81 e0       	ldi	r24, 0x01	; 1
    31a6:	8a 83       	std	Y+2, r24	; 0x02
    31a8:	01 c0       	rjmp	.+2      	; 0x31ac <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    31aa:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    31ac:	8a 81       	ldd	r24, Y+2	; 0x02
}
    31ae:	29 96       	adiw	r28, 0x09	; 9
    31b0:	0f b6       	in	r0, 0x3f	; 63
    31b2:	f8 94       	cli
    31b4:	de bf       	out	0x3e, r29	; 62
    31b6:	0f be       	out	0x3f, r0	; 63
    31b8:	cd bf       	out	0x3d, r28	; 61
    31ba:	cf 91       	pop	r28
    31bc:	df 91       	pop	r29
    31be:	08 95       	ret

000031c0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    31c0:	df 93       	push	r29
    31c2:	cf 93       	push	r28
    31c4:	cd b7       	in	r28, 0x3d	; 61
    31c6:	de b7       	in	r29, 0x3e	; 62
    31c8:	2e 97       	sbiw	r28, 0x0e	; 14
    31ca:	0f b6       	in	r0, 0x3f	; 63
    31cc:	f8 94       	cli
    31ce:	de bf       	out	0x3e, r29	; 62
    31d0:	0f be       	out	0x3f, r0	; 63
    31d2:	cd bf       	out	0x3d, r28	; 61
    31d4:	98 87       	std	Y+8, r25	; 0x08
    31d6:	8f 83       	std	Y+7, r24	; 0x07
    31d8:	7a 87       	std	Y+10, r23	; 0x0a
    31da:	69 87       	std	Y+9, r22	; 0x09
    31dc:	5c 87       	std	Y+12, r21	; 0x0c
    31de:	4b 87       	std	Y+11, r20	; 0x0b
    31e0:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    31e2:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    31e4:	0f b6       	in	r0, 0x3f	; 63
    31e6:	f8 94       	cli
    31e8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    31ea:	ef 81       	ldd	r30, Y+7	; 0x07
    31ec:	f8 85       	ldd	r31, Y+8	; 0x08
    31ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    31f0:	88 23       	and	r24, r24
    31f2:	09 f4       	brne	.+2      	; 0x31f6 <xQueueGenericReceive+0x36>
    31f4:	3f c0       	rjmp	.+126    	; 0x3274 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    31f6:	ef 81       	ldd	r30, Y+7	; 0x07
    31f8:	f8 85       	ldd	r31, Y+8	; 0x08
    31fa:	86 81       	ldd	r24, Z+6	; 0x06
    31fc:	97 81       	ldd	r25, Z+7	; 0x07
    31fe:	9a 83       	std	Y+2, r25	; 0x02
    3200:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3202:	8f 81       	ldd	r24, Y+7	; 0x07
    3204:	98 85       	ldd	r25, Y+8	; 0x08
    3206:	29 85       	ldd	r18, Y+9	; 0x09
    3208:	3a 85       	ldd	r19, Y+10	; 0x0a
    320a:	b9 01       	movw	r22, r18
    320c:	0e 94 c5 1a 	call	0x358a	; 0x358a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3210:	8d 85       	ldd	r24, Y+13	; 0x0d
    3212:	88 23       	and	r24, r24
    3214:	b1 f4       	brne	.+44     	; 0x3242 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3216:	ef 81       	ldd	r30, Y+7	; 0x07
    3218:	f8 85       	ldd	r31, Y+8	; 0x08
    321a:	82 8d       	ldd	r24, Z+26	; 0x1a
    321c:	81 50       	subi	r24, 0x01	; 1
    321e:	ef 81       	ldd	r30, Y+7	; 0x07
    3220:	f8 85       	ldd	r31, Y+8	; 0x08
    3222:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3224:	ef 81       	ldd	r30, Y+7	; 0x07
    3226:	f8 85       	ldd	r31, Y+8	; 0x08
    3228:	80 85       	ldd	r24, Z+8	; 0x08
    322a:	88 23       	and	r24, r24
    322c:	f1 f0       	breq	.+60     	; 0x326a <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    322e:	8f 81       	ldd	r24, Y+7	; 0x07
    3230:	98 85       	ldd	r25, Y+8	; 0x08
    3232:	08 96       	adiw	r24, 0x08	; 8
    3234:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskRemoveFromEventList>
    3238:	81 30       	cpi	r24, 0x01	; 1
    323a:	b9 f4       	brne	.+46     	; 0x326a <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    323c:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
    3240:	14 c0       	rjmp	.+40     	; 0x326a <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3242:	ef 81       	ldd	r30, Y+7	; 0x07
    3244:	f8 85       	ldd	r31, Y+8	; 0x08
    3246:	89 81       	ldd	r24, Y+1	; 0x01
    3248:	9a 81       	ldd	r25, Y+2	; 0x02
    324a:	97 83       	std	Z+7, r25	; 0x07
    324c:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    324e:	ef 81       	ldd	r30, Y+7	; 0x07
    3250:	f8 85       	ldd	r31, Y+8	; 0x08
    3252:	81 89       	ldd	r24, Z+17	; 0x11
    3254:	88 23       	and	r24, r24
    3256:	49 f0       	breq	.+18     	; 0x326a <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3258:	8f 81       	ldd	r24, Y+7	; 0x07
    325a:	98 85       	ldd	r25, Y+8	; 0x08
    325c:	41 96       	adiw	r24, 0x11	; 17
    325e:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskRemoveFromEventList>
    3262:	88 23       	and	r24, r24
    3264:	11 f0       	breq	.+4      	; 0x326a <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3266:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    326a:	0f 90       	pop	r0
    326c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    326e:	81 e0       	ldi	r24, 0x01	; 1
    3270:	8e 87       	std	Y+14, r24	; 0x0e
    3272:	5c c0       	rjmp	.+184    	; 0x332c <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3274:	8b 85       	ldd	r24, Y+11	; 0x0b
    3276:	9c 85       	ldd	r25, Y+12	; 0x0c
    3278:	00 97       	sbiw	r24, 0x00	; 0
    327a:	21 f4       	brne	.+8      	; 0x3284 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    327c:	0f 90       	pop	r0
    327e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3280:	1e 86       	std	Y+14, r1	; 0x0e
    3282:	54 c0       	rjmp	.+168    	; 0x332c <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3284:	8b 81       	ldd	r24, Y+3	; 0x03
    3286:	88 23       	and	r24, r24
    3288:	31 f4       	brne	.+12     	; 0x3296 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    328a:	ce 01       	movw	r24, r28
    328c:	04 96       	adiw	r24, 0x04	; 4
    328e:	0e 94 ad 20 	call	0x415a	; 0x415a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3292:	81 e0       	ldi	r24, 0x01	; 1
    3294:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3296:	0f 90       	pop	r0
    3298:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    329a:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    329e:	0f b6       	in	r0, 0x3f	; 63
    32a0:	f8 94       	cli
    32a2:	0f 92       	push	r0
    32a4:	ef 81       	ldd	r30, Y+7	; 0x07
    32a6:	f8 85       	ldd	r31, Y+8	; 0x08
    32a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    32aa:	8f 3f       	cpi	r24, 0xFF	; 255
    32ac:	19 f4       	brne	.+6      	; 0x32b4 <xQueueGenericReceive+0xf4>
    32ae:	ef 81       	ldd	r30, Y+7	; 0x07
    32b0:	f8 85       	ldd	r31, Y+8	; 0x08
    32b2:	15 8e       	std	Z+29, r1	; 0x1d
    32b4:	ef 81       	ldd	r30, Y+7	; 0x07
    32b6:	f8 85       	ldd	r31, Y+8	; 0x08
    32b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    32ba:	8f 3f       	cpi	r24, 0xFF	; 255
    32bc:	19 f4       	brne	.+6      	; 0x32c4 <xQueueGenericReceive+0x104>
    32be:	ef 81       	ldd	r30, Y+7	; 0x07
    32c0:	f8 85       	ldd	r31, Y+8	; 0x08
    32c2:	16 8e       	std	Z+30, r1	; 0x1e
    32c4:	0f 90       	pop	r0
    32c6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    32c8:	ce 01       	movw	r24, r28
    32ca:	04 96       	adiw	r24, 0x04	; 4
    32cc:	9e 01       	movw	r18, r28
    32ce:	25 5f       	subi	r18, 0xF5	; 245
    32d0:	3f 4f       	sbci	r19, 0xFF	; 255
    32d2:	b9 01       	movw	r22, r18
    32d4:	0e 94 c6 20 	call	0x418c	; 0x418c <xTaskCheckForTimeOut>
    32d8:	88 23       	and	r24, r24
    32da:	09 f5       	brne	.+66     	; 0x331e <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    32dc:	8f 81       	ldd	r24, Y+7	; 0x07
    32de:	98 85       	ldd	r25, Y+8	; 0x08
    32e0:	0e 94 61 1b 	call	0x36c2	; 0x36c2 <prvIsQueueEmpty>
    32e4:	88 23       	and	r24, r24
    32e6:	a1 f0       	breq	.+40     	; 0x3310 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    32e8:	8f 81       	ldd	r24, Y+7	; 0x07
    32ea:	98 85       	ldd	r25, Y+8	; 0x08
    32ec:	41 96       	adiw	r24, 0x11	; 17
    32ee:	2b 85       	ldd	r18, Y+11	; 0x0b
    32f0:	3c 85       	ldd	r19, Y+12	; 0x0c
    32f2:	b9 01       	movw	r22, r18
    32f4:	0e 94 0f 20 	call	0x401e	; 0x401e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    32f8:	8f 81       	ldd	r24, Y+7	; 0x07
    32fa:	98 85       	ldd	r25, Y+8	; 0x08
    32fc:	0e 94 0d 1b 	call	0x361a	; 0x361a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3300:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>
    3304:	88 23       	and	r24, r24
    3306:	09 f0       	breq	.+2      	; 0x330a <xQueueGenericReceive+0x14a>
    3308:	6d cf       	rjmp	.-294    	; 0x31e4 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    330a:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
    330e:	6a cf       	rjmp	.-300    	; 0x31e4 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3310:	8f 81       	ldd	r24, Y+7	; 0x07
    3312:	98 85       	ldd	r25, Y+8	; 0x08
    3314:	0e 94 0d 1b 	call	0x361a	; 0x361a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3318:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>
    331c:	63 cf       	rjmp	.-314    	; 0x31e4 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    331e:	8f 81       	ldd	r24, Y+7	; 0x07
    3320:	98 85       	ldd	r25, Y+8	; 0x08
    3322:	0e 94 0d 1b 	call	0x361a	; 0x361a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3326:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    332a:	1e 86       	std	Y+14, r1	; 0x0e
    332c:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    332e:	2e 96       	adiw	r28, 0x0e	; 14
    3330:	0f b6       	in	r0, 0x3f	; 63
    3332:	f8 94       	cli
    3334:	de bf       	out	0x3e, r29	; 62
    3336:	0f be       	out	0x3f, r0	; 63
    3338:	cd bf       	out	0x3d, r28	; 61
    333a:	cf 91       	pop	r28
    333c:	df 91       	pop	r29
    333e:	08 95       	ret

00003340 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3340:	df 93       	push	r29
    3342:	cf 93       	push	r28
    3344:	cd b7       	in	r28, 0x3d	; 61
    3346:	de b7       	in	r29, 0x3e	; 62
    3348:	28 97       	sbiw	r28, 0x08	; 8
    334a:	0f b6       	in	r0, 0x3f	; 63
    334c:	f8 94       	cli
    334e:	de bf       	out	0x3e, r29	; 62
    3350:	0f be       	out	0x3f, r0	; 63
    3352:	cd bf       	out	0x3d, r28	; 61
    3354:	9c 83       	std	Y+4, r25	; 0x04
    3356:	8b 83       	std	Y+3, r24	; 0x03
    3358:	7e 83       	std	Y+6, r23	; 0x06
    335a:	6d 83       	std	Y+5, r22	; 0x05
    335c:	58 87       	std	Y+8, r21	; 0x08
    335e:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3360:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3362:	eb 81       	ldd	r30, Y+3	; 0x03
    3364:	fc 81       	ldd	r31, Y+4	; 0x04
    3366:	82 8d       	ldd	r24, Z+26	; 0x1a
    3368:	88 23       	and	r24, r24
    336a:	71 f1       	breq	.+92     	; 0x33c8 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    336c:	8b 81       	ldd	r24, Y+3	; 0x03
    336e:	9c 81       	ldd	r25, Y+4	; 0x04
    3370:	2d 81       	ldd	r18, Y+5	; 0x05
    3372:	3e 81       	ldd	r19, Y+6	; 0x06
    3374:	b9 01       	movw	r22, r18
    3376:	0e 94 c5 1a 	call	0x358a	; 0x358a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    337a:	eb 81       	ldd	r30, Y+3	; 0x03
    337c:	fc 81       	ldd	r31, Y+4	; 0x04
    337e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3380:	81 50       	subi	r24, 0x01	; 1
    3382:	eb 81       	ldd	r30, Y+3	; 0x03
    3384:	fc 81       	ldd	r31, Y+4	; 0x04
    3386:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3388:	eb 81       	ldd	r30, Y+3	; 0x03
    338a:	fc 81       	ldd	r31, Y+4	; 0x04
    338c:	85 8d       	ldd	r24, Z+29	; 0x1d
    338e:	8f 3f       	cpi	r24, 0xFF	; 255
    3390:	89 f4       	brne	.+34     	; 0x33b4 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3392:	eb 81       	ldd	r30, Y+3	; 0x03
    3394:	fc 81       	ldd	r31, Y+4	; 0x04
    3396:	80 85       	ldd	r24, Z+8	; 0x08
    3398:	88 23       	and	r24, r24
    339a:	99 f0       	breq	.+38     	; 0x33c2 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    339c:	8b 81       	ldd	r24, Y+3	; 0x03
    339e:	9c 81       	ldd	r25, Y+4	; 0x04
    33a0:	08 96       	adiw	r24, 0x08	; 8
    33a2:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskRemoveFromEventList>
    33a6:	88 23       	and	r24, r24
    33a8:	61 f0       	breq	.+24     	; 0x33c2 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    33aa:	ef 81       	ldd	r30, Y+7	; 0x07
    33ac:	f8 85       	ldd	r31, Y+8	; 0x08
    33ae:	81 e0       	ldi	r24, 0x01	; 1
    33b0:	80 83       	st	Z, r24
    33b2:	07 c0       	rjmp	.+14     	; 0x33c2 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    33b4:	eb 81       	ldd	r30, Y+3	; 0x03
    33b6:	fc 81       	ldd	r31, Y+4	; 0x04
    33b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    33ba:	8f 5f       	subi	r24, 0xFF	; 255
    33bc:	eb 81       	ldd	r30, Y+3	; 0x03
    33be:	fc 81       	ldd	r31, Y+4	; 0x04
    33c0:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    33c2:	81 e0       	ldi	r24, 0x01	; 1
    33c4:	8a 83       	std	Y+2, r24	; 0x02
    33c6:	01 c0       	rjmp	.+2      	; 0x33ca <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    33c8:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    33ca:	8a 81       	ldd	r24, Y+2	; 0x02
}
    33cc:	28 96       	adiw	r28, 0x08	; 8
    33ce:	0f b6       	in	r0, 0x3f	; 63
    33d0:	f8 94       	cli
    33d2:	de bf       	out	0x3e, r29	; 62
    33d4:	0f be       	out	0x3f, r0	; 63
    33d6:	cd bf       	out	0x3d, r28	; 61
    33d8:	cf 91       	pop	r28
    33da:	df 91       	pop	r29
    33dc:	08 95       	ret

000033de <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    33de:	df 93       	push	r29
    33e0:	cf 93       	push	r28
    33e2:	00 d0       	rcall	.+0      	; 0x33e4 <uxQueueMessagesWaiting+0x6>
    33e4:	0f 92       	push	r0
    33e6:	cd b7       	in	r28, 0x3d	; 61
    33e8:	de b7       	in	r29, 0x3e	; 62
    33ea:	9b 83       	std	Y+3, r25	; 0x03
    33ec:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    33ee:	0f b6       	in	r0, 0x3f	; 63
    33f0:	f8 94       	cli
    33f2:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    33f4:	ea 81       	ldd	r30, Y+2	; 0x02
    33f6:	fb 81       	ldd	r31, Y+3	; 0x03
    33f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    33fa:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    33fc:	0f 90       	pop	r0
    33fe:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3400:	89 81       	ldd	r24, Y+1	; 0x01
}
    3402:	0f 90       	pop	r0
    3404:	0f 90       	pop	r0
    3406:	0f 90       	pop	r0
    3408:	cf 91       	pop	r28
    340a:	df 91       	pop	r29
    340c:	08 95       	ret

0000340e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    340e:	df 93       	push	r29
    3410:	cf 93       	push	r28
    3412:	00 d0       	rcall	.+0      	; 0x3414 <uxQueueMessagesWaitingFromISR+0x6>
    3414:	0f 92       	push	r0
    3416:	cd b7       	in	r28, 0x3d	; 61
    3418:	de b7       	in	r29, 0x3e	; 62
    341a:	9b 83       	std	Y+3, r25	; 0x03
    341c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    341e:	ea 81       	ldd	r30, Y+2	; 0x02
    3420:	fb 81       	ldd	r31, Y+3	; 0x03
    3422:	82 8d       	ldd	r24, Z+26	; 0x1a
    3424:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3426:	89 81       	ldd	r24, Y+1	; 0x01
}
    3428:	0f 90       	pop	r0
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	cf 91       	pop	r28
    3430:	df 91       	pop	r29
    3432:	08 95       	ret

00003434 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3434:	df 93       	push	r29
    3436:	cf 93       	push	r28
    3438:	00 d0       	rcall	.+0      	; 0x343a <vQueueDelete+0x6>
    343a:	cd b7       	in	r28, 0x3d	; 61
    343c:	de b7       	in	r29, 0x3e	; 62
    343e:	9a 83       	std	Y+2, r25	; 0x02
    3440:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3442:	e9 81       	ldd	r30, Y+1	; 0x01
    3444:	fa 81       	ldd	r31, Y+2	; 0x02
    3446:	80 81       	ld	r24, Z
    3448:	91 81       	ldd	r25, Z+1	; 0x01
    344a:	0e 94 9e 12 	call	0x253c	; 0x253c <vPortFree>
	vPortFree( pxQueue );
    344e:	89 81       	ldd	r24, Y+1	; 0x01
    3450:	9a 81       	ldd	r25, Y+2	; 0x02
    3452:	0e 94 9e 12 	call	0x253c	; 0x253c <vPortFree>
}
    3456:	0f 90       	pop	r0
    3458:	0f 90       	pop	r0
    345a:	cf 91       	pop	r28
    345c:	df 91       	pop	r29
    345e:	08 95       	ret

00003460 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3460:	df 93       	push	r29
    3462:	cf 93       	push	r28
    3464:	00 d0       	rcall	.+0      	; 0x3466 <prvCopyDataToQueue+0x6>
    3466:	00 d0       	rcall	.+0      	; 0x3468 <prvCopyDataToQueue+0x8>
    3468:	0f 92       	push	r0
    346a:	cd b7       	in	r28, 0x3d	; 61
    346c:	de b7       	in	r29, 0x3e	; 62
    346e:	9a 83       	std	Y+2, r25	; 0x02
    3470:	89 83       	std	Y+1, r24	; 0x01
    3472:	7c 83       	std	Y+4, r23	; 0x04
    3474:	6b 83       	std	Y+3, r22	; 0x03
    3476:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3478:	e9 81       	ldd	r30, Y+1	; 0x01
    347a:	fa 81       	ldd	r31, Y+2	; 0x02
    347c:	84 8d       	ldd	r24, Z+28	; 0x1c
    347e:	88 23       	and	r24, r24
    3480:	09 f4       	brne	.+2      	; 0x3484 <prvCopyDataToQueue+0x24>
    3482:	74 c0       	rjmp	.+232    	; 0x356c <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3484:	8d 81       	ldd	r24, Y+5	; 0x05
    3486:	88 23       	and	r24, r24
    3488:	99 f5       	brne	.+102    	; 0x34f0 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    348a:	e9 81       	ldd	r30, Y+1	; 0x01
    348c:	fa 81       	ldd	r31, Y+2	; 0x02
    348e:	64 81       	ldd	r22, Z+4	; 0x04
    3490:	75 81       	ldd	r23, Z+5	; 0x05
    3492:	e9 81       	ldd	r30, Y+1	; 0x01
    3494:	fa 81       	ldd	r31, Y+2	; 0x02
    3496:	84 8d       	ldd	r24, Z+28	; 0x1c
    3498:	48 2f       	mov	r20, r24
    349a:	50 e0       	ldi	r21, 0x00	; 0
    349c:	2b 81       	ldd	r18, Y+3	; 0x03
    349e:	3c 81       	ldd	r19, Y+4	; 0x04
    34a0:	cb 01       	movw	r24, r22
    34a2:	b9 01       	movw	r22, r18
    34a4:	0e 94 2c 23 	call	0x4658	; 0x4658 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    34a8:	e9 81       	ldd	r30, Y+1	; 0x01
    34aa:	fa 81       	ldd	r31, Y+2	; 0x02
    34ac:	24 81       	ldd	r18, Z+4	; 0x04
    34ae:	35 81       	ldd	r19, Z+5	; 0x05
    34b0:	e9 81       	ldd	r30, Y+1	; 0x01
    34b2:	fa 81       	ldd	r31, Y+2	; 0x02
    34b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    34b6:	88 2f       	mov	r24, r24
    34b8:	90 e0       	ldi	r25, 0x00	; 0
    34ba:	82 0f       	add	r24, r18
    34bc:	93 1f       	adc	r25, r19
    34be:	e9 81       	ldd	r30, Y+1	; 0x01
    34c0:	fa 81       	ldd	r31, Y+2	; 0x02
    34c2:	95 83       	std	Z+5, r25	; 0x05
    34c4:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    34c6:	e9 81       	ldd	r30, Y+1	; 0x01
    34c8:	fa 81       	ldd	r31, Y+2	; 0x02
    34ca:	24 81       	ldd	r18, Z+4	; 0x04
    34cc:	35 81       	ldd	r19, Z+5	; 0x05
    34ce:	e9 81       	ldd	r30, Y+1	; 0x01
    34d0:	fa 81       	ldd	r31, Y+2	; 0x02
    34d2:	82 81       	ldd	r24, Z+2	; 0x02
    34d4:	93 81       	ldd	r25, Z+3	; 0x03
    34d6:	28 17       	cp	r18, r24
    34d8:	39 07       	cpc	r19, r25
    34da:	08 f4       	brcc	.+2      	; 0x34de <prvCopyDataToQueue+0x7e>
    34dc:	47 c0       	rjmp	.+142    	; 0x356c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    34de:	e9 81       	ldd	r30, Y+1	; 0x01
    34e0:	fa 81       	ldd	r31, Y+2	; 0x02
    34e2:	80 81       	ld	r24, Z
    34e4:	91 81       	ldd	r25, Z+1	; 0x01
    34e6:	e9 81       	ldd	r30, Y+1	; 0x01
    34e8:	fa 81       	ldd	r31, Y+2	; 0x02
    34ea:	95 83       	std	Z+5, r25	; 0x05
    34ec:	84 83       	std	Z+4, r24	; 0x04
    34ee:	3e c0       	rjmp	.+124    	; 0x356c <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    34f0:	e9 81       	ldd	r30, Y+1	; 0x01
    34f2:	fa 81       	ldd	r31, Y+2	; 0x02
    34f4:	66 81       	ldd	r22, Z+6	; 0x06
    34f6:	77 81       	ldd	r23, Z+7	; 0x07
    34f8:	e9 81       	ldd	r30, Y+1	; 0x01
    34fa:	fa 81       	ldd	r31, Y+2	; 0x02
    34fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    34fe:	48 2f       	mov	r20, r24
    3500:	50 e0       	ldi	r21, 0x00	; 0
    3502:	2b 81       	ldd	r18, Y+3	; 0x03
    3504:	3c 81       	ldd	r19, Y+4	; 0x04
    3506:	cb 01       	movw	r24, r22
    3508:	b9 01       	movw	r22, r18
    350a:	0e 94 2c 23 	call	0x4658	; 0x4658 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    350e:	e9 81       	ldd	r30, Y+1	; 0x01
    3510:	fa 81       	ldd	r31, Y+2	; 0x02
    3512:	26 81       	ldd	r18, Z+6	; 0x06
    3514:	37 81       	ldd	r19, Z+7	; 0x07
    3516:	e9 81       	ldd	r30, Y+1	; 0x01
    3518:	fa 81       	ldd	r31, Y+2	; 0x02
    351a:	84 8d       	ldd	r24, Z+28	; 0x1c
    351c:	88 2f       	mov	r24, r24
    351e:	90 e0       	ldi	r25, 0x00	; 0
    3520:	90 95       	com	r25
    3522:	81 95       	neg	r24
    3524:	9f 4f       	sbci	r25, 0xFF	; 255
    3526:	82 0f       	add	r24, r18
    3528:	93 1f       	adc	r25, r19
    352a:	e9 81       	ldd	r30, Y+1	; 0x01
    352c:	fa 81       	ldd	r31, Y+2	; 0x02
    352e:	97 83       	std	Z+7, r25	; 0x07
    3530:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    3532:	e9 81       	ldd	r30, Y+1	; 0x01
    3534:	fa 81       	ldd	r31, Y+2	; 0x02
    3536:	26 81       	ldd	r18, Z+6	; 0x06
    3538:	37 81       	ldd	r19, Z+7	; 0x07
    353a:	e9 81       	ldd	r30, Y+1	; 0x01
    353c:	fa 81       	ldd	r31, Y+2	; 0x02
    353e:	80 81       	ld	r24, Z
    3540:	91 81       	ldd	r25, Z+1	; 0x01
    3542:	28 17       	cp	r18, r24
    3544:	39 07       	cpc	r19, r25
    3546:	90 f4       	brcc	.+36     	; 0x356c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3548:	e9 81       	ldd	r30, Y+1	; 0x01
    354a:	fa 81       	ldd	r31, Y+2	; 0x02
    354c:	22 81       	ldd	r18, Z+2	; 0x02
    354e:	33 81       	ldd	r19, Z+3	; 0x03
    3550:	e9 81       	ldd	r30, Y+1	; 0x01
    3552:	fa 81       	ldd	r31, Y+2	; 0x02
    3554:	84 8d       	ldd	r24, Z+28	; 0x1c
    3556:	88 2f       	mov	r24, r24
    3558:	90 e0       	ldi	r25, 0x00	; 0
    355a:	90 95       	com	r25
    355c:	81 95       	neg	r24
    355e:	9f 4f       	sbci	r25, 0xFF	; 255
    3560:	82 0f       	add	r24, r18
    3562:	93 1f       	adc	r25, r19
    3564:	e9 81       	ldd	r30, Y+1	; 0x01
    3566:	fa 81       	ldd	r31, Y+2	; 0x02
    3568:	97 83       	std	Z+7, r25	; 0x07
    356a:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    356c:	e9 81       	ldd	r30, Y+1	; 0x01
    356e:	fa 81       	ldd	r31, Y+2	; 0x02
    3570:	82 8d       	ldd	r24, Z+26	; 0x1a
    3572:	8f 5f       	subi	r24, 0xFF	; 255
    3574:	e9 81       	ldd	r30, Y+1	; 0x01
    3576:	fa 81       	ldd	r31, Y+2	; 0x02
    3578:	82 8f       	std	Z+26, r24	; 0x1a
}
    357a:	0f 90       	pop	r0
    357c:	0f 90       	pop	r0
    357e:	0f 90       	pop	r0
    3580:	0f 90       	pop	r0
    3582:	0f 90       	pop	r0
    3584:	cf 91       	pop	r28
    3586:	df 91       	pop	r29
    3588:	08 95       	ret

0000358a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    358a:	df 93       	push	r29
    358c:	cf 93       	push	r28
    358e:	00 d0       	rcall	.+0      	; 0x3590 <prvCopyDataFromQueue+0x6>
    3590:	00 d0       	rcall	.+0      	; 0x3592 <prvCopyDataFromQueue+0x8>
    3592:	cd b7       	in	r28, 0x3d	; 61
    3594:	de b7       	in	r29, 0x3e	; 62
    3596:	9a 83       	std	Y+2, r25	; 0x02
    3598:	89 83       	std	Y+1, r24	; 0x01
    359a:	7c 83       	std	Y+4, r23	; 0x04
    359c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    359e:	e9 81       	ldd	r30, Y+1	; 0x01
    35a0:	fa 81       	ldd	r31, Y+2	; 0x02
    35a2:	80 81       	ld	r24, Z
    35a4:	91 81       	ldd	r25, Z+1	; 0x01
    35a6:	00 97       	sbiw	r24, 0x00	; 0
    35a8:	89 f1       	breq	.+98     	; 0x360c <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    35aa:	e9 81       	ldd	r30, Y+1	; 0x01
    35ac:	fa 81       	ldd	r31, Y+2	; 0x02
    35ae:	26 81       	ldd	r18, Z+6	; 0x06
    35b0:	37 81       	ldd	r19, Z+7	; 0x07
    35b2:	e9 81       	ldd	r30, Y+1	; 0x01
    35b4:	fa 81       	ldd	r31, Y+2	; 0x02
    35b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    35b8:	88 2f       	mov	r24, r24
    35ba:	90 e0       	ldi	r25, 0x00	; 0
    35bc:	82 0f       	add	r24, r18
    35be:	93 1f       	adc	r25, r19
    35c0:	e9 81       	ldd	r30, Y+1	; 0x01
    35c2:	fa 81       	ldd	r31, Y+2	; 0x02
    35c4:	97 83       	std	Z+7, r25	; 0x07
    35c6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    35c8:	e9 81       	ldd	r30, Y+1	; 0x01
    35ca:	fa 81       	ldd	r31, Y+2	; 0x02
    35cc:	26 81       	ldd	r18, Z+6	; 0x06
    35ce:	37 81       	ldd	r19, Z+7	; 0x07
    35d0:	e9 81       	ldd	r30, Y+1	; 0x01
    35d2:	fa 81       	ldd	r31, Y+2	; 0x02
    35d4:	82 81       	ldd	r24, Z+2	; 0x02
    35d6:	93 81       	ldd	r25, Z+3	; 0x03
    35d8:	28 17       	cp	r18, r24
    35da:	39 07       	cpc	r19, r25
    35dc:	40 f0       	brcs	.+16     	; 0x35ee <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    35de:	e9 81       	ldd	r30, Y+1	; 0x01
    35e0:	fa 81       	ldd	r31, Y+2	; 0x02
    35e2:	80 81       	ld	r24, Z
    35e4:	91 81       	ldd	r25, Z+1	; 0x01
    35e6:	e9 81       	ldd	r30, Y+1	; 0x01
    35e8:	fa 81       	ldd	r31, Y+2	; 0x02
    35ea:	97 83       	std	Z+7, r25	; 0x07
    35ec:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    35ee:	e9 81       	ldd	r30, Y+1	; 0x01
    35f0:	fa 81       	ldd	r31, Y+2	; 0x02
    35f2:	46 81       	ldd	r20, Z+6	; 0x06
    35f4:	57 81       	ldd	r21, Z+7	; 0x07
    35f6:	e9 81       	ldd	r30, Y+1	; 0x01
    35f8:	fa 81       	ldd	r31, Y+2	; 0x02
    35fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    35fc:	28 2f       	mov	r18, r24
    35fe:	30 e0       	ldi	r19, 0x00	; 0
    3600:	8b 81       	ldd	r24, Y+3	; 0x03
    3602:	9c 81       	ldd	r25, Y+4	; 0x04
    3604:	ba 01       	movw	r22, r20
    3606:	a9 01       	movw	r20, r18
    3608:	0e 94 2c 23 	call	0x4658	; 0x4658 <memcpy>
	}
}
    360c:	0f 90       	pop	r0
    360e:	0f 90       	pop	r0
    3610:	0f 90       	pop	r0
    3612:	0f 90       	pop	r0
    3614:	cf 91       	pop	r28
    3616:	df 91       	pop	r29
    3618:	08 95       	ret

0000361a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    361a:	df 93       	push	r29
    361c:	cf 93       	push	r28
    361e:	00 d0       	rcall	.+0      	; 0x3620 <prvUnlockQueue+0x6>
    3620:	cd b7       	in	r28, 0x3d	; 61
    3622:	de b7       	in	r29, 0x3e	; 62
    3624:	9a 83       	std	Y+2, r25	; 0x02
    3626:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3628:	0f b6       	in	r0, 0x3f	; 63
    362a:	f8 94       	cli
    362c:	0f 92       	push	r0
    362e:	15 c0       	rjmp	.+42     	; 0x365a <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3630:	e9 81       	ldd	r30, Y+1	; 0x01
    3632:	fa 81       	ldd	r31, Y+2	; 0x02
    3634:	81 89       	ldd	r24, Z+17	; 0x11
    3636:	88 23       	and	r24, r24
    3638:	a9 f0       	breq	.+42     	; 0x3664 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    363a:	89 81       	ldd	r24, Y+1	; 0x01
    363c:	9a 81       	ldd	r25, Y+2	; 0x02
    363e:	41 96       	adiw	r24, 0x11	; 17
    3640:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskRemoveFromEventList>
    3644:	88 23       	and	r24, r24
    3646:	11 f0       	breq	.+4      	; 0x364c <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    3648:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    364c:	e9 81       	ldd	r30, Y+1	; 0x01
    364e:	fa 81       	ldd	r31, Y+2	; 0x02
    3650:	86 8d       	ldd	r24, Z+30	; 0x1e
    3652:	81 50       	subi	r24, 0x01	; 1
    3654:	e9 81       	ldd	r30, Y+1	; 0x01
    3656:	fa 81       	ldd	r31, Y+2	; 0x02
    3658:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    365a:	e9 81       	ldd	r30, Y+1	; 0x01
    365c:	fa 81       	ldd	r31, Y+2	; 0x02
    365e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3660:	18 16       	cp	r1, r24
    3662:	34 f3       	brlt	.-52     	; 0x3630 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3664:	e9 81       	ldd	r30, Y+1	; 0x01
    3666:	fa 81       	ldd	r31, Y+2	; 0x02
    3668:	8f ef       	ldi	r24, 0xFF	; 255
    366a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    366c:	0f 90       	pop	r0
    366e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3670:	0f b6       	in	r0, 0x3f	; 63
    3672:	f8 94       	cli
    3674:	0f 92       	push	r0
    3676:	15 c0       	rjmp	.+42     	; 0x36a2 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3678:	e9 81       	ldd	r30, Y+1	; 0x01
    367a:	fa 81       	ldd	r31, Y+2	; 0x02
    367c:	80 85       	ldd	r24, Z+8	; 0x08
    367e:	88 23       	and	r24, r24
    3680:	a9 f0       	breq	.+42     	; 0x36ac <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3682:	89 81       	ldd	r24, Y+1	; 0x01
    3684:	9a 81       	ldd	r25, Y+2	; 0x02
    3686:	08 96       	adiw	r24, 0x08	; 8
    3688:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskRemoveFromEventList>
    368c:	88 23       	and	r24, r24
    368e:	11 f0       	breq	.+4      	; 0x3694 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3690:	0e 94 23 21 	call	0x4246	; 0x4246 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    3694:	e9 81       	ldd	r30, Y+1	; 0x01
    3696:	fa 81       	ldd	r31, Y+2	; 0x02
    3698:	85 8d       	ldd	r24, Z+29	; 0x1d
    369a:	81 50       	subi	r24, 0x01	; 1
    369c:	e9 81       	ldd	r30, Y+1	; 0x01
    369e:	fa 81       	ldd	r31, Y+2	; 0x02
    36a0:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    36a2:	e9 81       	ldd	r30, Y+1	; 0x01
    36a4:	fa 81       	ldd	r31, Y+2	; 0x02
    36a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    36a8:	18 16       	cp	r1, r24
    36aa:	34 f3       	brlt	.-52     	; 0x3678 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    36ac:	e9 81       	ldd	r30, Y+1	; 0x01
    36ae:	fa 81       	ldd	r31, Y+2	; 0x02
    36b0:	8f ef       	ldi	r24, 0xFF	; 255
    36b2:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    36b4:	0f 90       	pop	r0
    36b6:	0f be       	out	0x3f, r0	; 63
}
    36b8:	0f 90       	pop	r0
    36ba:	0f 90       	pop	r0
    36bc:	cf 91       	pop	r28
    36be:	df 91       	pop	r29
    36c0:	08 95       	ret

000036c2 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    36c2:	df 93       	push	r29
    36c4:	cf 93       	push	r28
    36c6:	00 d0       	rcall	.+0      	; 0x36c8 <prvIsQueueEmpty+0x6>
    36c8:	0f 92       	push	r0
    36ca:	cd b7       	in	r28, 0x3d	; 61
    36cc:	de b7       	in	r29, 0x3e	; 62
    36ce:	9b 83       	std	Y+3, r25	; 0x03
    36d0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    36d2:	0f b6       	in	r0, 0x3f	; 63
    36d4:	f8 94       	cli
    36d6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    36d8:	ea 81       	ldd	r30, Y+2	; 0x02
    36da:	fb 81       	ldd	r31, Y+3	; 0x03
    36dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    36de:	19 82       	std	Y+1, r1	; 0x01
    36e0:	88 23       	and	r24, r24
    36e2:	11 f4       	brne	.+4      	; 0x36e8 <prvIsQueueEmpty+0x26>
    36e4:	81 e0       	ldi	r24, 0x01	; 1
    36e6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    36e8:	0f 90       	pop	r0
    36ea:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    36ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    36ee:	0f 90       	pop	r0
    36f0:	0f 90       	pop	r0
    36f2:	0f 90       	pop	r0
    36f4:	cf 91       	pop	r28
    36f6:	df 91       	pop	r29
    36f8:	08 95       	ret

000036fa <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    36fa:	df 93       	push	r29
    36fc:	cf 93       	push	r28
    36fe:	00 d0       	rcall	.+0      	; 0x3700 <xQueueIsQueueEmptyFromISR+0x6>
    3700:	0f 92       	push	r0
    3702:	cd b7       	in	r28, 0x3d	; 61
    3704:	de b7       	in	r29, 0x3e	; 62
    3706:	9b 83       	std	Y+3, r25	; 0x03
    3708:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    370a:	ea 81       	ldd	r30, Y+2	; 0x02
    370c:	fb 81       	ldd	r31, Y+3	; 0x03
    370e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3710:	19 82       	std	Y+1, r1	; 0x01
    3712:	88 23       	and	r24, r24
    3714:	11 f4       	brne	.+4      	; 0x371a <xQueueIsQueueEmptyFromISR+0x20>
    3716:	81 e0       	ldi	r24, 0x01	; 1
    3718:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    371a:	89 81       	ldd	r24, Y+1	; 0x01
}
    371c:	0f 90       	pop	r0
    371e:	0f 90       	pop	r0
    3720:	0f 90       	pop	r0
    3722:	cf 91       	pop	r28
    3724:	df 91       	pop	r29
    3726:	08 95       	ret

00003728 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    3728:	df 93       	push	r29
    372a:	cf 93       	push	r28
    372c:	00 d0       	rcall	.+0      	; 0x372e <prvIsQueueFull+0x6>
    372e:	0f 92       	push	r0
    3730:	cd b7       	in	r28, 0x3d	; 61
    3732:	de b7       	in	r29, 0x3e	; 62
    3734:	9b 83       	std	Y+3, r25	; 0x03
    3736:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3738:	0f b6       	in	r0, 0x3f	; 63
    373a:	f8 94       	cli
    373c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    373e:	ea 81       	ldd	r30, Y+2	; 0x02
    3740:	fb 81       	ldd	r31, Y+3	; 0x03
    3742:	92 8d       	ldd	r25, Z+26	; 0x1a
    3744:	ea 81       	ldd	r30, Y+2	; 0x02
    3746:	fb 81       	ldd	r31, Y+3	; 0x03
    3748:	83 8d       	ldd	r24, Z+27	; 0x1b
    374a:	19 82       	std	Y+1, r1	; 0x01
    374c:	98 17       	cp	r25, r24
    374e:	11 f4       	brne	.+4      	; 0x3754 <prvIsQueueFull+0x2c>
    3750:	81 e0       	ldi	r24, 0x01	; 1
    3752:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3754:	0f 90       	pop	r0
    3756:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3758:	89 81       	ldd	r24, Y+1	; 0x01
}
    375a:	0f 90       	pop	r0
    375c:	0f 90       	pop	r0
    375e:	0f 90       	pop	r0
    3760:	cf 91       	pop	r28
    3762:	df 91       	pop	r29
    3764:	08 95       	ret

00003766 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    3766:	df 93       	push	r29
    3768:	cf 93       	push	r28
    376a:	00 d0       	rcall	.+0      	; 0x376c <xQueueIsQueueFullFromISR+0x6>
    376c:	0f 92       	push	r0
    376e:	cd b7       	in	r28, 0x3d	; 61
    3770:	de b7       	in	r29, 0x3e	; 62
    3772:	9b 83       	std	Y+3, r25	; 0x03
    3774:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3776:	ea 81       	ldd	r30, Y+2	; 0x02
    3778:	fb 81       	ldd	r31, Y+3	; 0x03
    377a:	92 8d       	ldd	r25, Z+26	; 0x1a
    377c:	ea 81       	ldd	r30, Y+2	; 0x02
    377e:	fb 81       	ldd	r31, Y+3	; 0x03
    3780:	83 8d       	ldd	r24, Z+27	; 0x1b
    3782:	19 82       	std	Y+1, r1	; 0x01
    3784:	98 17       	cp	r25, r24
    3786:	11 f4       	brne	.+4      	; 0x378c <xQueueIsQueueFullFromISR+0x26>
    3788:	81 e0       	ldi	r24, 0x01	; 1
    378a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    378c:	89 81       	ldd	r24, Y+1	; 0x01
}
    378e:	0f 90       	pop	r0
    3790:	0f 90       	pop	r0
    3792:	0f 90       	pop	r0
    3794:	cf 91       	pop	r28
    3796:	df 91       	pop	r29
    3798:	08 95       	ret

0000379a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    379a:	af 92       	push	r10
    379c:	bf 92       	push	r11
    379e:	cf 92       	push	r12
    37a0:	df 92       	push	r13
    37a2:	ef 92       	push	r14
    37a4:	ff 92       	push	r15
    37a6:	0f 93       	push	r16
    37a8:	1f 93       	push	r17
    37aa:	df 93       	push	r29
    37ac:	cf 93       	push	r28
    37ae:	cd b7       	in	r28, 0x3d	; 61
    37b0:	de b7       	in	r29, 0x3e	; 62
    37b2:	64 97       	sbiw	r28, 0x14	; 20
    37b4:	0f b6       	in	r0, 0x3f	; 63
    37b6:	f8 94       	cli
    37b8:	de bf       	out	0x3e, r29	; 62
    37ba:	0f be       	out	0x3f, r0	; 63
    37bc:	cd bf       	out	0x3d, r28	; 61
    37be:	9f 83       	std	Y+7, r25	; 0x07
    37c0:	8e 83       	std	Y+6, r24	; 0x06
    37c2:	79 87       	std	Y+9, r23	; 0x09
    37c4:	68 87       	std	Y+8, r22	; 0x08
    37c6:	5b 87       	std	Y+11, r21	; 0x0b
    37c8:	4a 87       	std	Y+10, r20	; 0x0a
    37ca:	3d 87       	std	Y+13, r19	; 0x0d
    37cc:	2c 87       	std	Y+12, r18	; 0x0c
    37ce:	0e 87       	std	Y+14, r16	; 0x0e
    37d0:	f8 8a       	std	Y+16, r15	; 0x10
    37d2:	ef 86       	std	Y+15, r14	; 0x0f
    37d4:	da 8a       	std	Y+18, r13	; 0x12
    37d6:	c9 8a       	std	Y+17, r12	; 0x11
    37d8:	bc 8a       	std	Y+20, r11	; 0x14
    37da:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    37dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    37de:	9b 85       	ldd	r25, Y+11	; 0x0b
    37e0:	29 89       	ldd	r18, Y+17	; 0x11
    37e2:	3a 89       	ldd	r19, Y+18	; 0x12
    37e4:	b9 01       	movw	r22, r18
    37e6:	0e 94 52 22 	call	0x44a4	; 0x44a4 <prvAllocateTCBAndStack>
    37ea:	9c 83       	std	Y+4, r25	; 0x04
    37ec:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    37ee:	8b 81       	ldd	r24, Y+3	; 0x03
    37f0:	9c 81       	ldd	r25, Y+4	; 0x04
    37f2:	00 97       	sbiw	r24, 0x00	; 0
    37f4:	09 f4       	brne	.+2      	; 0x37f8 <xTaskGenericCreate+0x5e>
    37f6:	99 c0       	rjmp	.+306    	; 0x392a <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    37f8:	eb 81       	ldd	r30, Y+3	; 0x03
    37fa:	fc 81       	ldd	r31, Y+4	; 0x04
    37fc:	27 89       	ldd	r18, Z+23	; 0x17
    37fe:	30 8d       	ldd	r19, Z+24	; 0x18
    3800:	8a 85       	ldd	r24, Y+10	; 0x0a
    3802:	9b 85       	ldd	r25, Y+11	; 0x0b
    3804:	01 97       	sbiw	r24, 0x01	; 1
    3806:	82 0f       	add	r24, r18
    3808:	93 1f       	adc	r25, r19
    380a:	9a 83       	std	Y+2, r25	; 0x02
    380c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    380e:	8b 81       	ldd	r24, Y+3	; 0x03
    3810:	9c 81       	ldd	r25, Y+4	; 0x04
    3812:	28 85       	ldd	r18, Y+8	; 0x08
    3814:	39 85       	ldd	r19, Y+9	; 0x09
    3816:	eb 89       	ldd	r30, Y+19	; 0x13
    3818:	fc 89       	ldd	r31, Y+20	; 0x14
    381a:	aa 85       	ldd	r26, Y+10	; 0x0a
    381c:	bb 85       	ldd	r27, Y+11	; 0x0b
    381e:	b9 01       	movw	r22, r18
    3820:	4e 85       	ldd	r20, Y+14	; 0x0e
    3822:	9f 01       	movw	r18, r30
    3824:	8d 01       	movw	r16, r26
    3826:	0e 94 37 21 	call	0x426e	; 0x426e <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    382a:	89 81       	ldd	r24, Y+1	; 0x01
    382c:	9a 81       	ldd	r25, Y+2	; 0x02
    382e:	2e 81       	ldd	r18, Y+6	; 0x06
    3830:	3f 81       	ldd	r19, Y+7	; 0x07
    3832:	4c 85       	ldd	r20, Y+12	; 0x0c
    3834:	5d 85       	ldd	r21, Y+13	; 0x0d
    3836:	b9 01       	movw	r22, r18
    3838:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <pxPortInitialiseStack>
    383c:	eb 81       	ldd	r30, Y+3	; 0x03
    383e:	fc 81       	ldd	r31, Y+4	; 0x04
    3840:	91 83       	std	Z+1, r25	; 0x01
    3842:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    3844:	8f 85       	ldd	r24, Y+15	; 0x0f
    3846:	98 89       	ldd	r25, Y+16	; 0x10
    3848:	00 97       	sbiw	r24, 0x00	; 0
    384a:	31 f0       	breq	.+12     	; 0x3858 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    384c:	ef 85       	ldd	r30, Y+15	; 0x0f
    384e:	f8 89       	ldd	r31, Y+16	; 0x10
    3850:	8b 81       	ldd	r24, Y+3	; 0x03
    3852:	9c 81       	ldd	r25, Y+4	; 0x04
    3854:	91 83       	std	Z+1, r25	; 0x01
    3856:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    3858:	0f b6       	in	r0, 0x3f	; 63
    385a:	f8 94       	cli
    385c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    385e:	80 91 71 05 	lds	r24, 0x0571
    3862:	8f 5f       	subi	r24, 0xFF	; 255
    3864:	80 93 71 05 	sts	0x0571, r24
			if( pxCurrentTCB == NULL )
    3868:	80 91 6e 05 	lds	r24, 0x056E
    386c:	90 91 6f 05 	lds	r25, 0x056F
    3870:	00 97       	sbiw	r24, 0x00	; 0
    3872:	69 f4       	brne	.+26     	; 0x388e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3874:	8b 81       	ldd	r24, Y+3	; 0x03
    3876:	9c 81       	ldd	r25, Y+4	; 0x04
    3878:	90 93 6f 05 	sts	0x056F, r25
    387c:	80 93 6e 05 	sts	0x056E, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    3880:	80 91 71 05 	lds	r24, 0x0571
    3884:	81 30       	cpi	r24, 0x01	; 1
    3886:	a9 f4       	brne	.+42     	; 0x38b2 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    3888:	0e 94 8e 21 	call	0x431c	; 0x431c <prvInitialiseTaskLists>
    388c:	12 c0       	rjmp	.+36     	; 0x38b2 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    388e:	80 91 76 05 	lds	r24, 0x0576
    3892:	88 23       	and	r24, r24
    3894:	71 f4       	brne	.+28     	; 0x38b2 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3896:	e0 91 6e 05 	lds	r30, 0x056E
    389a:	f0 91 6f 05 	lds	r31, 0x056F
    389e:	96 89       	ldd	r25, Z+22	; 0x16
    38a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    38a2:	89 17       	cp	r24, r25
    38a4:	30 f0       	brcs	.+12     	; 0x38b2 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    38a6:	8b 81       	ldd	r24, Y+3	; 0x03
    38a8:	9c 81       	ldd	r25, Y+4	; 0x04
    38aa:	90 93 6f 05 	sts	0x056F, r25
    38ae:	80 93 6e 05 	sts	0x056E, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    38b2:	eb 81       	ldd	r30, Y+3	; 0x03
    38b4:	fc 81       	ldd	r31, Y+4	; 0x04
    38b6:	96 89       	ldd	r25, Z+22	; 0x16
    38b8:	80 91 74 05 	lds	r24, 0x0574
    38bc:	89 17       	cp	r24, r25
    38be:	28 f4       	brcc	.+10     	; 0x38ca <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    38c0:	eb 81       	ldd	r30, Y+3	; 0x03
    38c2:	fc 81       	ldd	r31, Y+4	; 0x04
    38c4:	86 89       	ldd	r24, Z+22	; 0x16
    38c6:	80 93 74 05 	sts	0x0574, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    38ca:	80 91 7b 05 	lds	r24, 0x057B
    38ce:	8f 5f       	subi	r24, 0xFF	; 255
    38d0:	80 93 7b 05 	sts	0x057B, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    38d4:	eb 81       	ldd	r30, Y+3	; 0x03
    38d6:	fc 81       	ldd	r31, Y+4	; 0x04
    38d8:	96 89       	ldd	r25, Z+22	; 0x16
    38da:	80 91 75 05 	lds	r24, 0x0575
    38de:	89 17       	cp	r24, r25
    38e0:	28 f4       	brcc	.+10     	; 0x38ec <xTaskGenericCreate+0x152>
    38e2:	eb 81       	ldd	r30, Y+3	; 0x03
    38e4:	fc 81       	ldd	r31, Y+4	; 0x04
    38e6:	86 89       	ldd	r24, Z+22	; 0x16
    38e8:	80 93 75 05 	sts	0x0575, r24
    38ec:	eb 81       	ldd	r30, Y+3	; 0x03
    38ee:	fc 81       	ldd	r31, Y+4	; 0x04
    38f0:	86 89       	ldd	r24, Z+22	; 0x16
    38f2:	28 2f       	mov	r18, r24
    38f4:	30 e0       	ldi	r19, 0x00	; 0
    38f6:	c9 01       	movw	r24, r18
    38f8:	88 0f       	add	r24, r24
    38fa:	99 1f       	adc	r25, r25
    38fc:	88 0f       	add	r24, r24
    38fe:	99 1f       	adc	r25, r25
    3900:	88 0f       	add	r24, r24
    3902:	99 1f       	adc	r25, r25
    3904:	82 0f       	add	r24, r18
    3906:	93 1f       	adc	r25, r19
    3908:	ac 01       	movw	r20, r24
    390a:	44 58       	subi	r20, 0x84	; 132
    390c:	5a 4f       	sbci	r21, 0xFA	; 250
    390e:	8b 81       	ldd	r24, Y+3	; 0x03
    3910:	9c 81       	ldd	r25, Y+4	; 0x04
    3912:	9c 01       	movw	r18, r24
    3914:	2e 5f       	subi	r18, 0xFE	; 254
    3916:	3f 4f       	sbci	r19, 0xFF	; 255
    3918:	ca 01       	movw	r24, r20
    391a:	b9 01       	movw	r22, r18
    391c:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>

			xReturn = pdPASS;
    3920:	81 e0       	ldi	r24, 0x01	; 1
    3922:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3924:	0f 90       	pop	r0
    3926:	0f be       	out	0x3f, r0	; 63
    3928:	02 c0       	rjmp	.+4      	; 0x392e <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    392a:	8f ef       	ldi	r24, 0xFF	; 255
    392c:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    392e:	8d 81       	ldd	r24, Y+5	; 0x05
    3930:	81 30       	cpi	r24, 0x01	; 1
    3932:	71 f4       	brne	.+28     	; 0x3950 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    3934:	80 91 76 05 	lds	r24, 0x0576
    3938:	88 23       	and	r24, r24
    393a:	51 f0       	breq	.+20     	; 0x3950 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    393c:	e0 91 6e 05 	lds	r30, 0x056E
    3940:	f0 91 6f 05 	lds	r31, 0x056F
    3944:	96 89       	ldd	r25, Z+22	; 0x16
    3946:	8e 85       	ldd	r24, Y+14	; 0x0e
    3948:	98 17       	cp	r25, r24
    394a:	10 f4       	brcc	.+4      	; 0x3950 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    394c:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
			}
		}
	}

	return xReturn;
    3950:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3952:	64 96       	adiw	r28, 0x14	; 20
    3954:	0f b6       	in	r0, 0x3f	; 63
    3956:	f8 94       	cli
    3958:	de bf       	out	0x3e, r29	; 62
    395a:	0f be       	out	0x3f, r0	; 63
    395c:	cd bf       	out	0x3d, r28	; 61
    395e:	cf 91       	pop	r28
    3960:	df 91       	pop	r29
    3962:	1f 91       	pop	r17
    3964:	0f 91       	pop	r16
    3966:	ff 90       	pop	r15
    3968:	ef 90       	pop	r14
    396a:	df 90       	pop	r13
    396c:	cf 90       	pop	r12
    396e:	bf 90       	pop	r11
    3970:	af 90       	pop	r10
    3972:	08 95       	ret

00003974 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    3974:	df 93       	push	r29
    3976:	cf 93       	push	r28
    3978:	00 d0       	rcall	.+0      	; 0x397a <vTaskDelete+0x6>
    397a:	00 d0       	rcall	.+0      	; 0x397c <vTaskDelete+0x8>
    397c:	00 d0       	rcall	.+0      	; 0x397e <vTaskDelete+0xa>
    397e:	cd b7       	in	r28, 0x3d	; 61
    3980:	de b7       	in	r29, 0x3e	; 62
    3982:	9c 83       	std	Y+4, r25	; 0x04
    3984:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    3986:	0f b6       	in	r0, 0x3f	; 63
    3988:	f8 94       	cli
    398a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    398c:	20 91 6e 05 	lds	r18, 0x056E
    3990:	30 91 6f 05 	lds	r19, 0x056F
    3994:	8b 81       	ldd	r24, Y+3	; 0x03
    3996:	9c 81       	ldd	r25, Y+4	; 0x04
    3998:	82 17       	cp	r24, r18
    399a:	93 07       	cpc	r25, r19
    399c:	11 f4       	brne	.+4      	; 0x39a2 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    399e:	1c 82       	std	Y+4, r1	; 0x04
    39a0:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    39a2:	8b 81       	ldd	r24, Y+3	; 0x03
    39a4:	9c 81       	ldd	r25, Y+4	; 0x04
    39a6:	00 97       	sbiw	r24, 0x00	; 0
    39a8:	39 f4       	brne	.+14     	; 0x39b8 <vTaskDelete+0x44>
    39aa:	80 91 6e 05 	lds	r24, 0x056E
    39ae:	90 91 6f 05 	lds	r25, 0x056F
    39b2:	9e 83       	std	Y+6, r25	; 0x06
    39b4:	8d 83       	std	Y+5, r24	; 0x05
    39b6:	04 c0       	rjmp	.+8      	; 0x39c0 <vTaskDelete+0x4c>
    39b8:	8b 81       	ldd	r24, Y+3	; 0x03
    39ba:	9c 81       	ldd	r25, Y+4	; 0x04
    39bc:	9e 83       	std	Y+6, r25	; 0x06
    39be:	8d 83       	std	Y+5, r24	; 0x05
    39c0:	8d 81       	ldd	r24, Y+5	; 0x05
    39c2:	9e 81       	ldd	r25, Y+6	; 0x06
    39c4:	9a 83       	std	Y+2, r25	; 0x02
    39c6:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    39c8:	89 81       	ldd	r24, Y+1	; 0x01
    39ca:	9a 81       	ldd	r25, Y+2	; 0x02
    39cc:	02 96       	adiw	r24, 0x02	; 2
    39ce:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    39d2:	e9 81       	ldd	r30, Y+1	; 0x01
    39d4:	fa 81       	ldd	r31, Y+2	; 0x02
    39d6:	84 89       	ldd	r24, Z+20	; 0x14
    39d8:	95 89       	ldd	r25, Z+21	; 0x15
    39da:	00 97       	sbiw	r24, 0x00	; 0
    39dc:	29 f0       	breq	.+10     	; 0x39e8 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    39de:	89 81       	ldd	r24, Y+1	; 0x01
    39e0:	9a 81       	ldd	r25, Y+2	; 0x02
    39e2:	0c 96       	adiw	r24, 0x0c	; 12
    39e4:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    39e8:	89 81       	ldd	r24, Y+1	; 0x01
    39ea:	9a 81       	ldd	r25, Y+2	; 0x02
    39ec:	9c 01       	movw	r18, r24
    39ee:	2e 5f       	subi	r18, 0xFE	; 254
    39f0:	3f 4f       	sbci	r19, 0xFF	; 255
    39f2:	8a ed       	ldi	r24, 0xDA	; 218
    39f4:	95 e0       	ldi	r25, 0x05	; 5
    39f6:	b9 01       	movw	r22, r18
    39f8:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    39fc:	80 91 70 05 	lds	r24, 0x0570
    3a00:	8f 5f       	subi	r24, 0xFF	; 255
    3a02:	80 93 70 05 	sts	0x0570, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    3a06:	80 91 7b 05 	lds	r24, 0x057B
    3a0a:	8f 5f       	subi	r24, 0xFF	; 255
    3a0c:	80 93 7b 05 	sts	0x057B, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3a10:	0f 90       	pop	r0
    3a12:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    3a14:	80 91 76 05 	lds	r24, 0x0576
    3a18:	88 23       	and	r24, r24
    3a1a:	31 f0       	breq	.+12     	; 0x3a28 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    3a1c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a1e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a20:	00 97       	sbiw	r24, 0x00	; 0
    3a22:	11 f4       	brne	.+4      	; 0x3a28 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    3a24:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
			}
		}
	}
    3a28:	26 96       	adiw	r28, 0x06	; 6
    3a2a:	0f b6       	in	r0, 0x3f	; 63
    3a2c:	f8 94       	cli
    3a2e:	de bf       	out	0x3e, r29	; 62
    3a30:	0f be       	out	0x3f, r0	; 63
    3a32:	cd bf       	out	0x3d, r28	; 61
    3a34:	cf 91       	pop	r28
    3a36:	df 91       	pop	r29
    3a38:	08 95       	ret

00003a3a <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    3a3a:	df 93       	push	r29
    3a3c:	cf 93       	push	r28
    3a3e:	cd b7       	in	r28, 0x3d	; 61
    3a40:	de b7       	in	r29, 0x3e	; 62
    3a42:	28 97       	sbiw	r28, 0x08	; 8
    3a44:	0f b6       	in	r0, 0x3f	; 63
    3a46:	f8 94       	cli
    3a48:	de bf       	out	0x3e, r29	; 62
    3a4a:	0f be       	out	0x3f, r0	; 63
    3a4c:	cd bf       	out	0x3d, r28	; 61
    3a4e:	9e 83       	std	Y+6, r25	; 0x06
    3a50:	8d 83       	std	Y+5, r24	; 0x05
    3a52:	78 87       	std	Y+8, r23	; 0x08
    3a54:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    3a56:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    3a58:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3a5c:	ed 81       	ldd	r30, Y+5	; 0x05
    3a5e:	fe 81       	ldd	r31, Y+6	; 0x06
    3a60:	20 81       	ld	r18, Z
    3a62:	31 81       	ldd	r19, Z+1	; 0x01
    3a64:	8f 81       	ldd	r24, Y+7	; 0x07
    3a66:	98 85       	ldd	r25, Y+8	; 0x08
    3a68:	82 0f       	add	r24, r18
    3a6a:	93 1f       	adc	r25, r19
    3a6c:	9c 83       	std	Y+4, r25	; 0x04
    3a6e:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    3a70:	ed 81       	ldd	r30, Y+5	; 0x05
    3a72:	fe 81       	ldd	r31, Y+6	; 0x06
    3a74:	20 81       	ld	r18, Z
    3a76:	31 81       	ldd	r19, Z+1	; 0x01
    3a78:	80 91 72 05 	lds	r24, 0x0572
    3a7c:	90 91 73 05 	lds	r25, 0x0573
    3a80:	82 17       	cp	r24, r18
    3a82:	93 07       	cpc	r25, r19
    3a84:	a8 f4       	brcc	.+42     	; 0x3ab0 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    3a86:	ed 81       	ldd	r30, Y+5	; 0x05
    3a88:	fe 81       	ldd	r31, Y+6	; 0x06
    3a8a:	20 81       	ld	r18, Z
    3a8c:	31 81       	ldd	r19, Z+1	; 0x01
    3a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a90:	9c 81       	ldd	r25, Y+4	; 0x04
    3a92:	82 17       	cp	r24, r18
    3a94:	93 07       	cpc	r25, r19
    3a96:	00 f5       	brcc	.+64     	; 0x3ad8 <vTaskDelayUntil+0x9e>
    3a98:	20 91 72 05 	lds	r18, 0x0572
    3a9c:	30 91 73 05 	lds	r19, 0x0573
    3aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    3aa2:	9c 81       	ldd	r25, Y+4	; 0x04
    3aa4:	28 17       	cp	r18, r24
    3aa6:	39 07       	cpc	r19, r25
    3aa8:	b8 f4       	brcc	.+46     	; 0x3ad8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3aaa:	81 e0       	ldi	r24, 0x01	; 1
    3aac:	89 83       	std	Y+1, r24	; 0x01
    3aae:	14 c0       	rjmp	.+40     	; 0x3ad8 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3ab0:	ed 81       	ldd	r30, Y+5	; 0x05
    3ab2:	fe 81       	ldd	r31, Y+6	; 0x06
    3ab4:	20 81       	ld	r18, Z
    3ab6:	31 81       	ldd	r19, Z+1	; 0x01
    3ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    3aba:	9c 81       	ldd	r25, Y+4	; 0x04
    3abc:	82 17       	cp	r24, r18
    3abe:	93 07       	cpc	r25, r19
    3ac0:	48 f0       	brcs	.+18     	; 0x3ad4 <vTaskDelayUntil+0x9a>
    3ac2:	20 91 72 05 	lds	r18, 0x0572
    3ac6:	30 91 73 05 	lds	r19, 0x0573
    3aca:	8b 81       	ldd	r24, Y+3	; 0x03
    3acc:	9c 81       	ldd	r25, Y+4	; 0x04
    3ace:	28 17       	cp	r18, r24
    3ad0:	39 07       	cpc	r19, r25
    3ad2:	10 f4       	brcc	.+4      	; 0x3ad8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3ad4:	81 e0       	ldi	r24, 0x01	; 1
    3ad6:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3ad8:	ed 81       	ldd	r30, Y+5	; 0x05
    3ada:	fe 81       	ldd	r31, Y+6	; 0x06
    3adc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ade:	9c 81       	ldd	r25, Y+4	; 0x04
    3ae0:	91 83       	std	Z+1, r25	; 0x01
    3ae2:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3ae4:	89 81       	ldd	r24, Y+1	; 0x01
    3ae6:	88 23       	and	r24, r24
    3ae8:	59 f0       	breq	.+22     	; 0x3b00 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3aea:	80 91 6e 05 	lds	r24, 0x056E
    3aee:	90 91 6f 05 	lds	r25, 0x056F
    3af2:	02 96       	adiw	r24, 0x02	; 2
    3af4:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3af8:	8b 81       	ldd	r24, Y+3	; 0x03
    3afa:	9c 81       	ldd	r25, Y+4	; 0x04
    3afc:	0e 94 09 22 	call	0x4412	; 0x4412 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3b00:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>
    3b04:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3b06:	8a 81       	ldd	r24, Y+2	; 0x02
    3b08:	88 23       	and	r24, r24
    3b0a:	11 f4       	brne	.+4      	; 0x3b10 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    3b0c:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
		}
	}
    3b10:	28 96       	adiw	r28, 0x08	; 8
    3b12:	0f b6       	in	r0, 0x3f	; 63
    3b14:	f8 94       	cli
    3b16:	de bf       	out	0x3e, r29	; 62
    3b18:	0f be       	out	0x3f, r0	; 63
    3b1a:	cd bf       	out	0x3d, r28	; 61
    3b1c:	cf 91       	pop	r28
    3b1e:	df 91       	pop	r29
    3b20:	08 95       	ret

00003b22 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    3b22:	df 93       	push	r29
    3b24:	cf 93       	push	r28
    3b26:	00 d0       	rcall	.+0      	; 0x3b28 <vTaskDelay+0x6>
    3b28:	00 d0       	rcall	.+0      	; 0x3b2a <vTaskDelay+0x8>
    3b2a:	0f 92       	push	r0
    3b2c:	cd b7       	in	r28, 0x3d	; 61
    3b2e:	de b7       	in	r29, 0x3e	; 62
    3b30:	9d 83       	std	Y+5, r25	; 0x05
    3b32:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    3b34:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    3b36:	8c 81       	ldd	r24, Y+4	; 0x04
    3b38:	9d 81       	ldd	r25, Y+5	; 0x05
    3b3a:	00 97       	sbiw	r24, 0x00	; 0
    3b3c:	d1 f0       	breq	.+52     	; 0x3b72 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    3b3e:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3b42:	20 91 72 05 	lds	r18, 0x0572
    3b46:	30 91 73 05 	lds	r19, 0x0573
    3b4a:	8c 81       	ldd	r24, Y+4	; 0x04
    3b4c:	9d 81       	ldd	r25, Y+5	; 0x05
    3b4e:	82 0f       	add	r24, r18
    3b50:	93 1f       	adc	r25, r19
    3b52:	9b 83       	std	Y+3, r25	; 0x03
    3b54:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3b56:	80 91 6e 05 	lds	r24, 0x056E
    3b5a:	90 91 6f 05 	lds	r25, 0x056F
    3b5e:	02 96       	adiw	r24, 0x02	; 2
    3b60:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3b64:	8a 81       	ldd	r24, Y+2	; 0x02
    3b66:	9b 81       	ldd	r25, Y+3	; 0x03
    3b68:	0e 94 09 22 	call	0x4412	; 0x4412 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3b6c:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>
    3b70:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3b72:	89 81       	ldd	r24, Y+1	; 0x01
    3b74:	88 23       	and	r24, r24
    3b76:	11 f4       	brne	.+4      	; 0x3b7c <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3b78:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
		}
	}
    3b7c:	0f 90       	pop	r0
    3b7e:	0f 90       	pop	r0
    3b80:	0f 90       	pop	r0
    3b82:	0f 90       	pop	r0
    3b84:	0f 90       	pop	r0
    3b86:	cf 91       	pop	r28
    3b88:	df 91       	pop	r29
    3b8a:	08 95       	ret

00003b8c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    3b8c:	af 92       	push	r10
    3b8e:	bf 92       	push	r11
    3b90:	cf 92       	push	r12
    3b92:	df 92       	push	r13
    3b94:	ef 92       	push	r14
    3b96:	ff 92       	push	r15
    3b98:	0f 93       	push	r16
    3b9a:	df 93       	push	r29
    3b9c:	cf 93       	push	r28
    3b9e:	0f 92       	push	r0
    3ba0:	cd b7       	in	r28, 0x3d	; 61
    3ba2:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    3ba4:	22 e7       	ldi	r18, 0x72	; 114
    3ba6:	30 e0       	ldi	r19, 0x00	; 0
    3ba8:	8d e2       	ldi	r24, 0x2D	; 45
    3baa:	91 e2       	ldi	r25, 0x21	; 33
    3bac:	b9 01       	movw	r22, r18
    3bae:	44 e6       	ldi	r20, 0x64	; 100
    3bb0:	50 e0       	ldi	r21, 0x00	; 0
    3bb2:	20 e0       	ldi	r18, 0x00	; 0
    3bb4:	30 e0       	ldi	r19, 0x00	; 0
    3bb6:	00 e0       	ldi	r16, 0x00	; 0
    3bb8:	ee 24       	eor	r14, r14
    3bba:	ff 24       	eor	r15, r15
    3bbc:	cc 24       	eor	r12, r12
    3bbe:	dd 24       	eor	r13, r13
    3bc0:	aa 24       	eor	r10, r10
    3bc2:	bb 24       	eor	r11, r11
    3bc4:	0e 94 cd 1b 	call	0x379a	; 0x379a <xTaskGenericCreate>
    3bc8:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    3bca:	89 81       	ldd	r24, Y+1	; 0x01
    3bcc:	81 30       	cpi	r24, 0x01	; 1
    3bce:	51 f4       	brne	.+20     	; 0x3be4 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    3bd0:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    3bd2:	81 e0       	ldi	r24, 0x01	; 1
    3bd4:	80 93 76 05 	sts	0x0576, r24
		xTickCount = ( portTickType ) 0U;
    3bd8:	10 92 73 05 	sts	0x0573, r1
    3bdc:	10 92 72 05 	sts	0x0572, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3be0:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    3be4:	0f 90       	pop	r0
    3be6:	cf 91       	pop	r28
    3be8:	df 91       	pop	r29
    3bea:	0f 91       	pop	r16
    3bec:	ff 90       	pop	r15
    3bee:	ef 90       	pop	r14
    3bf0:	df 90       	pop	r13
    3bf2:	cf 90       	pop	r12
    3bf4:	bf 90       	pop	r11
    3bf6:	af 90       	pop	r10
    3bf8:	08 95       	ret

00003bfa <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3bfa:	df 93       	push	r29
    3bfc:	cf 93       	push	r28
    3bfe:	cd b7       	in	r28, 0x3d	; 61
    3c00:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3c02:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3c04:	10 92 76 05 	sts	0x0576, r1
	vPortEndScheduler();
    3c08:	0e 94 13 16 	call	0x2c26	; 0x2c26 <vPortEndScheduler>
}
    3c0c:	cf 91       	pop	r28
    3c0e:	df 91       	pop	r29
    3c10:	08 95       	ret

00003c12 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3c12:	df 93       	push	r29
    3c14:	cf 93       	push	r28
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    3c1a:	80 91 77 05 	lds	r24, 0x0577
    3c1e:	8f 5f       	subi	r24, 0xFF	; 255
    3c20:	80 93 77 05 	sts	0x0577, r24
}
    3c24:	cf 91       	pop	r28
    3c26:	df 91       	pop	r29
    3c28:	08 95       	ret

00003c2a <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    3c2a:	df 93       	push	r29
    3c2c:	cf 93       	push	r28
    3c2e:	00 d0       	rcall	.+0      	; 0x3c30 <xTaskResumeAll+0x6>
    3c30:	00 d0       	rcall	.+0      	; 0x3c32 <xTaskResumeAll+0x8>
    3c32:	cd b7       	in	r28, 0x3d	; 61
    3c34:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    3c36:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3c38:	0f b6       	in	r0, 0x3f	; 63
    3c3a:	f8 94       	cli
    3c3c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3c3e:	80 91 77 05 	lds	r24, 0x0577
    3c42:	81 50       	subi	r24, 0x01	; 1
    3c44:	80 93 77 05 	sts	0x0577, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3c48:	80 91 77 05 	lds	r24, 0x0577
    3c4c:	88 23       	and	r24, r24
    3c4e:	09 f0       	breq	.+2      	; 0x3c52 <xTaskResumeAll+0x28>
    3c50:	6c c0       	rjmp	.+216    	; 0x3d2a <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    3c52:	80 91 71 05 	lds	r24, 0x0571
    3c56:	88 23       	and	r24, r24
    3c58:	09 f4       	brne	.+2      	; 0x3c5c <xTaskResumeAll+0x32>
    3c5a:	67 c0       	rjmp	.+206    	; 0x3d2a <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    3c5c:	19 82       	std	Y+1, r1	; 0x01
    3c5e:	41 c0       	rjmp	.+130    	; 0x3ce2 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3c60:	e0 91 d6 05 	lds	r30, 0x05D6
    3c64:	f0 91 d7 05 	lds	r31, 0x05D7
    3c68:	86 81       	ldd	r24, Z+6	; 0x06
    3c6a:	97 81       	ldd	r25, Z+7	; 0x07
    3c6c:	9c 83       	std	Y+4, r25	; 0x04
    3c6e:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    3c70:	8b 81       	ldd	r24, Y+3	; 0x03
    3c72:	9c 81       	ldd	r25, Y+4	; 0x04
    3c74:	0c 96       	adiw	r24, 0x0c	; 12
    3c76:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    3c7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c7c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c7e:	02 96       	adiw	r24, 0x02	; 2
    3c80:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    3c84:	eb 81       	ldd	r30, Y+3	; 0x03
    3c86:	fc 81       	ldd	r31, Y+4	; 0x04
    3c88:	96 89       	ldd	r25, Z+22	; 0x16
    3c8a:	80 91 75 05 	lds	r24, 0x0575
    3c8e:	89 17       	cp	r24, r25
    3c90:	28 f4       	brcc	.+10     	; 0x3c9c <xTaskResumeAll+0x72>
    3c92:	eb 81       	ldd	r30, Y+3	; 0x03
    3c94:	fc 81       	ldd	r31, Y+4	; 0x04
    3c96:	86 89       	ldd	r24, Z+22	; 0x16
    3c98:	80 93 75 05 	sts	0x0575, r24
    3c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    3ca0:	86 89       	ldd	r24, Z+22	; 0x16
    3ca2:	28 2f       	mov	r18, r24
    3ca4:	30 e0       	ldi	r19, 0x00	; 0
    3ca6:	c9 01       	movw	r24, r18
    3ca8:	88 0f       	add	r24, r24
    3caa:	99 1f       	adc	r25, r25
    3cac:	88 0f       	add	r24, r24
    3cae:	99 1f       	adc	r25, r25
    3cb0:	88 0f       	add	r24, r24
    3cb2:	99 1f       	adc	r25, r25
    3cb4:	82 0f       	add	r24, r18
    3cb6:	93 1f       	adc	r25, r19
    3cb8:	84 58       	subi	r24, 0x84	; 132
    3cba:	9a 4f       	sbci	r25, 0xFA	; 250
    3cbc:	2b 81       	ldd	r18, Y+3	; 0x03
    3cbe:	3c 81       	ldd	r19, Y+4	; 0x04
    3cc0:	2e 5f       	subi	r18, 0xFE	; 254
    3cc2:	3f 4f       	sbci	r19, 0xFF	; 255
    3cc4:	b9 01       	movw	r22, r18
    3cc6:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3cca:	eb 81       	ldd	r30, Y+3	; 0x03
    3ccc:	fc 81       	ldd	r31, Y+4	; 0x04
    3cce:	96 89       	ldd	r25, Z+22	; 0x16
    3cd0:	e0 91 6e 05 	lds	r30, 0x056E
    3cd4:	f0 91 6f 05 	lds	r31, 0x056F
    3cd8:	86 89       	ldd	r24, Z+22	; 0x16
    3cda:	98 17       	cp	r25, r24
    3cdc:	10 f0       	brcs	.+4      	; 0x3ce2 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    3cde:	81 e0       	ldi	r24, 0x01	; 1
    3ce0:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3ce2:	80 91 d1 05 	lds	r24, 0x05D1
    3ce6:	88 23       	and	r24, r24
    3ce8:	09 f0       	breq	.+2      	; 0x3cec <xTaskResumeAll+0xc2>
    3cea:	ba cf       	rjmp	.-140    	; 0x3c60 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3cec:	80 91 78 05 	lds	r24, 0x0578
    3cf0:	88 23       	and	r24, r24
    3cf2:	71 f0       	breq	.+28     	; 0x3d10 <xTaskResumeAll+0xe6>
    3cf4:	07 c0       	rjmp	.+14     	; 0x3d04 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    3cf6:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <vTaskIncrementTick>
						--uxMissedTicks;
    3cfa:	80 91 78 05 	lds	r24, 0x0578
    3cfe:	81 50       	subi	r24, 0x01	; 1
    3d00:	80 93 78 05 	sts	0x0578, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3d04:	80 91 78 05 	lds	r24, 0x0578
    3d08:	88 23       	and	r24, r24
    3d0a:	a9 f7       	brne	.-22     	; 0x3cf6 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    3d0c:	81 e0       	ldi	r24, 0x01	; 1
    3d0e:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    3d10:	89 81       	ldd	r24, Y+1	; 0x01
    3d12:	81 30       	cpi	r24, 0x01	; 1
    3d14:	21 f0       	breq	.+8      	; 0x3d1e <xTaskResumeAll+0xf4>
    3d16:	80 91 79 05 	lds	r24, 0x0579
    3d1a:	81 30       	cpi	r24, 0x01	; 1
    3d1c:	31 f4       	brne	.+12     	; 0x3d2a <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    3d1e:	81 e0       	ldi	r24, 0x01	; 1
    3d20:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    3d22:	10 92 79 05 	sts	0x0579, r1
					portYIELD_WITHIN_API();
    3d26:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    3d2a:	0f 90       	pop	r0
    3d2c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3d2e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3d30:	0f 90       	pop	r0
    3d32:	0f 90       	pop	r0
    3d34:	0f 90       	pop	r0
    3d36:	0f 90       	pop	r0
    3d38:	cf 91       	pop	r28
    3d3a:	df 91       	pop	r29
    3d3c:	08 95       	ret

00003d3e <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    3d3e:	df 93       	push	r29
    3d40:	cf 93       	push	r28
    3d42:	00 d0       	rcall	.+0      	; 0x3d44 <xTaskGetTickCount+0x6>
    3d44:	cd b7       	in	r28, 0x3d	; 61
    3d46:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3d48:	0f b6       	in	r0, 0x3f	; 63
    3d4a:	f8 94       	cli
    3d4c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3d4e:	80 91 72 05 	lds	r24, 0x0572
    3d52:	90 91 73 05 	lds	r25, 0x0573
    3d56:	9a 83       	std	Y+2, r25	; 0x02
    3d58:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3d5a:	0f 90       	pop	r0
    3d5c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3d5e:	89 81       	ldd	r24, Y+1	; 0x01
    3d60:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3d62:	0f 90       	pop	r0
    3d64:	0f 90       	pop	r0
    3d66:	cf 91       	pop	r28
    3d68:	df 91       	pop	r29
    3d6a:	08 95       	ret

00003d6c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    3d6c:	df 93       	push	r29
    3d6e:	cf 93       	push	r28
    3d70:	00 d0       	rcall	.+0      	; 0x3d72 <xTaskGetTickCountFromISR+0x6>
    3d72:	0f 92       	push	r0
    3d74:	cd b7       	in	r28, 0x3d	; 61
    3d76:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3d78:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    3d7a:	80 91 72 05 	lds	r24, 0x0572
    3d7e:	90 91 73 05 	lds	r25, 0x0573
    3d82:	9b 83       	std	Y+3, r25	; 0x03
    3d84:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3d86:	8a 81       	ldd	r24, Y+2	; 0x02
    3d88:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3d8a:	0f 90       	pop	r0
    3d8c:	0f 90       	pop	r0
    3d8e:	0f 90       	pop	r0
    3d90:	cf 91       	pop	r28
    3d92:	df 91       	pop	r29
    3d94:	08 95       	ret

00003d96 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    3d96:	df 93       	push	r29
    3d98:	cf 93       	push	r28
    3d9a:	cd b7       	in	r28, 0x3d	; 61
    3d9c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    3d9e:	80 91 71 05 	lds	r24, 0x0571
}
    3da2:	cf 91       	pop	r28
    3da4:	df 91       	pop	r29
    3da6:	08 95       	ret

00003da8 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    3da8:	df 93       	push	r29
    3daa:	cf 93       	push	r28
    3dac:	00 d0       	rcall	.+0      	; 0x3dae <vTaskIncrementTick+0x6>
    3dae:	00 d0       	rcall	.+0      	; 0x3db0 <vTaskIncrementTick+0x8>
    3db0:	00 d0       	rcall	.+0      	; 0x3db2 <vTaskIncrementTick+0xa>
    3db2:	cd b7       	in	r28, 0x3d	; 61
    3db4:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3db6:	80 91 77 05 	lds	r24, 0x0577
    3dba:	88 23       	and	r24, r24
    3dbc:	09 f0       	breq	.+2      	; 0x3dc0 <vTaskIncrementTick+0x18>
    3dbe:	bb c0       	rjmp	.+374    	; 0x3f36 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    3dc0:	80 91 72 05 	lds	r24, 0x0572
    3dc4:	90 91 73 05 	lds	r25, 0x0573
    3dc8:	01 96       	adiw	r24, 0x01	; 1
    3dca:	90 93 73 05 	sts	0x0573, r25
    3dce:	80 93 72 05 	sts	0x0572, r24
		if( xTickCount == ( portTickType ) 0U )
    3dd2:	80 91 72 05 	lds	r24, 0x0572
    3dd6:	90 91 73 05 	lds	r25, 0x0573
    3dda:	00 97       	sbiw	r24, 0x00	; 0
    3ddc:	d1 f5       	brne	.+116    	; 0x3e52 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    3dde:	80 91 cd 05 	lds	r24, 0x05CD
    3de2:	90 91 ce 05 	lds	r25, 0x05CE
    3de6:	9c 83       	std	Y+4, r25	; 0x04
    3de8:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    3dea:	80 91 cf 05 	lds	r24, 0x05CF
    3dee:	90 91 d0 05 	lds	r25, 0x05D0
    3df2:	90 93 ce 05 	sts	0x05CE, r25
    3df6:	80 93 cd 05 	sts	0x05CD, r24
			pxOverflowDelayedTaskList = pxTemp;
    3dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    3dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    3dfe:	90 93 d0 05 	sts	0x05D0, r25
    3e02:	80 93 cf 05 	sts	0x05CF, r24
			xNumOfOverflows++;
    3e06:	80 91 7a 05 	lds	r24, 0x057A
    3e0a:	8f 5f       	subi	r24, 0xFF	; 255
    3e0c:	80 93 7a 05 	sts	0x057A, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3e10:	e0 91 cd 05 	lds	r30, 0x05CD
    3e14:	f0 91 ce 05 	lds	r31, 0x05CE
    3e18:	80 81       	ld	r24, Z
    3e1a:	88 23       	and	r24, r24
    3e1c:	39 f4       	brne	.+14     	; 0x3e2c <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    3e1e:	8f ef       	ldi	r24, 0xFF	; 255
    3e20:	9f ef       	ldi	r25, 0xFF	; 255
    3e22:	90 93 80 00 	sts	0x0080, r25
    3e26:	80 93 7f 00 	sts	0x007F, r24
    3e2a:	13 c0       	rjmp	.+38     	; 0x3e52 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3e2c:	e0 91 cd 05 	lds	r30, 0x05CD
    3e30:	f0 91 ce 05 	lds	r31, 0x05CE
    3e34:	05 80       	ldd	r0, Z+5	; 0x05
    3e36:	f6 81       	ldd	r31, Z+6	; 0x06
    3e38:	e0 2d       	mov	r30, r0
    3e3a:	86 81       	ldd	r24, Z+6	; 0x06
    3e3c:	97 81       	ldd	r25, Z+7	; 0x07
    3e3e:	9e 83       	std	Y+6, r25	; 0x06
    3e40:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3e42:	ed 81       	ldd	r30, Y+5	; 0x05
    3e44:	fe 81       	ldd	r31, Y+6	; 0x06
    3e46:	82 81       	ldd	r24, Z+2	; 0x02
    3e48:	93 81       	ldd	r25, Z+3	; 0x03
    3e4a:	90 93 80 00 	sts	0x0080, r25
    3e4e:	80 93 7f 00 	sts	0x007F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    3e52:	20 91 72 05 	lds	r18, 0x0572
    3e56:	30 91 73 05 	lds	r19, 0x0573
    3e5a:	80 91 7f 00 	lds	r24, 0x007F
    3e5e:	90 91 80 00 	lds	r25, 0x0080
    3e62:	28 17       	cp	r18, r24
    3e64:	39 07       	cpc	r19, r25
    3e66:	08 f4       	brcc	.+2      	; 0x3e6a <vTaskIncrementTick+0xc2>
    3e68:	6b c0       	rjmp	.+214    	; 0x3f40 <vTaskIncrementTick+0x198>
    3e6a:	e0 91 cd 05 	lds	r30, 0x05CD
    3e6e:	f0 91 ce 05 	lds	r31, 0x05CE
    3e72:	80 81       	ld	r24, Z
    3e74:	88 23       	and	r24, r24
    3e76:	39 f4       	brne	.+14     	; 0x3e86 <vTaskIncrementTick+0xde>
    3e78:	8f ef       	ldi	r24, 0xFF	; 255
    3e7a:	9f ef       	ldi	r25, 0xFF	; 255
    3e7c:	90 93 80 00 	sts	0x0080, r25
    3e80:	80 93 7f 00 	sts	0x007F, r24
    3e84:	5d c0       	rjmp	.+186    	; 0x3f40 <vTaskIncrementTick+0x198>
    3e86:	e0 91 cd 05 	lds	r30, 0x05CD
    3e8a:	f0 91 ce 05 	lds	r31, 0x05CE
    3e8e:	05 80       	ldd	r0, Z+5	; 0x05
    3e90:	f6 81       	ldd	r31, Z+6	; 0x06
    3e92:	e0 2d       	mov	r30, r0
    3e94:	86 81       	ldd	r24, Z+6	; 0x06
    3e96:	97 81       	ldd	r25, Z+7	; 0x07
    3e98:	9e 83       	std	Y+6, r25	; 0x06
    3e9a:	8d 83       	std	Y+5, r24	; 0x05
    3e9c:	ed 81       	ldd	r30, Y+5	; 0x05
    3e9e:	fe 81       	ldd	r31, Y+6	; 0x06
    3ea0:	82 81       	ldd	r24, Z+2	; 0x02
    3ea2:	93 81       	ldd	r25, Z+3	; 0x03
    3ea4:	9a 83       	std	Y+2, r25	; 0x02
    3ea6:	89 83       	std	Y+1, r24	; 0x01
    3ea8:	20 91 72 05 	lds	r18, 0x0572
    3eac:	30 91 73 05 	lds	r19, 0x0573
    3eb0:	89 81       	ldd	r24, Y+1	; 0x01
    3eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb4:	28 17       	cp	r18, r24
    3eb6:	39 07       	cpc	r19, r25
    3eb8:	38 f4       	brcc	.+14     	; 0x3ec8 <vTaskIncrementTick+0x120>
    3eba:	89 81       	ldd	r24, Y+1	; 0x01
    3ebc:	9a 81       	ldd	r25, Y+2	; 0x02
    3ebe:	90 93 80 00 	sts	0x0080, r25
    3ec2:	80 93 7f 00 	sts	0x007F, r24
    3ec6:	3c c0       	rjmp	.+120    	; 0x3f40 <vTaskIncrementTick+0x198>
    3ec8:	8d 81       	ldd	r24, Y+5	; 0x05
    3eca:	9e 81       	ldd	r25, Y+6	; 0x06
    3ecc:	02 96       	adiw	r24, 0x02	; 2
    3ece:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
    3ed2:	ed 81       	ldd	r30, Y+5	; 0x05
    3ed4:	fe 81       	ldd	r31, Y+6	; 0x06
    3ed6:	84 89       	ldd	r24, Z+20	; 0x14
    3ed8:	95 89       	ldd	r25, Z+21	; 0x15
    3eda:	00 97       	sbiw	r24, 0x00	; 0
    3edc:	29 f0       	breq	.+10     	; 0x3ee8 <vTaskIncrementTick+0x140>
    3ede:	8d 81       	ldd	r24, Y+5	; 0x05
    3ee0:	9e 81       	ldd	r25, Y+6	; 0x06
    3ee2:	0c 96       	adiw	r24, 0x0c	; 12
    3ee4:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
    3ee8:	ed 81       	ldd	r30, Y+5	; 0x05
    3eea:	fe 81       	ldd	r31, Y+6	; 0x06
    3eec:	96 89       	ldd	r25, Z+22	; 0x16
    3eee:	80 91 75 05 	lds	r24, 0x0575
    3ef2:	89 17       	cp	r24, r25
    3ef4:	28 f4       	brcc	.+10     	; 0x3f00 <vTaskIncrementTick+0x158>
    3ef6:	ed 81       	ldd	r30, Y+5	; 0x05
    3ef8:	fe 81       	ldd	r31, Y+6	; 0x06
    3efa:	86 89       	ldd	r24, Z+22	; 0x16
    3efc:	80 93 75 05 	sts	0x0575, r24
    3f00:	ed 81       	ldd	r30, Y+5	; 0x05
    3f02:	fe 81       	ldd	r31, Y+6	; 0x06
    3f04:	86 89       	ldd	r24, Z+22	; 0x16
    3f06:	28 2f       	mov	r18, r24
    3f08:	30 e0       	ldi	r19, 0x00	; 0
    3f0a:	c9 01       	movw	r24, r18
    3f0c:	88 0f       	add	r24, r24
    3f0e:	99 1f       	adc	r25, r25
    3f10:	88 0f       	add	r24, r24
    3f12:	99 1f       	adc	r25, r25
    3f14:	88 0f       	add	r24, r24
    3f16:	99 1f       	adc	r25, r25
    3f18:	82 0f       	add	r24, r18
    3f1a:	93 1f       	adc	r25, r19
    3f1c:	ac 01       	movw	r20, r24
    3f1e:	44 58       	subi	r20, 0x84	; 132
    3f20:	5a 4f       	sbci	r21, 0xFA	; 250
    3f22:	8d 81       	ldd	r24, Y+5	; 0x05
    3f24:	9e 81       	ldd	r25, Y+6	; 0x06
    3f26:	9c 01       	movw	r18, r24
    3f28:	2e 5f       	subi	r18, 0xFE	; 254
    3f2a:	3f 4f       	sbci	r19, 0xFF	; 255
    3f2c:	ca 01       	movw	r24, r20
    3f2e:	b9 01       	movw	r22, r18
    3f30:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>
    3f34:	9a cf       	rjmp	.-204    	; 0x3e6a <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3f36:	80 91 78 05 	lds	r24, 0x0578
    3f3a:	8f 5f       	subi	r24, 0xFF	; 255
    3f3c:	80 93 78 05 	sts	0x0578, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    3f40:	26 96       	adiw	r28, 0x06	; 6
    3f42:	0f b6       	in	r0, 0x3f	; 63
    3f44:	f8 94       	cli
    3f46:	de bf       	out	0x3e, r29	; 62
    3f48:	0f be       	out	0x3f, r0	; 63
    3f4a:	cd bf       	out	0x3d, r28	; 61
    3f4c:	cf 91       	pop	r28
    3f4e:	df 91       	pop	r29
    3f50:	08 95       	ret

00003f52 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3f52:	df 93       	push	r29
    3f54:	cf 93       	push	r28
    3f56:	00 d0       	rcall	.+0      	; 0x3f58 <vTaskSwitchContext+0x6>
    3f58:	cd b7       	in	r28, 0x3d	; 61
    3f5a:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3f5c:	80 91 77 05 	lds	r24, 0x0577
    3f60:	88 23       	and	r24, r24
    3f62:	49 f0       	breq	.+18     	; 0x3f76 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3f64:	81 e0       	ldi	r24, 0x01	; 1
    3f66:	80 93 79 05 	sts	0x0579, r24
    3f6a:	54 c0       	rjmp	.+168    	; 0x4014 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3f6c:	80 91 75 05 	lds	r24, 0x0575
    3f70:	81 50       	subi	r24, 0x01	; 1
    3f72:	80 93 75 05 	sts	0x0575, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3f76:	80 91 75 05 	lds	r24, 0x0575
    3f7a:	28 2f       	mov	r18, r24
    3f7c:	30 e0       	ldi	r19, 0x00	; 0
    3f7e:	c9 01       	movw	r24, r18
    3f80:	88 0f       	add	r24, r24
    3f82:	99 1f       	adc	r25, r25
    3f84:	88 0f       	add	r24, r24
    3f86:	99 1f       	adc	r25, r25
    3f88:	88 0f       	add	r24, r24
    3f8a:	99 1f       	adc	r25, r25
    3f8c:	82 0f       	add	r24, r18
    3f8e:	93 1f       	adc	r25, r19
    3f90:	fc 01       	movw	r30, r24
    3f92:	e4 58       	subi	r30, 0x84	; 132
    3f94:	fa 4f       	sbci	r31, 0xFA	; 250
    3f96:	80 81       	ld	r24, Z
    3f98:	88 23       	and	r24, r24
    3f9a:	41 f3       	breq	.-48     	; 0x3f6c <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    3f9c:	80 91 75 05 	lds	r24, 0x0575
    3fa0:	28 2f       	mov	r18, r24
    3fa2:	30 e0       	ldi	r19, 0x00	; 0
    3fa4:	c9 01       	movw	r24, r18
    3fa6:	88 0f       	add	r24, r24
    3fa8:	99 1f       	adc	r25, r25
    3faa:	88 0f       	add	r24, r24
    3fac:	99 1f       	adc	r25, r25
    3fae:	88 0f       	add	r24, r24
    3fb0:	99 1f       	adc	r25, r25
    3fb2:	82 0f       	add	r24, r18
    3fb4:	93 1f       	adc	r25, r19
    3fb6:	84 58       	subi	r24, 0x84	; 132
    3fb8:	9a 4f       	sbci	r25, 0xFA	; 250
    3fba:	9a 83       	std	Y+2, r25	; 0x02
    3fbc:	89 83       	std	Y+1, r24	; 0x01
    3fbe:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc2:	01 80       	ldd	r0, Z+1	; 0x01
    3fc4:	f2 81       	ldd	r31, Z+2	; 0x02
    3fc6:	e0 2d       	mov	r30, r0
    3fc8:	82 81       	ldd	r24, Z+2	; 0x02
    3fca:	93 81       	ldd	r25, Z+3	; 0x03
    3fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    3fce:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd0:	92 83       	std	Z+2, r25	; 0x02
    3fd2:	81 83       	std	Z+1, r24	; 0x01
    3fd4:	e9 81       	ldd	r30, Y+1	; 0x01
    3fd6:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd8:	21 81       	ldd	r18, Z+1	; 0x01
    3fda:	32 81       	ldd	r19, Z+2	; 0x02
    3fdc:	89 81       	ldd	r24, Y+1	; 0x01
    3fde:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe0:	03 96       	adiw	r24, 0x03	; 3
    3fe2:	28 17       	cp	r18, r24
    3fe4:	39 07       	cpc	r19, r25
    3fe6:	59 f4       	brne	.+22     	; 0x3ffe <vTaskSwitchContext+0xac>
    3fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fea:	fa 81       	ldd	r31, Y+2	; 0x02
    3fec:	01 80       	ldd	r0, Z+1	; 0x01
    3fee:	f2 81       	ldd	r31, Z+2	; 0x02
    3ff0:	e0 2d       	mov	r30, r0
    3ff2:	82 81       	ldd	r24, Z+2	; 0x02
    3ff4:	93 81       	ldd	r25, Z+3	; 0x03
    3ff6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ff8:	fa 81       	ldd	r31, Y+2	; 0x02
    3ffa:	92 83       	std	Z+2, r25	; 0x02
    3ffc:	81 83       	std	Z+1, r24	; 0x01
    3ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    4000:	fa 81       	ldd	r31, Y+2	; 0x02
    4002:	01 80       	ldd	r0, Z+1	; 0x01
    4004:	f2 81       	ldd	r31, Z+2	; 0x02
    4006:	e0 2d       	mov	r30, r0
    4008:	86 81       	ldd	r24, Z+6	; 0x06
    400a:	97 81       	ldd	r25, Z+7	; 0x07
    400c:	90 93 6f 05 	sts	0x056F, r25
    4010:	80 93 6e 05 	sts	0x056E, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    4014:	0f 90       	pop	r0
    4016:	0f 90       	pop	r0
    4018:	cf 91       	pop	r28
    401a:	df 91       	pop	r29
    401c:	08 95       	ret

0000401e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    401e:	df 93       	push	r29
    4020:	cf 93       	push	r28
    4022:	00 d0       	rcall	.+0      	; 0x4024 <vTaskPlaceOnEventList+0x6>
    4024:	00 d0       	rcall	.+0      	; 0x4026 <vTaskPlaceOnEventList+0x8>
    4026:	00 d0       	rcall	.+0      	; 0x4028 <vTaskPlaceOnEventList+0xa>
    4028:	cd b7       	in	r28, 0x3d	; 61
    402a:	de b7       	in	r29, 0x3e	; 62
    402c:	9c 83       	std	Y+4, r25	; 0x04
    402e:	8b 83       	std	Y+3, r24	; 0x03
    4030:	7e 83       	std	Y+6, r23	; 0x06
    4032:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4034:	4b 81       	ldd	r20, Y+3	; 0x03
    4036:	5c 81       	ldd	r21, Y+4	; 0x04
    4038:	80 91 6e 05 	lds	r24, 0x056E
    403c:	90 91 6f 05 	lds	r25, 0x056F
    4040:	9c 01       	movw	r18, r24
    4042:	24 5f       	subi	r18, 0xF4	; 244
    4044:	3f 4f       	sbci	r19, 0xFF	; 255
    4046:	ca 01       	movw	r24, r20
    4048:	b9 01       	movw	r22, r18
    404a:	0e 94 4a 13 	call	0x2694	; 0x2694 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    404e:	80 91 6e 05 	lds	r24, 0x056E
    4052:	90 91 6f 05 	lds	r25, 0x056F
    4056:	02 96       	adiw	r24, 0x02	; 2
    4058:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    405c:	20 91 72 05 	lds	r18, 0x0572
    4060:	30 91 73 05 	lds	r19, 0x0573
    4064:	8d 81       	ldd	r24, Y+5	; 0x05
    4066:	9e 81       	ldd	r25, Y+6	; 0x06
    4068:	82 0f       	add	r24, r18
    406a:	93 1f       	adc	r25, r19
    406c:	9a 83       	std	Y+2, r25	; 0x02
    406e:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4070:	89 81       	ldd	r24, Y+1	; 0x01
    4072:	9a 81       	ldd	r25, Y+2	; 0x02
    4074:	0e 94 09 22 	call	0x4412	; 0x4412 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    4078:	26 96       	adiw	r28, 0x06	; 6
    407a:	0f b6       	in	r0, 0x3f	; 63
    407c:	f8 94       	cli
    407e:	de bf       	out	0x3e, r29	; 62
    4080:	0f be       	out	0x3f, r0	; 63
    4082:	cd bf       	out	0x3d, r28	; 61
    4084:	cf 91       	pop	r28
    4086:	df 91       	pop	r29
    4088:	08 95       	ret

0000408a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    408a:	df 93       	push	r29
    408c:	cf 93       	push	r28
    408e:	00 d0       	rcall	.+0      	; 0x4090 <xTaskRemoveFromEventList+0x6>
    4090:	00 d0       	rcall	.+0      	; 0x4092 <xTaskRemoveFromEventList+0x8>
    4092:	0f 92       	push	r0
    4094:	cd b7       	in	r28, 0x3d	; 61
    4096:	de b7       	in	r29, 0x3e	; 62
    4098:	9d 83       	std	Y+5, r25	; 0x05
    409a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    409c:	ec 81       	ldd	r30, Y+4	; 0x04
    409e:	fd 81       	ldd	r31, Y+5	; 0x05
    40a0:	05 80       	ldd	r0, Z+5	; 0x05
    40a2:	f6 81       	ldd	r31, Z+6	; 0x06
    40a4:	e0 2d       	mov	r30, r0
    40a6:	86 81       	ldd	r24, Z+6	; 0x06
    40a8:	97 81       	ldd	r25, Z+7	; 0x07
    40aa:	9b 83       	std	Y+3, r25	; 0x03
    40ac:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    40ae:	8a 81       	ldd	r24, Y+2	; 0x02
    40b0:	9b 81       	ldd	r25, Y+3	; 0x03
    40b2:	0c 96       	adiw	r24, 0x0c	; 12
    40b4:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    40b8:	80 91 77 05 	lds	r24, 0x0577
    40bc:	88 23       	and	r24, r24
    40be:	61 f5       	brne	.+88     	; 0x4118 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    40c0:	8a 81       	ldd	r24, Y+2	; 0x02
    40c2:	9b 81       	ldd	r25, Y+3	; 0x03
    40c4:	02 96       	adiw	r24, 0x02	; 2
    40c6:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    40ca:	ea 81       	ldd	r30, Y+2	; 0x02
    40cc:	fb 81       	ldd	r31, Y+3	; 0x03
    40ce:	96 89       	ldd	r25, Z+22	; 0x16
    40d0:	80 91 75 05 	lds	r24, 0x0575
    40d4:	89 17       	cp	r24, r25
    40d6:	28 f4       	brcc	.+10     	; 0x40e2 <xTaskRemoveFromEventList+0x58>
    40d8:	ea 81       	ldd	r30, Y+2	; 0x02
    40da:	fb 81       	ldd	r31, Y+3	; 0x03
    40dc:	86 89       	ldd	r24, Z+22	; 0x16
    40de:	80 93 75 05 	sts	0x0575, r24
    40e2:	ea 81       	ldd	r30, Y+2	; 0x02
    40e4:	fb 81       	ldd	r31, Y+3	; 0x03
    40e6:	86 89       	ldd	r24, Z+22	; 0x16
    40e8:	28 2f       	mov	r18, r24
    40ea:	30 e0       	ldi	r19, 0x00	; 0
    40ec:	c9 01       	movw	r24, r18
    40ee:	88 0f       	add	r24, r24
    40f0:	99 1f       	adc	r25, r25
    40f2:	88 0f       	add	r24, r24
    40f4:	99 1f       	adc	r25, r25
    40f6:	88 0f       	add	r24, r24
    40f8:	99 1f       	adc	r25, r25
    40fa:	82 0f       	add	r24, r18
    40fc:	93 1f       	adc	r25, r19
    40fe:	ac 01       	movw	r20, r24
    4100:	44 58       	subi	r20, 0x84	; 132
    4102:	5a 4f       	sbci	r21, 0xFA	; 250
    4104:	8a 81       	ldd	r24, Y+2	; 0x02
    4106:	9b 81       	ldd	r25, Y+3	; 0x03
    4108:	9c 01       	movw	r18, r24
    410a:	2e 5f       	subi	r18, 0xFE	; 254
    410c:	3f 4f       	sbci	r19, 0xFF	; 255
    410e:	ca 01       	movw	r24, r20
    4110:	b9 01       	movw	r22, r18
    4112:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>
    4116:	0a c0       	rjmp	.+20     	; 0x412c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4118:	8a 81       	ldd	r24, Y+2	; 0x02
    411a:	9b 81       	ldd	r25, Y+3	; 0x03
    411c:	9c 01       	movw	r18, r24
    411e:	24 5f       	subi	r18, 0xF4	; 244
    4120:	3f 4f       	sbci	r19, 0xFF	; 255
    4122:	81 ed       	ldi	r24, 0xD1	; 209
    4124:	95 e0       	ldi	r25, 0x05	; 5
    4126:	b9 01       	movw	r22, r18
    4128:	0e 94 fe 12 	call	0x25fc	; 0x25fc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    412c:	ea 81       	ldd	r30, Y+2	; 0x02
    412e:	fb 81       	ldd	r31, Y+3	; 0x03
    4130:	96 89       	ldd	r25, Z+22	; 0x16
    4132:	e0 91 6e 05 	lds	r30, 0x056E
    4136:	f0 91 6f 05 	lds	r31, 0x056F
    413a:	86 89       	ldd	r24, Z+22	; 0x16
    413c:	98 17       	cp	r25, r24
    413e:	18 f0       	brcs	.+6      	; 0x4146 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4140:	81 e0       	ldi	r24, 0x01	; 1
    4142:	89 83       	std	Y+1, r24	; 0x01
    4144:	01 c0       	rjmp	.+2      	; 0x4148 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    4146:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4148:	89 81       	ldd	r24, Y+1	; 0x01
}
    414a:	0f 90       	pop	r0
    414c:	0f 90       	pop	r0
    414e:	0f 90       	pop	r0
    4150:	0f 90       	pop	r0
    4152:	0f 90       	pop	r0
    4154:	cf 91       	pop	r28
    4156:	df 91       	pop	r29
    4158:	08 95       	ret

0000415a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    415a:	df 93       	push	r29
    415c:	cf 93       	push	r28
    415e:	00 d0       	rcall	.+0      	; 0x4160 <vTaskSetTimeOutState+0x6>
    4160:	cd b7       	in	r28, 0x3d	; 61
    4162:	de b7       	in	r29, 0x3e	; 62
    4164:	9a 83       	std	Y+2, r25	; 0x02
    4166:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4168:	80 91 7a 05 	lds	r24, 0x057A
    416c:	e9 81       	ldd	r30, Y+1	; 0x01
    416e:	fa 81       	ldd	r31, Y+2	; 0x02
    4170:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4172:	80 91 72 05 	lds	r24, 0x0572
    4176:	90 91 73 05 	lds	r25, 0x0573
    417a:	e9 81       	ldd	r30, Y+1	; 0x01
    417c:	fa 81       	ldd	r31, Y+2	; 0x02
    417e:	92 83       	std	Z+2, r25	; 0x02
    4180:	81 83       	std	Z+1, r24	; 0x01
}
    4182:	0f 90       	pop	r0
    4184:	0f 90       	pop	r0
    4186:	cf 91       	pop	r28
    4188:	df 91       	pop	r29
    418a:	08 95       	ret

0000418c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    418c:	df 93       	push	r29
    418e:	cf 93       	push	r28
    4190:	00 d0       	rcall	.+0      	; 0x4192 <xTaskCheckForTimeOut+0x6>
    4192:	00 d0       	rcall	.+0      	; 0x4194 <xTaskCheckForTimeOut+0x8>
    4194:	0f 92       	push	r0
    4196:	cd b7       	in	r28, 0x3d	; 61
    4198:	de b7       	in	r29, 0x3e	; 62
    419a:	9b 83       	std	Y+3, r25	; 0x03
    419c:	8a 83       	std	Y+2, r24	; 0x02
    419e:	7d 83       	std	Y+5, r23	; 0x05
    41a0:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    41a2:	0f b6       	in	r0, 0x3f	; 63
    41a4:	f8 94       	cli
    41a6:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    41a8:	ea 81       	ldd	r30, Y+2	; 0x02
    41aa:	fb 81       	ldd	r31, Y+3	; 0x03
    41ac:	90 81       	ld	r25, Z
    41ae:	80 91 7a 05 	lds	r24, 0x057A
    41b2:	98 17       	cp	r25, r24
    41b4:	71 f0       	breq	.+28     	; 0x41d2 <xTaskCheckForTimeOut+0x46>
    41b6:	ea 81       	ldd	r30, Y+2	; 0x02
    41b8:	fb 81       	ldd	r31, Y+3	; 0x03
    41ba:	21 81       	ldd	r18, Z+1	; 0x01
    41bc:	32 81       	ldd	r19, Z+2	; 0x02
    41be:	80 91 72 05 	lds	r24, 0x0572
    41c2:	90 91 73 05 	lds	r25, 0x0573
    41c6:	82 17       	cp	r24, r18
    41c8:	93 07       	cpc	r25, r19
    41ca:	18 f0       	brcs	.+6      	; 0x41d2 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    41cc:	81 e0       	ldi	r24, 0x01	; 1
    41ce:	89 83       	std	Y+1, r24	; 0x01
    41d0:	2f c0       	rjmp	.+94     	; 0x4230 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    41d2:	20 91 72 05 	lds	r18, 0x0572
    41d6:	30 91 73 05 	lds	r19, 0x0573
    41da:	ea 81       	ldd	r30, Y+2	; 0x02
    41dc:	fb 81       	ldd	r31, Y+3	; 0x03
    41de:	81 81       	ldd	r24, Z+1	; 0x01
    41e0:	92 81       	ldd	r25, Z+2	; 0x02
    41e2:	28 1b       	sub	r18, r24
    41e4:	39 0b       	sbc	r19, r25
    41e6:	ec 81       	ldd	r30, Y+4	; 0x04
    41e8:	fd 81       	ldd	r31, Y+5	; 0x05
    41ea:	80 81       	ld	r24, Z
    41ec:	91 81       	ldd	r25, Z+1	; 0x01
    41ee:	28 17       	cp	r18, r24
    41f0:	39 07       	cpc	r19, r25
    41f2:	e0 f4       	brcc	.+56     	; 0x422c <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    41f4:	ec 81       	ldd	r30, Y+4	; 0x04
    41f6:	fd 81       	ldd	r31, Y+5	; 0x05
    41f8:	40 81       	ld	r20, Z
    41fa:	51 81       	ldd	r21, Z+1	; 0x01
    41fc:	ea 81       	ldd	r30, Y+2	; 0x02
    41fe:	fb 81       	ldd	r31, Y+3	; 0x03
    4200:	21 81       	ldd	r18, Z+1	; 0x01
    4202:	32 81       	ldd	r19, Z+2	; 0x02
    4204:	80 91 72 05 	lds	r24, 0x0572
    4208:	90 91 73 05 	lds	r25, 0x0573
    420c:	b9 01       	movw	r22, r18
    420e:	68 1b       	sub	r22, r24
    4210:	79 0b       	sbc	r23, r25
    4212:	cb 01       	movw	r24, r22
    4214:	84 0f       	add	r24, r20
    4216:	95 1f       	adc	r25, r21
    4218:	ec 81       	ldd	r30, Y+4	; 0x04
    421a:	fd 81       	ldd	r31, Y+5	; 0x05
    421c:	91 83       	std	Z+1, r25	; 0x01
    421e:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4220:	8a 81       	ldd	r24, Y+2	; 0x02
    4222:	9b 81       	ldd	r25, Y+3	; 0x03
    4224:	0e 94 ad 20 	call	0x415a	; 0x415a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4228:	19 82       	std	Y+1, r1	; 0x01
    422a:	02 c0       	rjmp	.+4      	; 0x4230 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    422c:	81 e0       	ldi	r24, 0x01	; 1
    422e:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4230:	0f 90       	pop	r0
    4232:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4234:	89 81       	ldd	r24, Y+1	; 0x01
}
    4236:	0f 90       	pop	r0
    4238:	0f 90       	pop	r0
    423a:	0f 90       	pop	r0
    423c:	0f 90       	pop	r0
    423e:	0f 90       	pop	r0
    4240:	cf 91       	pop	r28
    4242:	df 91       	pop	r29
    4244:	08 95       	ret

00004246 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4246:	df 93       	push	r29
    4248:	cf 93       	push	r28
    424a:	cd b7       	in	r28, 0x3d	; 61
    424c:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    424e:	81 e0       	ldi	r24, 0x01	; 1
    4250:	80 93 79 05 	sts	0x0579, r24
}
    4254:	cf 91       	pop	r28
    4256:	df 91       	pop	r29
    4258:	08 95       	ret

0000425a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    425a:	df 93       	push	r29
    425c:	cf 93       	push	r28
    425e:	00 d0       	rcall	.+0      	; 0x4260 <prvIdleTask+0x6>
    4260:	cd b7       	in	r28, 0x3d	; 61
    4262:	de b7       	in	r29, 0x3e	; 62
    4264:	9a 83       	std	Y+2, r25	; 0x02
    4266:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4268:	0e 94 cb 21 	call	0x4396	; 0x4396 <prvCheckTasksWaitingTermination>
    426c:	fd cf       	rjmp	.-6      	; 0x4268 <prvIdleTask+0xe>

0000426e <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    426e:	0f 93       	push	r16
    4270:	1f 93       	push	r17
    4272:	df 93       	push	r29
    4274:	cf 93       	push	r28
    4276:	cd b7       	in	r28, 0x3d	; 61
    4278:	de b7       	in	r29, 0x3e	; 62
    427a:	29 97       	sbiw	r28, 0x09	; 9
    427c:	0f b6       	in	r0, 0x3f	; 63
    427e:	f8 94       	cli
    4280:	de bf       	out	0x3e, r29	; 62
    4282:	0f be       	out	0x3f, r0	; 63
    4284:	cd bf       	out	0x3d, r28	; 61
    4286:	9a 83       	std	Y+2, r25	; 0x02
    4288:	89 83       	std	Y+1, r24	; 0x01
    428a:	7c 83       	std	Y+4, r23	; 0x04
    428c:	6b 83       	std	Y+3, r22	; 0x03
    428e:	4d 83       	std	Y+5, r20	; 0x05
    4290:	3f 83       	std	Y+7, r19	; 0x07
    4292:	2e 83       	std	Y+6, r18	; 0x06
    4294:	19 87       	std	Y+9, r17	; 0x09
    4296:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4298:	89 81       	ldd	r24, Y+1	; 0x01
    429a:	9a 81       	ldd	r25, Y+2	; 0x02
    429c:	49 96       	adiw	r24, 0x19	; 25
    429e:	2b 81       	ldd	r18, Y+3	; 0x03
    42a0:	3c 81       	ldd	r19, Y+4	; 0x04
    42a2:	b9 01       	movw	r22, r18
    42a4:	48 e0       	ldi	r20, 0x08	; 8
    42a6:	50 e0       	ldi	r21, 0x00	; 0
    42a8:	0e 94 3c 23 	call	0x4678	; 0x4678 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    42ac:	e9 81       	ldd	r30, Y+1	; 0x01
    42ae:	fa 81       	ldd	r31, Y+2	; 0x02
    42b0:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    42b2:	8d 81       	ldd	r24, Y+5	; 0x05
    42b4:	87 30       	cpi	r24, 0x07	; 7
    42b6:	10 f0       	brcs	.+4      	; 0x42bc <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    42b8:	86 e0       	ldi	r24, 0x06	; 6
    42ba:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    42bc:	e9 81       	ldd	r30, Y+1	; 0x01
    42be:	fa 81       	ldd	r31, Y+2	; 0x02
    42c0:	8d 81       	ldd	r24, Y+5	; 0x05
    42c2:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    42c4:	89 81       	ldd	r24, Y+1	; 0x01
    42c6:	9a 81       	ldd	r25, Y+2	; 0x02
    42c8:	02 96       	adiw	r24, 0x02	; 2
    42ca:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    42ce:	89 81       	ldd	r24, Y+1	; 0x01
    42d0:	9a 81       	ldd	r25, Y+2	; 0x02
    42d2:	0c 96       	adiw	r24, 0x0c	; 12
    42d4:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    42d8:	e9 81       	ldd	r30, Y+1	; 0x01
    42da:	fa 81       	ldd	r31, Y+2	; 0x02
    42dc:	89 81       	ldd	r24, Y+1	; 0x01
    42de:	9a 81       	ldd	r25, Y+2	; 0x02
    42e0:	91 87       	std	Z+9, r25	; 0x09
    42e2:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    42e4:	8d 81       	ldd	r24, Y+5	; 0x05
    42e6:	28 2f       	mov	r18, r24
    42e8:	30 e0       	ldi	r19, 0x00	; 0
    42ea:	87 e0       	ldi	r24, 0x07	; 7
    42ec:	90 e0       	ldi	r25, 0x00	; 0
    42ee:	82 1b       	sub	r24, r18
    42f0:	93 0b       	sbc	r25, r19
    42f2:	e9 81       	ldd	r30, Y+1	; 0x01
    42f4:	fa 81       	ldd	r31, Y+2	; 0x02
    42f6:	95 87       	std	Z+13, r25	; 0x0d
    42f8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    42fa:	e9 81       	ldd	r30, Y+1	; 0x01
    42fc:	fa 81       	ldd	r31, Y+2	; 0x02
    42fe:	89 81       	ldd	r24, Y+1	; 0x01
    4300:	9a 81       	ldd	r25, Y+2	; 0x02
    4302:	93 8b       	std	Z+19, r25	; 0x13
    4304:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4306:	29 96       	adiw	r28, 0x09	; 9
    4308:	0f b6       	in	r0, 0x3f	; 63
    430a:	f8 94       	cli
    430c:	de bf       	out	0x3e, r29	; 62
    430e:	0f be       	out	0x3f, r0	; 63
    4310:	cd bf       	out	0x3d, r28	; 61
    4312:	cf 91       	pop	r28
    4314:	df 91       	pop	r29
    4316:	1f 91       	pop	r17
    4318:	0f 91       	pop	r16
    431a:	08 95       	ret

0000431c <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    431c:	df 93       	push	r29
    431e:	cf 93       	push	r28
    4320:	0f 92       	push	r0
    4322:	cd b7       	in	r28, 0x3d	; 61
    4324:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4326:	19 82       	std	Y+1, r1	; 0x01
    4328:	13 c0       	rjmp	.+38     	; 0x4350 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    432a:	89 81       	ldd	r24, Y+1	; 0x01
    432c:	28 2f       	mov	r18, r24
    432e:	30 e0       	ldi	r19, 0x00	; 0
    4330:	c9 01       	movw	r24, r18
    4332:	88 0f       	add	r24, r24
    4334:	99 1f       	adc	r25, r25
    4336:	88 0f       	add	r24, r24
    4338:	99 1f       	adc	r25, r25
    433a:	88 0f       	add	r24, r24
    433c:	99 1f       	adc	r25, r25
    433e:	82 0f       	add	r24, r18
    4340:	93 1f       	adc	r25, r19
    4342:	84 58       	subi	r24, 0x84	; 132
    4344:	9a 4f       	sbci	r25, 0xFA	; 250
    4346:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    434a:	89 81       	ldd	r24, Y+1	; 0x01
    434c:	8f 5f       	subi	r24, 0xFF	; 255
    434e:	89 83       	std	Y+1, r24	; 0x01
    4350:	89 81       	ldd	r24, Y+1	; 0x01
    4352:	87 30       	cpi	r24, 0x07	; 7
    4354:	50 f3       	brcs	.-44     	; 0x432a <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4356:	8b eb       	ldi	r24, 0xBB	; 187
    4358:	95 e0       	ldi	r25, 0x05	; 5
    435a:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    435e:	84 ec       	ldi	r24, 0xC4	; 196
    4360:	95 e0       	ldi	r25, 0x05	; 5
    4362:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4366:	81 ed       	ldi	r24, 0xD1	; 209
    4368:	95 e0       	ldi	r25, 0x05	; 5
    436a:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    436e:	8a ed       	ldi	r24, 0xDA	; 218
    4370:	95 e0       	ldi	r25, 0x05	; 5
    4372:	0e 94 c4 12 	call	0x2588	; 0x2588 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4376:	8b eb       	ldi	r24, 0xBB	; 187
    4378:	95 e0       	ldi	r25, 0x05	; 5
    437a:	90 93 ce 05 	sts	0x05CE, r25
    437e:	80 93 cd 05 	sts	0x05CD, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4382:	84 ec       	ldi	r24, 0xC4	; 196
    4384:	95 e0       	ldi	r25, 0x05	; 5
    4386:	90 93 d0 05 	sts	0x05D0, r25
    438a:	80 93 cf 05 	sts	0x05CF, r24
}
    438e:	0f 90       	pop	r0
    4390:	cf 91       	pop	r28
    4392:	df 91       	pop	r29
    4394:	08 95       	ret

00004396 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4396:	df 93       	push	r29
    4398:	cf 93       	push	r28
    439a:	00 d0       	rcall	.+0      	; 0x439c <prvCheckTasksWaitingTermination+0x6>
    439c:	0f 92       	push	r0
    439e:	cd b7       	in	r28, 0x3d	; 61
    43a0:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    43a2:	80 91 70 05 	lds	r24, 0x0570
    43a6:	88 23       	and	r24, r24
    43a8:	71 f1       	breq	.+92     	; 0x4406 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    43aa:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    43ae:	80 91 da 05 	lds	r24, 0x05DA
    43b2:	1b 82       	std	Y+3, r1	; 0x03
    43b4:	88 23       	and	r24, r24
    43b6:	11 f4       	brne	.+4      	; 0x43bc <prvCheckTasksWaitingTermination+0x26>
    43b8:	81 e0       	ldi	r24, 0x01	; 1
    43ba:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    43bc:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    43c0:	8b 81       	ldd	r24, Y+3	; 0x03
    43c2:	88 23       	and	r24, r24
    43c4:	01 f5       	brne	.+64     	; 0x4406 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    43c6:	0f b6       	in	r0, 0x3f	; 63
    43c8:	f8 94       	cli
    43ca:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    43cc:	e0 91 df 05 	lds	r30, 0x05DF
    43d0:	f0 91 e0 05 	lds	r31, 0x05E0
    43d4:	86 81       	ldd	r24, Z+6	; 0x06
    43d6:	97 81       	ldd	r25, Z+7	; 0x07
    43d8:	9a 83       	std	Y+2, r25	; 0x02
    43da:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    43dc:	89 81       	ldd	r24, Y+1	; 0x01
    43de:	9a 81       	ldd	r25, Y+2	; 0x02
    43e0:	02 96       	adiw	r24, 0x02	; 2
    43e2:	0e 94 b6 13 	call	0x276c	; 0x276c <vListRemove>
					--uxCurrentNumberOfTasks;
    43e6:	80 91 71 05 	lds	r24, 0x0571
    43ea:	81 50       	subi	r24, 0x01	; 1
    43ec:	80 93 71 05 	sts	0x0571, r24
					--uxTasksDeleted;
    43f0:	80 91 70 05 	lds	r24, 0x0570
    43f4:	81 50       	subi	r24, 0x01	; 1
    43f6:	80 93 70 05 	sts	0x0570, r24
				}
				taskEXIT_CRITICAL();
    43fa:	0f 90       	pop	r0
    43fc:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    43fe:	89 81       	ldd	r24, Y+1	; 0x01
    4400:	9a 81       	ldd	r25, Y+2	; 0x02
    4402:	0e 94 a2 22 	call	0x4544	; 0x4544 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    4406:	0f 90       	pop	r0
    4408:	0f 90       	pop	r0
    440a:	0f 90       	pop	r0
    440c:	cf 91       	pop	r28
    440e:	df 91       	pop	r29
    4410:	08 95       	ret

00004412 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    4412:	df 93       	push	r29
    4414:	cf 93       	push	r28
    4416:	00 d0       	rcall	.+0      	; 0x4418 <prvAddCurrentTaskToDelayedList+0x6>
    4418:	cd b7       	in	r28, 0x3d	; 61
    441a:	de b7       	in	r29, 0x3e	; 62
    441c:	9a 83       	std	Y+2, r25	; 0x02
    441e:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4420:	e0 91 6e 05 	lds	r30, 0x056E
    4424:	f0 91 6f 05 	lds	r31, 0x056F
    4428:	89 81       	ldd	r24, Y+1	; 0x01
    442a:	9a 81       	ldd	r25, Y+2	; 0x02
    442c:	93 83       	std	Z+3, r25	; 0x03
    442e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4430:	20 91 72 05 	lds	r18, 0x0572
    4434:	30 91 73 05 	lds	r19, 0x0573
    4438:	89 81       	ldd	r24, Y+1	; 0x01
    443a:	9a 81       	ldd	r25, Y+2	; 0x02
    443c:	82 17       	cp	r24, r18
    443e:	93 07       	cpc	r25, r19
    4440:	70 f4       	brcc	.+28     	; 0x445e <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4442:	80 91 cf 05 	lds	r24, 0x05CF
    4446:	90 91 d0 05 	lds	r25, 0x05D0
    444a:	20 91 6e 05 	lds	r18, 0x056E
    444e:	30 91 6f 05 	lds	r19, 0x056F
    4452:	2e 5f       	subi	r18, 0xFE	; 254
    4454:	3f 4f       	sbci	r19, 0xFF	; 255
    4456:	b9 01       	movw	r22, r18
    4458:	0e 94 4a 13 	call	0x2694	; 0x2694 <vListInsert>
    445c:	1e c0       	rjmp	.+60     	; 0x449a <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    445e:	40 91 cd 05 	lds	r20, 0x05CD
    4462:	50 91 ce 05 	lds	r21, 0x05CE
    4466:	80 91 6e 05 	lds	r24, 0x056E
    446a:	90 91 6f 05 	lds	r25, 0x056F
    446e:	9c 01       	movw	r18, r24
    4470:	2e 5f       	subi	r18, 0xFE	; 254
    4472:	3f 4f       	sbci	r19, 0xFF	; 255
    4474:	ca 01       	movw	r24, r20
    4476:	b9 01       	movw	r22, r18
    4478:	0e 94 4a 13 	call	0x2694	; 0x2694 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    447c:	20 91 7f 00 	lds	r18, 0x007F
    4480:	30 91 80 00 	lds	r19, 0x0080
    4484:	89 81       	ldd	r24, Y+1	; 0x01
    4486:	9a 81       	ldd	r25, Y+2	; 0x02
    4488:	82 17       	cp	r24, r18
    448a:	93 07       	cpc	r25, r19
    448c:	30 f4       	brcc	.+12     	; 0x449a <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    448e:	89 81       	ldd	r24, Y+1	; 0x01
    4490:	9a 81       	ldd	r25, Y+2	; 0x02
    4492:	90 93 80 00 	sts	0x0080, r25
    4496:	80 93 7f 00 	sts	0x007F, r24
		}
	}
}
    449a:	0f 90       	pop	r0
    449c:	0f 90       	pop	r0
    449e:	cf 91       	pop	r28
    44a0:	df 91       	pop	r29
    44a2:	08 95       	ret

000044a4 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    44a4:	df 93       	push	r29
    44a6:	cf 93       	push	r28
    44a8:	cd b7       	in	r28, 0x3d	; 61
    44aa:	de b7       	in	r29, 0x3e	; 62
    44ac:	28 97       	sbiw	r28, 0x08	; 8
    44ae:	0f b6       	in	r0, 0x3f	; 63
    44b0:	f8 94       	cli
    44b2:	de bf       	out	0x3e, r29	; 62
    44b4:	0f be       	out	0x3f, r0	; 63
    44b6:	cd bf       	out	0x3d, r28	; 61
    44b8:	9c 83       	std	Y+4, r25	; 0x04
    44ba:	8b 83       	std	Y+3, r24	; 0x03
    44bc:	7e 83       	std	Y+6, r23	; 0x06
    44be:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    44c0:	81 e2       	ldi	r24, 0x21	; 33
    44c2:	90 e0       	ldi	r25, 0x00	; 0
    44c4:	0e 94 58 12 	call	0x24b0	; 0x24b0 <pvPortMalloc>
    44c8:	9a 83       	std	Y+2, r25	; 0x02
    44ca:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    44cc:	89 81       	ldd	r24, Y+1	; 0x01
    44ce:	9a 81       	ldd	r25, Y+2	; 0x02
    44d0:	00 97       	sbiw	r24, 0x00	; 0
    44d2:	69 f1       	breq	.+90     	; 0x452e <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    44d4:	8d 81       	ldd	r24, Y+5	; 0x05
    44d6:	9e 81       	ldd	r25, Y+6	; 0x06
    44d8:	00 97       	sbiw	r24, 0x00	; 0
    44da:	39 f4       	brne	.+14     	; 0x44ea <prvAllocateTCBAndStack+0x46>
    44dc:	8b 81       	ldd	r24, Y+3	; 0x03
    44de:	9c 81       	ldd	r25, Y+4	; 0x04
    44e0:	0e 94 58 12 	call	0x24b0	; 0x24b0 <pvPortMalloc>
    44e4:	98 87       	std	Y+8, r25	; 0x08
    44e6:	8f 83       	std	Y+7, r24	; 0x07
    44e8:	04 c0       	rjmp	.+8      	; 0x44f2 <prvAllocateTCBAndStack+0x4e>
    44ea:	8d 81       	ldd	r24, Y+5	; 0x05
    44ec:	9e 81       	ldd	r25, Y+6	; 0x06
    44ee:	98 87       	std	Y+8, r25	; 0x08
    44f0:	8f 83       	std	Y+7, r24	; 0x07
    44f2:	e9 81       	ldd	r30, Y+1	; 0x01
    44f4:	fa 81       	ldd	r31, Y+2	; 0x02
    44f6:	8f 81       	ldd	r24, Y+7	; 0x07
    44f8:	98 85       	ldd	r25, Y+8	; 0x08
    44fa:	90 8f       	std	Z+24, r25	; 0x18
    44fc:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    44fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4500:	fa 81       	ldd	r31, Y+2	; 0x02
    4502:	87 89       	ldd	r24, Z+23	; 0x17
    4504:	90 8d       	ldd	r25, Z+24	; 0x18
    4506:	00 97       	sbiw	r24, 0x00	; 0
    4508:	39 f4       	brne	.+14     	; 0x4518 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    450a:	89 81       	ldd	r24, Y+1	; 0x01
    450c:	9a 81       	ldd	r25, Y+2	; 0x02
    450e:	0e 94 9e 12 	call	0x253c	; 0x253c <vPortFree>
			pxNewTCB = NULL;
    4512:	1a 82       	std	Y+2, r1	; 0x02
    4514:	19 82       	std	Y+1, r1	; 0x01
    4516:	0b c0       	rjmp	.+22     	; 0x452e <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    4518:	e9 81       	ldd	r30, Y+1	; 0x01
    451a:	fa 81       	ldd	r31, Y+2	; 0x02
    451c:	87 89       	ldd	r24, Z+23	; 0x17
    451e:	90 8d       	ldd	r25, Z+24	; 0x18
    4520:	2b 81       	ldd	r18, Y+3	; 0x03
    4522:	3c 81       	ldd	r19, Y+4	; 0x04
    4524:	65 ea       	ldi	r22, 0xA5	; 165
    4526:	70 e0       	ldi	r23, 0x00	; 0
    4528:	a9 01       	movw	r20, r18
    452a:	0e 94 35 23 	call	0x466a	; 0x466a <memset>
		}
	}

	return pxNewTCB;
    452e:	89 81       	ldd	r24, Y+1	; 0x01
    4530:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4532:	28 96       	adiw	r28, 0x08	; 8
    4534:	0f b6       	in	r0, 0x3f	; 63
    4536:	f8 94       	cli
    4538:	de bf       	out	0x3e, r29	; 62
    453a:	0f be       	out	0x3f, r0	; 63
    453c:	cd bf       	out	0x3d, r28	; 61
    453e:	cf 91       	pop	r28
    4540:	df 91       	pop	r29
    4542:	08 95       	ret

00004544 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    4544:	df 93       	push	r29
    4546:	cf 93       	push	r28
    4548:	00 d0       	rcall	.+0      	; 0x454a <prvDeleteTCB+0x6>
    454a:	cd b7       	in	r28, 0x3d	; 61
    454c:	de b7       	in	r29, 0x3e	; 62
    454e:	9a 83       	std	Y+2, r25	; 0x02
    4550:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4552:	e9 81       	ldd	r30, Y+1	; 0x01
    4554:	fa 81       	ldd	r31, Y+2	; 0x02
    4556:	87 89       	ldd	r24, Z+23	; 0x17
    4558:	90 8d       	ldd	r25, Z+24	; 0x18
    455a:	0e 94 9e 12 	call	0x253c	; 0x253c <vPortFree>
		vPortFree( pxTCB );
    455e:	89 81       	ldd	r24, Y+1	; 0x01
    4560:	9a 81       	ldd	r25, Y+2	; 0x02
    4562:	0e 94 9e 12 	call	0x253c	; 0x253c <vPortFree>
	}
    4566:	0f 90       	pop	r0
    4568:	0f 90       	pop	r0
    456a:	cf 91       	pop	r28
    456c:	df 91       	pop	r29
    456e:	08 95       	ret

00004570 <__divmodsi4>:
    4570:	97 fb       	bst	r25, 7
    4572:	09 2e       	mov	r0, r25
    4574:	05 26       	eor	r0, r21
    4576:	0e d0       	rcall	.+28     	; 0x4594 <__divmodsi4_neg1>
    4578:	57 fd       	sbrc	r21, 7
    457a:	04 d0       	rcall	.+8      	; 0x4584 <__divmodsi4_neg2>
    457c:	14 d0       	rcall	.+40     	; 0x45a6 <__udivmodsi4>
    457e:	0a d0       	rcall	.+20     	; 0x4594 <__divmodsi4_neg1>
    4580:	00 1c       	adc	r0, r0
    4582:	38 f4       	brcc	.+14     	; 0x4592 <__divmodsi4_exit>

00004584 <__divmodsi4_neg2>:
    4584:	50 95       	com	r21
    4586:	40 95       	com	r20
    4588:	30 95       	com	r19
    458a:	21 95       	neg	r18
    458c:	3f 4f       	sbci	r19, 0xFF	; 255
    458e:	4f 4f       	sbci	r20, 0xFF	; 255
    4590:	5f 4f       	sbci	r21, 0xFF	; 255

00004592 <__divmodsi4_exit>:
    4592:	08 95       	ret

00004594 <__divmodsi4_neg1>:
    4594:	f6 f7       	brtc	.-4      	; 0x4592 <__divmodsi4_exit>
    4596:	90 95       	com	r25
    4598:	80 95       	com	r24
    459a:	70 95       	com	r23
    459c:	61 95       	neg	r22
    459e:	7f 4f       	sbci	r23, 0xFF	; 255
    45a0:	8f 4f       	sbci	r24, 0xFF	; 255
    45a2:	9f 4f       	sbci	r25, 0xFF	; 255
    45a4:	08 95       	ret

000045a6 <__udivmodsi4>:
    45a6:	a1 e2       	ldi	r26, 0x21	; 33
    45a8:	1a 2e       	mov	r1, r26
    45aa:	aa 1b       	sub	r26, r26
    45ac:	bb 1b       	sub	r27, r27
    45ae:	fd 01       	movw	r30, r26
    45b0:	0d c0       	rjmp	.+26     	; 0x45cc <__udivmodsi4_ep>

000045b2 <__udivmodsi4_loop>:
    45b2:	aa 1f       	adc	r26, r26
    45b4:	bb 1f       	adc	r27, r27
    45b6:	ee 1f       	adc	r30, r30
    45b8:	ff 1f       	adc	r31, r31
    45ba:	a2 17       	cp	r26, r18
    45bc:	b3 07       	cpc	r27, r19
    45be:	e4 07       	cpc	r30, r20
    45c0:	f5 07       	cpc	r31, r21
    45c2:	20 f0       	brcs	.+8      	; 0x45cc <__udivmodsi4_ep>
    45c4:	a2 1b       	sub	r26, r18
    45c6:	b3 0b       	sbc	r27, r19
    45c8:	e4 0b       	sbc	r30, r20
    45ca:	f5 0b       	sbc	r31, r21

000045cc <__udivmodsi4_ep>:
    45cc:	66 1f       	adc	r22, r22
    45ce:	77 1f       	adc	r23, r23
    45d0:	88 1f       	adc	r24, r24
    45d2:	99 1f       	adc	r25, r25
    45d4:	1a 94       	dec	r1
    45d6:	69 f7       	brne	.-38     	; 0x45b2 <__udivmodsi4_loop>
    45d8:	60 95       	com	r22
    45da:	70 95       	com	r23
    45dc:	80 95       	com	r24
    45de:	90 95       	com	r25
    45e0:	9b 01       	movw	r18, r22
    45e2:	ac 01       	movw	r20, r24
    45e4:	bd 01       	movw	r22, r26
    45e6:	cf 01       	movw	r24, r30
    45e8:	08 95       	ret

000045ea <__prologue_saves__>:
    45ea:	2f 92       	push	r2
    45ec:	3f 92       	push	r3
    45ee:	4f 92       	push	r4
    45f0:	5f 92       	push	r5
    45f2:	6f 92       	push	r6
    45f4:	7f 92       	push	r7
    45f6:	8f 92       	push	r8
    45f8:	9f 92       	push	r9
    45fa:	af 92       	push	r10
    45fc:	bf 92       	push	r11
    45fe:	cf 92       	push	r12
    4600:	df 92       	push	r13
    4602:	ef 92       	push	r14
    4604:	ff 92       	push	r15
    4606:	0f 93       	push	r16
    4608:	1f 93       	push	r17
    460a:	cf 93       	push	r28
    460c:	df 93       	push	r29
    460e:	cd b7       	in	r28, 0x3d	; 61
    4610:	de b7       	in	r29, 0x3e	; 62
    4612:	ca 1b       	sub	r28, r26
    4614:	db 0b       	sbc	r29, r27
    4616:	0f b6       	in	r0, 0x3f	; 63
    4618:	f8 94       	cli
    461a:	de bf       	out	0x3e, r29	; 62
    461c:	0f be       	out	0x3f, r0	; 63
    461e:	cd bf       	out	0x3d, r28	; 61
    4620:	09 94       	ijmp

00004622 <__epilogue_restores__>:
    4622:	2a 88       	ldd	r2, Y+18	; 0x12
    4624:	39 88       	ldd	r3, Y+17	; 0x11
    4626:	48 88       	ldd	r4, Y+16	; 0x10
    4628:	5f 84       	ldd	r5, Y+15	; 0x0f
    462a:	6e 84       	ldd	r6, Y+14	; 0x0e
    462c:	7d 84       	ldd	r7, Y+13	; 0x0d
    462e:	8c 84       	ldd	r8, Y+12	; 0x0c
    4630:	9b 84       	ldd	r9, Y+11	; 0x0b
    4632:	aa 84       	ldd	r10, Y+10	; 0x0a
    4634:	b9 84       	ldd	r11, Y+9	; 0x09
    4636:	c8 84       	ldd	r12, Y+8	; 0x08
    4638:	df 80       	ldd	r13, Y+7	; 0x07
    463a:	ee 80       	ldd	r14, Y+6	; 0x06
    463c:	fd 80       	ldd	r15, Y+5	; 0x05
    463e:	0c 81       	ldd	r16, Y+4	; 0x04
    4640:	1b 81       	ldd	r17, Y+3	; 0x03
    4642:	aa 81       	ldd	r26, Y+2	; 0x02
    4644:	b9 81       	ldd	r27, Y+1	; 0x01
    4646:	ce 0f       	add	r28, r30
    4648:	d1 1d       	adc	r29, r1
    464a:	0f b6       	in	r0, 0x3f	; 63
    464c:	f8 94       	cli
    464e:	de bf       	out	0x3e, r29	; 62
    4650:	0f be       	out	0x3f, r0	; 63
    4652:	cd bf       	out	0x3d, r28	; 61
    4654:	ed 01       	movw	r28, r26
    4656:	08 95       	ret

00004658 <memcpy>:
    4658:	fb 01       	movw	r30, r22
    465a:	dc 01       	movw	r26, r24
    465c:	02 c0       	rjmp	.+4      	; 0x4662 <memcpy+0xa>
    465e:	01 90       	ld	r0, Z+
    4660:	0d 92       	st	X+, r0
    4662:	41 50       	subi	r20, 0x01	; 1
    4664:	50 40       	sbci	r21, 0x00	; 0
    4666:	d8 f7       	brcc	.-10     	; 0x465e <memcpy+0x6>
    4668:	08 95       	ret

0000466a <memset>:
    466a:	dc 01       	movw	r26, r24
    466c:	01 c0       	rjmp	.+2      	; 0x4670 <memset+0x6>
    466e:	6d 93       	st	X+, r22
    4670:	41 50       	subi	r20, 0x01	; 1
    4672:	50 40       	sbci	r21, 0x00	; 0
    4674:	e0 f7       	brcc	.-8      	; 0x466e <memset+0x4>
    4676:	08 95       	ret

00004678 <strncpy>:
    4678:	fb 01       	movw	r30, r22
    467a:	dc 01       	movw	r26, r24
    467c:	41 50       	subi	r20, 0x01	; 1
    467e:	50 40       	sbci	r21, 0x00	; 0
    4680:	48 f0       	brcs	.+18     	; 0x4694 <strncpy+0x1c>
    4682:	01 90       	ld	r0, Z+
    4684:	0d 92       	st	X+, r0
    4686:	00 20       	and	r0, r0
    4688:	c9 f7       	brne	.-14     	; 0x467c <strncpy+0x4>
    468a:	01 c0       	rjmp	.+2      	; 0x468e <strncpy+0x16>
    468c:	1d 92       	st	X+, r1
    468e:	41 50       	subi	r20, 0x01	; 1
    4690:	50 40       	sbci	r21, 0x00	; 0
    4692:	e0 f7       	brcc	.-8      	; 0x468c <strncpy+0x14>
    4694:	08 95       	ret

00004696 <_exit>:
    4696:	f8 94       	cli

00004698 <__stop_program>:
    4698:	ff cf       	rjmp	.-2      	; 0x4698 <__stop_program>
