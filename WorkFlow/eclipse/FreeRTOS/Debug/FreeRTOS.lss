
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002b8c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00002b8c  00002c20  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000047f  00800068  00800068  00002c28  2**0
                  ALLOC
  3 .stab         000049d4  00000000  00000000  00002c28  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002bd0  00000000  00000000  000075fc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 36 0a 	jmp	0x146c	; 0x146c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e8       	ldi	r30, 0x8C	; 140
      68:	fb e2       	ldi	r31, 0x2B	; 43
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 3e       	cpi	r26, 0xE7	; 231
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 2d 07 	call	0xe5a	; 0xe5a <main>
      8a:	0c 94 c4 15 	jmp	0x2b88	; 0x2b88 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_u8SetPinValue>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	28 97       	sbiw	r28, 0x08	; 8
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	8a 83       	std	Y+2, r24	; 0x02
      a8:	6b 83       	std	Y+3, r22	; 0x03
      aa:	4c 83       	std	Y+4, r20	; 0x04
      ac:	19 82       	std	Y+1, r1	; 0x01
      ae:	8b 81       	ldd	r24, Y+3	; 0x03
      b0:	88 30       	cpi	r24, 0x08	; 8
      b2:	08 f0       	brcs	.+2      	; 0xb6 <DIO_u8SetPinValue+0x24>
      b4:	f4 c0       	rjmp	.+488    	; 0x29e <DIO_u8SetPinValue+0x20c>
      b6:	8c 81       	ldd	r24, Y+4	; 0x04
      b8:	88 23       	and	r24, r24
      ba:	09 f0       	breq	.+2      	; 0xbe <DIO_u8SetPinValue+0x2c>
      bc:	77 c0       	rjmp	.+238    	; 0x1ac <DIO_u8SetPinValue+0x11a>
      be:	8a 81       	ldd	r24, Y+2	; 0x02
      c0:	28 2f       	mov	r18, r24
      c2:	30 e0       	ldi	r19, 0x00	; 0
      c4:	38 87       	std	Y+8, r19	; 0x08
      c6:	2f 83       	std	Y+7, r18	; 0x07
      c8:	8f 81       	ldd	r24, Y+7	; 0x07
      ca:	98 85       	ldd	r25, Y+8	; 0x08
      cc:	81 30       	cpi	r24, 0x01	; 1
      ce:	91 05       	cpc	r25, r1
      d0:	59 f1       	breq	.+86     	; 0x128 <DIO_u8SetPinValue+0x96>
      d2:	2f 81       	ldd	r18, Y+7	; 0x07
      d4:	38 85       	ldd	r19, Y+8	; 0x08
      d6:	22 30       	cpi	r18, 0x02	; 2
      d8:	31 05       	cpc	r19, r1
      da:	2c f4       	brge	.+10     	; 0xe6 <DIO_u8SetPinValue+0x54>
      dc:	8f 81       	ldd	r24, Y+7	; 0x07
      de:	98 85       	ldd	r25, Y+8	; 0x08
      e0:	00 97       	sbiw	r24, 0x00	; 0
      e2:	69 f0       	breq	.+26     	; 0xfe <DIO_u8SetPinValue+0x6c>
      e4:	60 c0       	rjmp	.+192    	; 0x1a6 <DIO_u8SetPinValue+0x114>
      e6:	2f 81       	ldd	r18, Y+7	; 0x07
      e8:	38 85       	ldd	r19, Y+8	; 0x08
      ea:	22 30       	cpi	r18, 0x02	; 2
      ec:	31 05       	cpc	r19, r1
      ee:	89 f1       	breq	.+98     	; 0x152 <DIO_u8SetPinValue+0xc0>
      f0:	8f 81       	ldd	r24, Y+7	; 0x07
      f2:	98 85       	ldd	r25, Y+8	; 0x08
      f4:	83 30       	cpi	r24, 0x03	; 3
      f6:	91 05       	cpc	r25, r1
      f8:	09 f4       	brne	.+2      	; 0xfc <DIO_u8SetPinValue+0x6a>
      fa:	40 c0       	rjmp	.+128    	; 0x17c <DIO_u8SetPinValue+0xea>
      fc:	54 c0       	rjmp	.+168    	; 0x1a6 <DIO_u8SetPinValue+0x114>
      fe:	ab e3       	ldi	r26, 0x3B	; 59
     100:	b0 e0       	ldi	r27, 0x00	; 0
     102:	eb e3       	ldi	r30, 0x3B	; 59
     104:	f0 e0       	ldi	r31, 0x00	; 0
     106:	80 81       	ld	r24, Z
     108:	48 2f       	mov	r20, r24
     10a:	8b 81       	ldd	r24, Y+3	; 0x03
     10c:	28 2f       	mov	r18, r24
     10e:	30 e0       	ldi	r19, 0x00	; 0
     110:	81 e0       	ldi	r24, 0x01	; 1
     112:	90 e0       	ldi	r25, 0x00	; 0
     114:	02 2e       	mov	r0, r18
     116:	02 c0       	rjmp	.+4      	; 0x11c <DIO_u8SetPinValue+0x8a>
     118:	88 0f       	add	r24, r24
     11a:	99 1f       	adc	r25, r25
     11c:	0a 94       	dec	r0
     11e:	e2 f7       	brpl	.-8      	; 0x118 <DIO_u8SetPinValue+0x86>
     120:	80 95       	com	r24
     122:	84 23       	and	r24, r20
     124:	8c 93       	st	X, r24
     126:	bd c0       	rjmp	.+378    	; 0x2a2 <DIO_u8SetPinValue+0x210>
     128:	a8 e3       	ldi	r26, 0x38	; 56
     12a:	b0 e0       	ldi	r27, 0x00	; 0
     12c:	e8 e3       	ldi	r30, 0x38	; 56
     12e:	f0 e0       	ldi	r31, 0x00	; 0
     130:	80 81       	ld	r24, Z
     132:	48 2f       	mov	r20, r24
     134:	8b 81       	ldd	r24, Y+3	; 0x03
     136:	28 2f       	mov	r18, r24
     138:	30 e0       	ldi	r19, 0x00	; 0
     13a:	81 e0       	ldi	r24, 0x01	; 1
     13c:	90 e0       	ldi	r25, 0x00	; 0
     13e:	02 2e       	mov	r0, r18
     140:	02 c0       	rjmp	.+4      	; 0x146 <DIO_u8SetPinValue+0xb4>
     142:	88 0f       	add	r24, r24
     144:	99 1f       	adc	r25, r25
     146:	0a 94       	dec	r0
     148:	e2 f7       	brpl	.-8      	; 0x142 <DIO_u8SetPinValue+0xb0>
     14a:	80 95       	com	r24
     14c:	84 23       	and	r24, r20
     14e:	8c 93       	st	X, r24
     150:	a8 c0       	rjmp	.+336    	; 0x2a2 <DIO_u8SetPinValue+0x210>
     152:	a5 e3       	ldi	r26, 0x35	; 53
     154:	b0 e0       	ldi	r27, 0x00	; 0
     156:	e5 e3       	ldi	r30, 0x35	; 53
     158:	f0 e0       	ldi	r31, 0x00	; 0
     15a:	80 81       	ld	r24, Z
     15c:	48 2f       	mov	r20, r24
     15e:	8b 81       	ldd	r24, Y+3	; 0x03
     160:	28 2f       	mov	r18, r24
     162:	30 e0       	ldi	r19, 0x00	; 0
     164:	81 e0       	ldi	r24, 0x01	; 1
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	02 2e       	mov	r0, r18
     16a:	02 c0       	rjmp	.+4      	; 0x170 <DIO_u8SetPinValue+0xde>
     16c:	88 0f       	add	r24, r24
     16e:	99 1f       	adc	r25, r25
     170:	0a 94       	dec	r0
     172:	e2 f7       	brpl	.-8      	; 0x16c <DIO_u8SetPinValue+0xda>
     174:	80 95       	com	r24
     176:	84 23       	and	r24, r20
     178:	8c 93       	st	X, r24
     17a:	93 c0       	rjmp	.+294    	; 0x2a2 <DIO_u8SetPinValue+0x210>
     17c:	a2 e3       	ldi	r26, 0x32	; 50
     17e:	b0 e0       	ldi	r27, 0x00	; 0
     180:	e2 e3       	ldi	r30, 0x32	; 50
     182:	f0 e0       	ldi	r31, 0x00	; 0
     184:	80 81       	ld	r24, Z
     186:	48 2f       	mov	r20, r24
     188:	8b 81       	ldd	r24, Y+3	; 0x03
     18a:	28 2f       	mov	r18, r24
     18c:	30 e0       	ldi	r19, 0x00	; 0
     18e:	81 e0       	ldi	r24, 0x01	; 1
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	02 2e       	mov	r0, r18
     194:	02 c0       	rjmp	.+4      	; 0x19a <DIO_u8SetPinValue+0x108>
     196:	88 0f       	add	r24, r24
     198:	99 1f       	adc	r25, r25
     19a:	0a 94       	dec	r0
     19c:	e2 f7       	brpl	.-8      	; 0x196 <DIO_u8SetPinValue+0x104>
     19e:	80 95       	com	r24
     1a0:	84 23       	and	r24, r20
     1a2:	8c 93       	st	X, r24
     1a4:	7e c0       	rjmp	.+252    	; 0x2a2 <DIO_u8SetPinValue+0x210>
     1a6:	81 e0       	ldi	r24, 0x01	; 1
     1a8:	89 83       	std	Y+1, r24	; 0x01
     1aa:	7b c0       	rjmp	.+246    	; 0x2a2 <DIO_u8SetPinValue+0x210>
     1ac:	8c 81       	ldd	r24, Y+4	; 0x04
     1ae:	81 30       	cpi	r24, 0x01	; 1
     1b0:	09 f0       	breq	.+2      	; 0x1b4 <DIO_u8SetPinValue+0x122>
     1b2:	72 c0       	rjmp	.+228    	; 0x298 <DIO_u8SetPinValue+0x206>
     1b4:	8a 81       	ldd	r24, Y+2	; 0x02
     1b6:	28 2f       	mov	r18, r24
     1b8:	30 e0       	ldi	r19, 0x00	; 0
     1ba:	3e 83       	std	Y+6, r19	; 0x06
     1bc:	2d 83       	std	Y+5, r18	; 0x05
     1be:	8d 81       	ldd	r24, Y+5	; 0x05
     1c0:	9e 81       	ldd	r25, Y+6	; 0x06
     1c2:	81 30       	cpi	r24, 0x01	; 1
     1c4:	91 05       	cpc	r25, r1
     1c6:	49 f1       	breq	.+82     	; 0x21a <DIO_u8SetPinValue+0x188>
     1c8:	2d 81       	ldd	r18, Y+5	; 0x05
     1ca:	3e 81       	ldd	r19, Y+6	; 0x06
     1cc:	22 30       	cpi	r18, 0x02	; 2
     1ce:	31 05       	cpc	r19, r1
     1d0:	2c f4       	brge	.+10     	; 0x1dc <DIO_u8SetPinValue+0x14a>
     1d2:	8d 81       	ldd	r24, Y+5	; 0x05
     1d4:	9e 81       	ldd	r25, Y+6	; 0x06
     1d6:	00 97       	sbiw	r24, 0x00	; 0
     1d8:	61 f0       	breq	.+24     	; 0x1f2 <DIO_u8SetPinValue+0x160>
     1da:	5b c0       	rjmp	.+182    	; 0x292 <DIO_u8SetPinValue+0x200>
     1dc:	2d 81       	ldd	r18, Y+5	; 0x05
     1de:	3e 81       	ldd	r19, Y+6	; 0x06
     1e0:	22 30       	cpi	r18, 0x02	; 2
     1e2:	31 05       	cpc	r19, r1
     1e4:	71 f1       	breq	.+92     	; 0x242 <DIO_u8SetPinValue+0x1b0>
     1e6:	8d 81       	ldd	r24, Y+5	; 0x05
     1e8:	9e 81       	ldd	r25, Y+6	; 0x06
     1ea:	83 30       	cpi	r24, 0x03	; 3
     1ec:	91 05       	cpc	r25, r1
     1ee:	e9 f1       	breq	.+122    	; 0x26a <DIO_u8SetPinValue+0x1d8>
     1f0:	50 c0       	rjmp	.+160    	; 0x292 <DIO_u8SetPinValue+0x200>
     1f2:	ab e3       	ldi	r26, 0x3B	; 59
     1f4:	b0 e0       	ldi	r27, 0x00	; 0
     1f6:	eb e3       	ldi	r30, 0x3B	; 59
     1f8:	f0 e0       	ldi	r31, 0x00	; 0
     1fa:	80 81       	ld	r24, Z
     1fc:	48 2f       	mov	r20, r24
     1fe:	8b 81       	ldd	r24, Y+3	; 0x03
     200:	28 2f       	mov	r18, r24
     202:	30 e0       	ldi	r19, 0x00	; 0
     204:	81 e0       	ldi	r24, 0x01	; 1
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	02 2e       	mov	r0, r18
     20a:	02 c0       	rjmp	.+4      	; 0x210 <DIO_u8SetPinValue+0x17e>
     20c:	88 0f       	add	r24, r24
     20e:	99 1f       	adc	r25, r25
     210:	0a 94       	dec	r0
     212:	e2 f7       	brpl	.-8      	; 0x20c <DIO_u8SetPinValue+0x17a>
     214:	84 2b       	or	r24, r20
     216:	8c 93       	st	X, r24
     218:	44 c0       	rjmp	.+136    	; 0x2a2 <DIO_u8SetPinValue+0x210>
     21a:	a8 e3       	ldi	r26, 0x38	; 56
     21c:	b0 e0       	ldi	r27, 0x00	; 0
     21e:	e8 e3       	ldi	r30, 0x38	; 56
     220:	f0 e0       	ldi	r31, 0x00	; 0
     222:	80 81       	ld	r24, Z
     224:	48 2f       	mov	r20, r24
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	28 2f       	mov	r18, r24
     22a:	30 e0       	ldi	r19, 0x00	; 0
     22c:	81 e0       	ldi	r24, 0x01	; 1
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	02 2e       	mov	r0, r18
     232:	02 c0       	rjmp	.+4      	; 0x238 <DIO_u8SetPinValue+0x1a6>
     234:	88 0f       	add	r24, r24
     236:	99 1f       	adc	r25, r25
     238:	0a 94       	dec	r0
     23a:	e2 f7       	brpl	.-8      	; 0x234 <DIO_u8SetPinValue+0x1a2>
     23c:	84 2b       	or	r24, r20
     23e:	8c 93       	st	X, r24
     240:	30 c0       	rjmp	.+96     	; 0x2a2 <DIO_u8SetPinValue+0x210>
     242:	a5 e3       	ldi	r26, 0x35	; 53
     244:	b0 e0       	ldi	r27, 0x00	; 0
     246:	e5 e3       	ldi	r30, 0x35	; 53
     248:	f0 e0       	ldi	r31, 0x00	; 0
     24a:	80 81       	ld	r24, Z
     24c:	48 2f       	mov	r20, r24
     24e:	8b 81       	ldd	r24, Y+3	; 0x03
     250:	28 2f       	mov	r18, r24
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	81 e0       	ldi	r24, 0x01	; 1
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	02 2e       	mov	r0, r18
     25a:	02 c0       	rjmp	.+4      	; 0x260 <DIO_u8SetPinValue+0x1ce>
     25c:	88 0f       	add	r24, r24
     25e:	99 1f       	adc	r25, r25
     260:	0a 94       	dec	r0
     262:	e2 f7       	brpl	.-8      	; 0x25c <DIO_u8SetPinValue+0x1ca>
     264:	84 2b       	or	r24, r20
     266:	8c 93       	st	X, r24
     268:	1c c0       	rjmp	.+56     	; 0x2a2 <DIO_u8SetPinValue+0x210>
     26a:	a2 e3       	ldi	r26, 0x32	; 50
     26c:	b0 e0       	ldi	r27, 0x00	; 0
     26e:	e2 e3       	ldi	r30, 0x32	; 50
     270:	f0 e0       	ldi	r31, 0x00	; 0
     272:	80 81       	ld	r24, Z
     274:	48 2f       	mov	r20, r24
     276:	8b 81       	ldd	r24, Y+3	; 0x03
     278:	28 2f       	mov	r18, r24
     27a:	30 e0       	ldi	r19, 0x00	; 0
     27c:	81 e0       	ldi	r24, 0x01	; 1
     27e:	90 e0       	ldi	r25, 0x00	; 0
     280:	02 2e       	mov	r0, r18
     282:	02 c0       	rjmp	.+4      	; 0x288 <DIO_u8SetPinValue+0x1f6>
     284:	88 0f       	add	r24, r24
     286:	99 1f       	adc	r25, r25
     288:	0a 94       	dec	r0
     28a:	e2 f7       	brpl	.-8      	; 0x284 <DIO_u8SetPinValue+0x1f2>
     28c:	84 2b       	or	r24, r20
     28e:	8c 93       	st	X, r24
     290:	08 c0       	rjmp	.+16     	; 0x2a2 <DIO_u8SetPinValue+0x210>
     292:	81 e0       	ldi	r24, 0x01	; 1
     294:	89 83       	std	Y+1, r24	; 0x01
     296:	05 c0       	rjmp	.+10     	; 0x2a2 <DIO_u8SetPinValue+0x210>
     298:	81 e0       	ldi	r24, 0x01	; 1
     29a:	89 83       	std	Y+1, r24	; 0x01
     29c:	02 c0       	rjmp	.+4      	; 0x2a2 <DIO_u8SetPinValue+0x210>
     29e:	81 e0       	ldi	r24, 0x01	; 1
     2a0:	89 83       	std	Y+1, r24	; 0x01
     2a2:	89 81       	ldd	r24, Y+1	; 0x01
     2a4:	28 96       	adiw	r28, 0x08	; 8
     2a6:	0f b6       	in	r0, 0x3f	; 63
     2a8:	f8 94       	cli
     2aa:	de bf       	out	0x3e, r29	; 62
     2ac:	0f be       	out	0x3f, r0	; 63
     2ae:	cd bf       	out	0x3d, r28	; 61
     2b0:	cf 91       	pop	r28
     2b2:	df 91       	pop	r29
     2b4:	08 95       	ret

000002b6 <DIO_u8SetPortValue>:
	}
	return Local_u8ErrorState;
}

u8 DIO_u8SetPortValue(u8 Copy_u8port, u8 Copy_u8Value)
{
     2b6:	df 93       	push	r29
     2b8:	cf 93       	push	r28
     2ba:	00 d0       	rcall	.+0      	; 0x2bc <DIO_u8SetPortValue+0x6>
     2bc:	00 d0       	rcall	.+0      	; 0x2be <DIO_u8SetPortValue+0x8>
     2be:	0f 92       	push	r0
     2c0:	cd b7       	in	r28, 0x3d	; 61
     2c2:	de b7       	in	r29, 0x3e	; 62
     2c4:	8a 83       	std	Y+2, r24	; 0x02
     2c6:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
     2c8:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8port<=DIO_u8PORTD)
     2ca:	8a 81       	ldd	r24, Y+2	; 0x02
     2cc:	84 30       	cpi	r24, 0x04	; 4
     2ce:	b0 f5       	brcc	.+108    	; 0x33c <DIO_u8SetPortValue+0x86>
	{
		switch(Copy_u8port)
     2d0:	8a 81       	ldd	r24, Y+2	; 0x02
     2d2:	28 2f       	mov	r18, r24
     2d4:	30 e0       	ldi	r19, 0x00	; 0
     2d6:	3d 83       	std	Y+5, r19	; 0x05
     2d8:	2c 83       	std	Y+4, r18	; 0x04
     2da:	8c 81       	ldd	r24, Y+4	; 0x04
     2dc:	9d 81       	ldd	r25, Y+5	; 0x05
     2de:	81 30       	cpi	r24, 0x01	; 1
     2e0:	91 05       	cpc	r25, r1
     2e2:	d1 f0       	breq	.+52     	; 0x318 <DIO_u8SetPortValue+0x62>
     2e4:	2c 81       	ldd	r18, Y+4	; 0x04
     2e6:	3d 81       	ldd	r19, Y+5	; 0x05
     2e8:	22 30       	cpi	r18, 0x02	; 2
     2ea:	31 05       	cpc	r19, r1
     2ec:	2c f4       	brge	.+10     	; 0x2f8 <DIO_u8SetPortValue+0x42>
     2ee:	8c 81       	ldd	r24, Y+4	; 0x04
     2f0:	9d 81       	ldd	r25, Y+5	; 0x05
     2f2:	00 97       	sbiw	r24, 0x00	; 0
     2f4:	61 f0       	breq	.+24     	; 0x30e <DIO_u8SetPortValue+0x58>
     2f6:	1f c0       	rjmp	.+62     	; 0x336 <DIO_u8SetPortValue+0x80>
     2f8:	2c 81       	ldd	r18, Y+4	; 0x04
     2fa:	3d 81       	ldd	r19, Y+5	; 0x05
     2fc:	22 30       	cpi	r18, 0x02	; 2
     2fe:	31 05       	cpc	r19, r1
     300:	81 f0       	breq	.+32     	; 0x322 <DIO_u8SetPortValue+0x6c>
     302:	8c 81       	ldd	r24, Y+4	; 0x04
     304:	9d 81       	ldd	r25, Y+5	; 0x05
     306:	83 30       	cpi	r24, 0x03	; 3
     308:	91 05       	cpc	r25, r1
     30a:	81 f0       	breq	.+32     	; 0x32c <DIO_u8SetPortValue+0x76>
     30c:	14 c0       	rjmp	.+40     	; 0x336 <DIO_u8SetPortValue+0x80>
		{
		case DIO_u8PORTA: PORTA = Copy_u8Value; break;
     30e:	eb e3       	ldi	r30, 0x3B	; 59
     310:	f0 e0       	ldi	r31, 0x00	; 0
     312:	8b 81       	ldd	r24, Y+3	; 0x03
     314:	80 83       	st	Z, r24
     316:	14 c0       	rjmp	.+40     	; 0x340 <DIO_u8SetPortValue+0x8a>
		case DIO_u8PORTB: PORTB = Copy_u8Value; break;
     318:	e8 e3       	ldi	r30, 0x38	; 56
     31a:	f0 e0       	ldi	r31, 0x00	; 0
     31c:	8b 81       	ldd	r24, Y+3	; 0x03
     31e:	80 83       	st	Z, r24
     320:	0f c0       	rjmp	.+30     	; 0x340 <DIO_u8SetPortValue+0x8a>
		case DIO_u8PORTC: PORTC = Copy_u8Value; break;
     322:	e5 e3       	ldi	r30, 0x35	; 53
     324:	f0 e0       	ldi	r31, 0x00	; 0
     326:	8b 81       	ldd	r24, Y+3	; 0x03
     328:	80 83       	st	Z, r24
     32a:	0a c0       	rjmp	.+20     	; 0x340 <DIO_u8SetPortValue+0x8a>
		case DIO_u8PORTD: PORTD = Copy_u8Value; break;
     32c:	e2 e3       	ldi	r30, 0x32	; 50
     32e:	f0 e0       	ldi	r31, 0x00	; 0
     330:	8b 81       	ldd	r24, Y+3	; 0x03
     332:	80 83       	st	Z, r24
     334:	05 c0       	rjmp	.+10     	; 0x340 <DIO_u8SetPortValue+0x8a>
		default: Local_u8ErrorState =1; break;
     336:	81 e0       	ldi	r24, 0x01	; 1
     338:	89 83       	std	Y+1, r24	; 0x01
     33a:	02 c0       	rjmp	.+4      	; 0x340 <DIO_u8SetPortValue+0x8a>

		}
	}
	else
	{
		Local_u8ErrorState = 1;
     33c:	81 e0       	ldi	r24, 0x01	; 1
     33e:	89 83       	std	Y+1, r24	; 0x01
	}


	return Local_u8ErrorState;
     340:	89 81       	ldd	r24, Y+1	; 0x01
}
     342:	0f 90       	pop	r0
     344:	0f 90       	pop	r0
     346:	0f 90       	pop	r0
     348:	0f 90       	pop	r0
     34a:	0f 90       	pop	r0
     34c:	cf 91       	pop	r28
     34e:	df 91       	pop	r29
     350:	08 95       	ret

00000352 <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 Copy_u8port, u8 Copy_u8Pin, u8* Copy_Pu8Value)
{
     352:	df 93       	push	r29
     354:	cf 93       	push	r28
     356:	cd b7       	in	r28, 0x3d	; 61
     358:	de b7       	in	r29, 0x3e	; 62
     35a:	27 97       	sbiw	r28, 0x07	; 7
     35c:	0f b6       	in	r0, 0x3f	; 63
     35e:	f8 94       	cli
     360:	de bf       	out	0x3e, r29	; 62
     362:	0f be       	out	0x3f, r0	; 63
     364:	cd bf       	out	0x3d, r28	; 61
     366:	8a 83       	std	Y+2, r24	; 0x02
     368:	6b 83       	std	Y+3, r22	; 0x03
     36a:	5d 83       	std	Y+5, r21	; 0x05
     36c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
     36e:	19 82       	std	Y+1, r1	; 0x01

	if((Copy_Pu8Value != NULL )&&(Copy_u8Pin<=DIO_u8PIN7))
     370:	8c 81       	ldd	r24, Y+4	; 0x04
     372:	9d 81       	ldd	r25, Y+5	; 0x05
     374:	00 97       	sbiw	r24, 0x00	; 0
     376:	09 f4       	brne	.+2      	; 0x37a <DIO_u8GetPinValue+0x28>
     378:	78 c0       	rjmp	.+240    	; 0x46a <DIO_u8GetPinValue+0x118>
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	88 30       	cpi	r24, 0x08	; 8
     37e:	08 f0       	brcs	.+2      	; 0x382 <DIO_u8GetPinValue+0x30>
     380:	74 c0       	rjmp	.+232    	; 0x46a <DIO_u8GetPinValue+0x118>
	{


			switch(Copy_u8port)
     382:	8a 81       	ldd	r24, Y+2	; 0x02
     384:	28 2f       	mov	r18, r24
     386:	30 e0       	ldi	r19, 0x00	; 0
     388:	3f 83       	std	Y+7, r19	; 0x07
     38a:	2e 83       	std	Y+6, r18	; 0x06
     38c:	4e 81       	ldd	r20, Y+6	; 0x06
     38e:	5f 81       	ldd	r21, Y+7	; 0x07
     390:	41 30       	cpi	r20, 0x01	; 1
     392:	51 05       	cpc	r21, r1
     394:	59 f1       	breq	.+86     	; 0x3ec <DIO_u8GetPinValue+0x9a>
     396:	8e 81       	ldd	r24, Y+6	; 0x06
     398:	9f 81       	ldd	r25, Y+7	; 0x07
     39a:	82 30       	cpi	r24, 0x02	; 2
     39c:	91 05       	cpc	r25, r1
     39e:	34 f4       	brge	.+12     	; 0x3ac <DIO_u8GetPinValue+0x5a>
     3a0:	2e 81       	ldd	r18, Y+6	; 0x06
     3a2:	3f 81       	ldd	r19, Y+7	; 0x07
     3a4:	21 15       	cp	r18, r1
     3a6:	31 05       	cpc	r19, r1
     3a8:	69 f0       	breq	.+26     	; 0x3c4 <DIO_u8GetPinValue+0x72>
     3aa:	5c c0       	rjmp	.+184    	; 0x464 <DIO_u8GetPinValue+0x112>
     3ac:	4e 81       	ldd	r20, Y+6	; 0x06
     3ae:	5f 81       	ldd	r21, Y+7	; 0x07
     3b0:	42 30       	cpi	r20, 0x02	; 2
     3b2:	51 05       	cpc	r21, r1
     3b4:	79 f1       	breq	.+94     	; 0x414 <DIO_u8GetPinValue+0xc2>
     3b6:	8e 81       	ldd	r24, Y+6	; 0x06
     3b8:	9f 81       	ldd	r25, Y+7	; 0x07
     3ba:	83 30       	cpi	r24, 0x03	; 3
     3bc:	91 05       	cpc	r25, r1
     3be:	09 f4       	brne	.+2      	; 0x3c2 <DIO_u8GetPinValue+0x70>
     3c0:	3d c0       	rjmp	.+122    	; 0x43c <DIO_u8GetPinValue+0xea>
     3c2:	50 c0       	rjmp	.+160    	; 0x464 <DIO_u8GetPinValue+0x112>
			{
			case DIO_u8PORTA: * Copy_Pu8Value = GET_BIT(PINA,Copy_u8Pin); break;
     3c4:	e9 e3       	ldi	r30, 0x39	; 57
     3c6:	f0 e0       	ldi	r31, 0x00	; 0
     3c8:	80 81       	ld	r24, Z
     3ca:	28 2f       	mov	r18, r24
     3cc:	30 e0       	ldi	r19, 0x00	; 0
     3ce:	8b 81       	ldd	r24, Y+3	; 0x03
     3d0:	88 2f       	mov	r24, r24
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	a9 01       	movw	r20, r18
     3d6:	02 c0       	rjmp	.+4      	; 0x3dc <DIO_u8GetPinValue+0x8a>
     3d8:	55 95       	asr	r21
     3da:	47 95       	ror	r20
     3dc:	8a 95       	dec	r24
     3de:	e2 f7       	brpl	.-8      	; 0x3d8 <DIO_u8GetPinValue+0x86>
     3e0:	ca 01       	movw	r24, r20
     3e2:	81 70       	andi	r24, 0x01	; 1
     3e4:	ec 81       	ldd	r30, Y+4	; 0x04
     3e6:	fd 81       	ldd	r31, Y+5	; 0x05
     3e8:	80 83       	st	Z, r24
     3ea:	41 c0       	rjmp	.+130    	; 0x46e <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTB: * Copy_Pu8Value = GET_BIT(PINB,Copy_u8Pin); break;
     3ec:	e6 e3       	ldi	r30, 0x36	; 54
     3ee:	f0 e0       	ldi	r31, 0x00	; 0
     3f0:	80 81       	ld	r24, Z
     3f2:	28 2f       	mov	r18, r24
     3f4:	30 e0       	ldi	r19, 0x00	; 0
     3f6:	8b 81       	ldd	r24, Y+3	; 0x03
     3f8:	88 2f       	mov	r24, r24
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	a9 01       	movw	r20, r18
     3fe:	02 c0       	rjmp	.+4      	; 0x404 <DIO_u8GetPinValue+0xb2>
     400:	55 95       	asr	r21
     402:	47 95       	ror	r20
     404:	8a 95       	dec	r24
     406:	e2 f7       	brpl	.-8      	; 0x400 <DIO_u8GetPinValue+0xae>
     408:	ca 01       	movw	r24, r20
     40a:	81 70       	andi	r24, 0x01	; 1
     40c:	ec 81       	ldd	r30, Y+4	; 0x04
     40e:	fd 81       	ldd	r31, Y+5	; 0x05
     410:	80 83       	st	Z, r24
     412:	2d c0       	rjmp	.+90     	; 0x46e <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTC: * Copy_Pu8Value = GET_BIT(PINC,Copy_u8Pin); break;
     414:	e3 e3       	ldi	r30, 0x33	; 51
     416:	f0 e0       	ldi	r31, 0x00	; 0
     418:	80 81       	ld	r24, Z
     41a:	28 2f       	mov	r18, r24
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	88 2f       	mov	r24, r24
     422:	90 e0       	ldi	r25, 0x00	; 0
     424:	a9 01       	movw	r20, r18
     426:	02 c0       	rjmp	.+4      	; 0x42c <DIO_u8GetPinValue+0xda>
     428:	55 95       	asr	r21
     42a:	47 95       	ror	r20
     42c:	8a 95       	dec	r24
     42e:	e2 f7       	brpl	.-8      	; 0x428 <DIO_u8GetPinValue+0xd6>
     430:	ca 01       	movw	r24, r20
     432:	81 70       	andi	r24, 0x01	; 1
     434:	ec 81       	ldd	r30, Y+4	; 0x04
     436:	fd 81       	ldd	r31, Y+5	; 0x05
     438:	80 83       	st	Z, r24
     43a:	19 c0       	rjmp	.+50     	; 0x46e <DIO_u8GetPinValue+0x11c>
			case DIO_u8PORTD: * Copy_Pu8Value = GET_BIT(PIND,Copy_u8Pin); break;
     43c:	e0 e3       	ldi	r30, 0x30	; 48
     43e:	f0 e0       	ldi	r31, 0x00	; 0
     440:	80 81       	ld	r24, Z
     442:	28 2f       	mov	r18, r24
     444:	30 e0       	ldi	r19, 0x00	; 0
     446:	8b 81       	ldd	r24, Y+3	; 0x03
     448:	88 2f       	mov	r24, r24
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	a9 01       	movw	r20, r18
     44e:	02 c0       	rjmp	.+4      	; 0x454 <DIO_u8GetPinValue+0x102>
     450:	55 95       	asr	r21
     452:	47 95       	ror	r20
     454:	8a 95       	dec	r24
     456:	e2 f7       	brpl	.-8      	; 0x450 <DIO_u8GetPinValue+0xfe>
     458:	ca 01       	movw	r24, r20
     45a:	81 70       	andi	r24, 0x01	; 1
     45c:	ec 81       	ldd	r30, Y+4	; 0x04
     45e:	fd 81       	ldd	r31, Y+5	; 0x05
     460:	80 83       	st	Z, r24
     462:	05 c0       	rjmp	.+10     	; 0x46e <DIO_u8GetPinValue+0x11c>
			default: Local_u8ErrorState =1; break;
     464:	81 e0       	ldi	r24, 0x01	; 1
     466:	89 83       	std	Y+1, r24	; 0x01
     468:	02 c0       	rjmp	.+4      	; 0x46e <DIO_u8GetPinValue+0x11c>

			}
	}
	else
	{
		Local_u8ErrorState = 1;
     46a:	81 e0       	ldi	r24, 0x01	; 1
     46c:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
     46e:	89 81       	ldd	r24, Y+1	; 0x01
}
     470:	27 96       	adiw	r28, 0x07	; 7
     472:	0f b6       	in	r0, 0x3f	; 63
     474:	f8 94       	cli
     476:	de bf       	out	0x3e, r29	; 62
     478:	0f be       	out	0x3f, r0	; 63
     47a:	cd bf       	out	0x3d, r28	; 61
     47c:	cf 91       	pop	r28
     47e:	df 91       	pop	r29
     480:	08 95       	ret

00000482 <DIO_u8AndWithPort>:

u8 DIO_u8AndWithPort(u8 Copy_u8port, u8 Copy_u8Value)
{
     482:	df 93       	push	r29
     484:	cf 93       	push	r28
     486:	00 d0       	rcall	.+0      	; 0x488 <DIO_u8AndWithPort+0x6>
     488:	00 d0       	rcall	.+0      	; 0x48a <DIO_u8AndWithPort+0x8>
     48a:	0f 92       	push	r0
     48c:	cd b7       	in	r28, 0x3d	; 61
     48e:	de b7       	in	r29, 0x3e	; 62
     490:	8a 83       	std	Y+2, r24	; 0x02
     492:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8Result = 0;
     494:	19 82       	std	Y+1, r1	; 0x01
	switch(Copy_u8port)
     496:	8a 81       	ldd	r24, Y+2	; 0x02
     498:	28 2f       	mov	r18, r24
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	3d 83       	std	Y+5, r19	; 0x05
     49e:	2c 83       	std	Y+4, r18	; 0x04
     4a0:	8c 81       	ldd	r24, Y+4	; 0x04
     4a2:	9d 81       	ldd	r25, Y+5	; 0x05
     4a4:	81 30       	cpi	r24, 0x01	; 1
     4a6:	91 05       	cpc	r25, r1
     4a8:	e1 f0       	breq	.+56     	; 0x4e2 <DIO_u8AndWithPort+0x60>
     4aa:	2c 81       	ldd	r18, Y+4	; 0x04
     4ac:	3d 81       	ldd	r19, Y+5	; 0x05
     4ae:	22 30       	cpi	r18, 0x02	; 2
     4b0:	31 05       	cpc	r19, r1
     4b2:	2c f4       	brge	.+10     	; 0x4be <DIO_u8AndWithPort+0x3c>
     4b4:	8c 81       	ldd	r24, Y+4	; 0x04
     4b6:	9d 81       	ldd	r25, Y+5	; 0x05
     4b8:	00 97       	sbiw	r24, 0x00	; 0
     4ba:	61 f0       	breq	.+24     	; 0x4d4 <DIO_u8AndWithPort+0x52>
     4bc:	26 c0       	rjmp	.+76     	; 0x50a <DIO_u8AndWithPort+0x88>
     4be:	2c 81       	ldd	r18, Y+4	; 0x04
     4c0:	3d 81       	ldd	r19, Y+5	; 0x05
     4c2:	22 30       	cpi	r18, 0x02	; 2
     4c4:	31 05       	cpc	r19, r1
     4c6:	a1 f0       	breq	.+40     	; 0x4f0 <DIO_u8AndWithPort+0x6e>
     4c8:	8c 81       	ldd	r24, Y+4	; 0x04
     4ca:	9d 81       	ldd	r25, Y+5	; 0x05
     4cc:	83 30       	cpi	r24, 0x03	; 3
     4ce:	91 05       	cpc	r25, r1
     4d0:	b1 f0       	breq	.+44     	; 0x4fe <DIO_u8AndWithPort+0x7c>
     4d2:	1b c0       	rjmp	.+54     	; 0x50a <DIO_u8AndWithPort+0x88>
			{
			case DIO_u8PORTA: Local_u8Result= PORTA & Copy_u8Value; break;
     4d4:	eb e3       	ldi	r30, 0x3B	; 59
     4d6:	f0 e0       	ldi	r31, 0x00	; 0
     4d8:	90 81       	ld	r25, Z
     4da:	8b 81       	ldd	r24, Y+3	; 0x03
     4dc:	89 23       	and	r24, r25
     4de:	89 83       	std	Y+1, r24	; 0x01
     4e0:	14 c0       	rjmp	.+40     	; 0x50a <DIO_u8AndWithPort+0x88>
			case DIO_u8PORTB: Local_u8Result= PORTB & Copy_u8Value; break;
     4e2:	e8 e3       	ldi	r30, 0x38	; 56
     4e4:	f0 e0       	ldi	r31, 0x00	; 0
     4e6:	90 81       	ld	r25, Z
     4e8:	8b 81       	ldd	r24, Y+3	; 0x03
     4ea:	89 23       	and	r24, r25
     4ec:	89 83       	std	Y+1, r24	; 0x01
     4ee:	0d c0       	rjmp	.+26     	; 0x50a <DIO_u8AndWithPort+0x88>
			case DIO_u8PORTC: Local_u8Result= PORTC & Copy_u8Value; break;
     4f0:	e5 e3       	ldi	r30, 0x35	; 53
     4f2:	f0 e0       	ldi	r31, 0x00	; 0
     4f4:	90 81       	ld	r25, Z
     4f6:	8b 81       	ldd	r24, Y+3	; 0x03
     4f8:	89 23       	and	r24, r25
     4fa:	89 83       	std	Y+1, r24	; 0x01
     4fc:	06 c0       	rjmp	.+12     	; 0x50a <DIO_u8AndWithPort+0x88>
			case DIO_u8PORTD: Local_u8Result = PORTD & Copy_u8Value; break;
     4fe:	e2 e3       	ldi	r30, 0x32	; 50
     500:	f0 e0       	ldi	r31, 0x00	; 0
     502:	90 81       	ld	r25, Z
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	89 23       	and	r24, r25
     508:	89 83       	std	Y+1, r24	; 0x01
			default:  break;


			}
	return Local_u8Result;
     50a:	89 81       	ldd	r24, Y+1	; 0x01
}
     50c:	0f 90       	pop	r0
     50e:	0f 90       	pop	r0
     510:	0f 90       	pop	r0
     512:	0f 90       	pop	r0
     514:	0f 90       	pop	r0
     516:	cf 91       	pop	r28
     518:	df 91       	pop	r29
     51a:	08 95       	ret

0000051c <PORT_VoidInit>:
#include "PORT_interface.h"
#include "PORT_register.h"


void PORT_VoidInit(void)
{
     51c:	df 93       	push	r29
     51e:	cf 93       	push	r28
     520:	cd b7       	in	r28, 0x3d	; 61
     522:	de b7       	in	r29, 0x3e	; 62
	DDRA = PORTA_DIR;
     524:	ea e3       	ldi	r30, 0x3A	; 58
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	10 82       	st	Z, r1
	DDRB = PORTB_DIR;
     52a:	e7 e3       	ldi	r30, 0x37	; 55
     52c:	f0 e0       	ldi	r31, 0x00	; 0
     52e:	10 82       	st	Z, r1
	DDRC = PORTC_DIR;
     530:	e4 e3       	ldi	r30, 0x34	; 52
     532:	f0 e0       	ldi	r31, 0x00	; 0
     534:	87 e0       	ldi	r24, 0x07	; 7
     536:	80 83       	st	Z, r24
	DDRD = PORTD_DIR;
     538:	e1 e3       	ldi	r30, 0x31	; 49
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	10 82       	st	Z, r1
	
	PORTA = PORTA_INITIAL_VALUE;
     53e:	eb e3       	ldi	r30, 0x3B	; 59
     540:	f0 e0       	ldi	r31, 0x00	; 0
     542:	10 82       	st	Z, r1
	PORTB = PORTB_INITIAL_VALUE;
     544:	e8 e3       	ldi	r30, 0x38	; 56
     546:	f0 e0       	ldi	r31, 0x00	; 0
     548:	10 82       	st	Z, r1
	PORTC = PORTC_INITIAL_VALUE;
     54a:	e5 e3       	ldi	r30, 0x35	; 53
     54c:	f0 e0       	ldi	r31, 0x00	; 0
     54e:	10 82       	st	Z, r1
	PORTD = PORTD_INITIAL_VALUE;
     550:	e2 e3       	ldi	r30, 0x32	; 50
     552:	f0 e0       	ldi	r31, 0x00	; 0
     554:	10 82       	st	Z, r1


}
     556:	cf 91       	pop	r28
     558:	df 91       	pop	r29
     55a:	08 95       	ret

0000055c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     55c:	df 93       	push	r29
     55e:	cf 93       	push	r28
     560:	cd b7       	in	r28, 0x3d	; 61
     562:	de b7       	in	r29, 0x3e	; 62
     564:	27 97       	sbiw	r28, 0x07	; 7
     566:	0f b6       	in	r0, 0x3f	; 63
     568:	f8 94       	cli
     56a:	de bf       	out	0x3e, r29	; 62
     56c:	0f be       	out	0x3f, r0	; 63
     56e:	cd bf       	out	0x3d, r28	; 61
     570:	9d 83       	std	Y+5, r25	; 0x05
     572:	8c 83       	std	Y+4, r24	; 0x04
     574:	6e 83       	std	Y+6, r22	; 0x06
     576:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     578:	8a e1       	ldi	r24, 0x1A	; 26
     57a:	90 e0       	ldi	r25, 0x00	; 0
     57c:	0e 94 86 05 	call	0xb0c	; 0xb0c <pvPortMalloc>
     580:	9a 83       	std	Y+2, r25	; 0x02
     582:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     584:	89 81       	ldd	r24, Y+1	; 0x01
     586:	9a 81       	ldd	r25, Y+2	; 0x02
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	09 f4       	brne	.+2      	; 0x58e <xCoRoutineCreate+0x32>
     58c:	6f c0       	rjmp	.+222    	; 0x66c <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     58e:	80 91 68 00 	lds	r24, 0x0068
     592:	90 91 69 00 	lds	r25, 0x0069
     596:	00 97       	sbiw	r24, 0x00	; 0
     598:	41 f4       	brne	.+16     	; 0x5aa <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     59a:	89 81       	ldd	r24, Y+1	; 0x01
     59c:	9a 81       	ldd	r25, Y+2	; 0x02
     59e:	90 93 69 00 	sts	0x0069, r25
     5a2:	80 93 68 00 	sts	0x0068, r24
			prvInitialiseCoRoutineLists();
     5a6:	0e 94 15 05 	call	0xa2a	; 0xa2a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     5aa:	8e 81       	ldd	r24, Y+6	; 0x06
     5ac:	82 30       	cpi	r24, 0x02	; 2
     5ae:	10 f0       	brcs	.+4      	; 0x5b4 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     5b0:	81 e0       	ldi	r24, 0x01	; 1
     5b2:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     5b4:	e9 81       	ldd	r30, Y+1	; 0x01
     5b6:	fa 81       	ldd	r31, Y+2	; 0x02
     5b8:	11 8e       	std	Z+25, r1	; 0x19
     5ba:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     5bc:	e9 81       	ldd	r30, Y+1	; 0x01
     5be:	fa 81       	ldd	r31, Y+2	; 0x02
     5c0:	8e 81       	ldd	r24, Y+6	; 0x06
     5c2:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     5c4:	e9 81       	ldd	r30, Y+1	; 0x01
     5c6:	fa 81       	ldd	r31, Y+2	; 0x02
     5c8:	8f 81       	ldd	r24, Y+7	; 0x07
     5ca:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     5cc:	e9 81       	ldd	r30, Y+1	; 0x01
     5ce:	fa 81       	ldd	r31, Y+2	; 0x02
     5d0:	8c 81       	ldd	r24, Y+4	; 0x04
     5d2:	9d 81       	ldd	r25, Y+5	; 0x05
     5d4:	91 83       	std	Z+1, r25	; 0x01
     5d6:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	02 96       	adiw	r24, 0x02	; 2
     5de:	0e 94 1c 06 	call	0xc38	; 0xc38 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     5e2:	89 81       	ldd	r24, Y+1	; 0x01
     5e4:	9a 81       	ldd	r25, Y+2	; 0x02
     5e6:	0c 96       	adiw	r24, 0x0c	; 12
     5e8:	0e 94 1c 06 	call	0xc38	; 0xc38 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     5ec:	e9 81       	ldd	r30, Y+1	; 0x01
     5ee:	fa 81       	ldd	r31, Y+2	; 0x02
     5f0:	89 81       	ldd	r24, Y+1	; 0x01
     5f2:	9a 81       	ldd	r25, Y+2	; 0x02
     5f4:	91 87       	std	Z+9, r25	; 0x09
     5f6:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     5f8:	e9 81       	ldd	r30, Y+1	; 0x01
     5fa:	fa 81       	ldd	r31, Y+2	; 0x02
     5fc:	89 81       	ldd	r24, Y+1	; 0x01
     5fe:	9a 81       	ldd	r25, Y+2	; 0x02
     600:	93 8b       	std	Z+19, r25	; 0x13
     602:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     604:	8e 81       	ldd	r24, Y+6	; 0x06
     606:	28 2f       	mov	r18, r24
     608:	30 e0       	ldi	r19, 0x00	; 0
     60a:	84 e0       	ldi	r24, 0x04	; 4
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	82 1b       	sub	r24, r18
     610:	93 0b       	sbc	r25, r19
     612:	e9 81       	ldd	r30, Y+1	; 0x01
     614:	fa 81       	ldd	r31, Y+2	; 0x02
     616:	95 87       	std	Z+13, r25	; 0x0d
     618:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     61a:	e9 81       	ldd	r30, Y+1	; 0x01
     61c:	fa 81       	ldd	r31, Y+2	; 0x02
     61e:	96 89       	ldd	r25, Z+22	; 0x16
     620:	80 91 6a 00 	lds	r24, 0x006A
     624:	89 17       	cp	r24, r25
     626:	28 f4       	brcc	.+10     	; 0x632 <xCoRoutineCreate+0xd6>
     628:	e9 81       	ldd	r30, Y+1	; 0x01
     62a:	fa 81       	ldd	r31, Y+2	; 0x02
     62c:	86 89       	ldd	r24, Z+22	; 0x16
     62e:	80 93 6a 00 	sts	0x006A, r24
     632:	e9 81       	ldd	r30, Y+1	; 0x01
     634:	fa 81       	ldd	r31, Y+2	; 0x02
     636:	86 89       	ldd	r24, Z+22	; 0x16
     638:	28 2f       	mov	r18, r24
     63a:	30 e0       	ldi	r19, 0x00	; 0
     63c:	c9 01       	movw	r24, r18
     63e:	88 0f       	add	r24, r24
     640:	99 1f       	adc	r25, r25
     642:	88 0f       	add	r24, r24
     644:	99 1f       	adc	r25, r25
     646:	88 0f       	add	r24, r24
     648:	99 1f       	adc	r25, r25
     64a:	82 0f       	add	r24, r18
     64c:	93 1f       	adc	r25, r19
     64e:	ac 01       	movw	r20, r24
     650:	4f 58       	subi	r20, 0x8F	; 143
     652:	5f 4f       	sbci	r21, 0xFF	; 255
     654:	89 81       	ldd	r24, Y+1	; 0x01
     656:	9a 81       	ldd	r25, Y+2	; 0x02
     658:	9c 01       	movw	r18, r24
     65a:	2e 5f       	subi	r18, 0xFE	; 254
     65c:	3f 4f       	sbci	r19, 0xFF	; 255
     65e:	ca 01       	movw	r24, r20
     660:	b9 01       	movw	r22, r18
     662:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>

		xReturn = pdPASS;
     666:	81 e0       	ldi	r24, 0x01	; 1
     668:	8b 83       	std	Y+3, r24	; 0x03
     66a:	02 c0       	rjmp	.+4      	; 0x670 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     66c:	8f ef       	ldi	r24, 0xFF	; 255
     66e:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     670:	8b 81       	ldd	r24, Y+3	; 0x03
}
     672:	27 96       	adiw	r28, 0x07	; 7
     674:	0f b6       	in	r0, 0x3f	; 63
     676:	f8 94       	cli
     678:	de bf       	out	0x3e, r29	; 62
     67a:	0f be       	out	0x3f, r0	; 63
     67c:	cd bf       	out	0x3d, r28	; 61
     67e:	cf 91       	pop	r28
     680:	df 91       	pop	r29
     682:	08 95       	ret

00000684 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     684:	df 93       	push	r29
     686:	cf 93       	push	r28
     688:	00 d0       	rcall	.+0      	; 0x68a <vCoRoutineAddToDelayedList+0x6>
     68a:	00 d0       	rcall	.+0      	; 0x68c <vCoRoutineAddToDelayedList+0x8>
     68c:	00 d0       	rcall	.+0      	; 0x68e <vCoRoutineAddToDelayedList+0xa>
     68e:	cd b7       	in	r28, 0x3d	; 61
     690:	de b7       	in	r29, 0x3e	; 62
     692:	9c 83       	std	Y+4, r25	; 0x04
     694:	8b 83       	std	Y+3, r24	; 0x03
     696:	7e 83       	std	Y+6, r23	; 0x06
     698:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     69a:	20 91 6b 00 	lds	r18, 0x006B
     69e:	30 91 6c 00 	lds	r19, 0x006C
     6a2:	8b 81       	ldd	r24, Y+3	; 0x03
     6a4:	9c 81       	ldd	r25, Y+4	; 0x04
     6a6:	82 0f       	add	r24, r18
     6a8:	93 1f       	adc	r25, r19
     6aa:	9a 83       	std	Y+2, r25	; 0x02
     6ac:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6ae:	80 91 68 00 	lds	r24, 0x0068
     6b2:	90 91 69 00 	lds	r25, 0x0069
     6b6:	02 96       	adiw	r24, 0x02	; 2
     6b8:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     6bc:	e0 91 68 00 	lds	r30, 0x0068
     6c0:	f0 91 69 00 	lds	r31, 0x0069
     6c4:	89 81       	ldd	r24, Y+1	; 0x01
     6c6:	9a 81       	ldd	r25, Y+2	; 0x02
     6c8:	93 83       	std	Z+3, r25	; 0x03
     6ca:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     6cc:	20 91 6b 00 	lds	r18, 0x006B
     6d0:	30 91 6c 00 	lds	r19, 0x006C
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	9a 81       	ldd	r25, Y+2	; 0x02
     6d8:	82 17       	cp	r24, r18
     6da:	93 07       	cpc	r25, r19
     6dc:	70 f4       	brcc	.+28     	; 0x6fa <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6de:	80 91 97 00 	lds	r24, 0x0097
     6e2:	90 91 98 00 	lds	r25, 0x0098
     6e6:	20 91 68 00 	lds	r18, 0x0068
     6ea:	30 91 69 00 	lds	r19, 0x0069
     6ee:	2e 5f       	subi	r18, 0xFE	; 254
     6f0:	3f 4f       	sbci	r19, 0xFF	; 255
     6f2:	b9 01       	movw	r22, r18
     6f4:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vListInsert>
     6f8:	0d c0       	rjmp	.+26     	; 0x714 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6fa:	80 91 95 00 	lds	r24, 0x0095
     6fe:	90 91 96 00 	lds	r25, 0x0096
     702:	20 91 68 00 	lds	r18, 0x0068
     706:	30 91 69 00 	lds	r19, 0x0069
     70a:	2e 5f       	subi	r18, 0xFE	; 254
     70c:	3f 4f       	sbci	r19, 0xFF	; 255
     70e:	b9 01       	movw	r22, r18
     710:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vListInsert>
	}

	if( pxEventList )
     714:	8d 81       	ldd	r24, Y+5	; 0x05
     716:	9e 81       	ldd	r25, Y+6	; 0x06
     718:	00 97       	sbiw	r24, 0x00	; 0
     71a:	61 f0       	breq	.+24     	; 0x734 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     71c:	80 91 68 00 	lds	r24, 0x0068
     720:	90 91 69 00 	lds	r25, 0x0069
     724:	9c 01       	movw	r18, r24
     726:	24 5f       	subi	r18, 0xF4	; 244
     728:	3f 4f       	sbci	r19, 0xFF	; 255
     72a:	8d 81       	ldd	r24, Y+5	; 0x05
     72c:	9e 81       	ldd	r25, Y+6	; 0x06
     72e:	b9 01       	movw	r22, r18
     730:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vListInsert>
	}
}
     734:	26 96       	adiw	r28, 0x06	; 6
     736:	0f b6       	in	r0, 0x3f	; 63
     738:	f8 94       	cli
     73a:	de bf       	out	0x3e, r29	; 62
     73c:	0f be       	out	0x3f, r0	; 63
     73e:	cd bf       	out	0x3d, r28	; 61
     740:	cf 91       	pop	r28
     742:	df 91       	pop	r29
     744:	08 95       	ret

00000746 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     746:	df 93       	push	r29
     748:	cf 93       	push	r28
     74a:	00 d0       	rcall	.+0      	; 0x74c <prvCheckPendingReadyList+0x6>
     74c:	cd b7       	in	r28, 0x3d	; 61
     74e:	de b7       	in	r29, 0x3e	; 62
     750:	3a c0       	rjmp	.+116    	; 0x7c6 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     752:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     754:	e0 91 9e 00 	lds	r30, 0x009E
     758:	f0 91 9f 00 	lds	r31, 0x009F
     75c:	86 81       	ldd	r24, Z+6	; 0x06
     75e:	97 81       	ldd	r25, Z+7	; 0x07
     760:	9a 83       	std	Y+2, r25	; 0x02
     762:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     764:	89 81       	ldd	r24, Y+1	; 0x01
     766:	9a 81       	ldd	r25, Y+2	; 0x02
     768:	0c 96       	adiw	r24, 0x0c	; 12
     76a:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     76e:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     770:	89 81       	ldd	r24, Y+1	; 0x01
     772:	9a 81       	ldd	r25, Y+2	; 0x02
     774:	02 96       	adiw	r24, 0x02	; 2
     776:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     77a:	e9 81       	ldd	r30, Y+1	; 0x01
     77c:	fa 81       	ldd	r31, Y+2	; 0x02
     77e:	96 89       	ldd	r25, Z+22	; 0x16
     780:	80 91 6a 00 	lds	r24, 0x006A
     784:	89 17       	cp	r24, r25
     786:	28 f4       	brcc	.+10     	; 0x792 <prvCheckPendingReadyList+0x4c>
     788:	e9 81       	ldd	r30, Y+1	; 0x01
     78a:	fa 81       	ldd	r31, Y+2	; 0x02
     78c:	86 89       	ldd	r24, Z+22	; 0x16
     78e:	80 93 6a 00 	sts	0x006A, r24
     792:	e9 81       	ldd	r30, Y+1	; 0x01
     794:	fa 81       	ldd	r31, Y+2	; 0x02
     796:	86 89       	ldd	r24, Z+22	; 0x16
     798:	28 2f       	mov	r18, r24
     79a:	30 e0       	ldi	r19, 0x00	; 0
     79c:	c9 01       	movw	r24, r18
     79e:	88 0f       	add	r24, r24
     7a0:	99 1f       	adc	r25, r25
     7a2:	88 0f       	add	r24, r24
     7a4:	99 1f       	adc	r25, r25
     7a6:	88 0f       	add	r24, r24
     7a8:	99 1f       	adc	r25, r25
     7aa:	82 0f       	add	r24, r18
     7ac:	93 1f       	adc	r25, r19
     7ae:	ac 01       	movw	r20, r24
     7b0:	4f 58       	subi	r20, 0x8F	; 143
     7b2:	5f 4f       	sbci	r21, 0xFF	; 255
     7b4:	89 81       	ldd	r24, Y+1	; 0x01
     7b6:	9a 81       	ldd	r25, Y+2	; 0x02
     7b8:	9c 01       	movw	r18, r24
     7ba:	2e 5f       	subi	r18, 0xFE	; 254
     7bc:	3f 4f       	sbci	r19, 0xFF	; 255
     7be:	ca 01       	movw	r24, r20
     7c0:	b9 01       	movw	r22, r18
     7c2:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     7c6:	80 91 99 00 	lds	r24, 0x0099
     7ca:	88 23       	and	r24, r24
     7cc:	09 f0       	breq	.+2      	; 0x7d0 <prvCheckPendingReadyList+0x8a>
     7ce:	c1 cf       	rjmp	.-126    	; 0x752 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     7d0:	0f 90       	pop	r0
     7d2:	0f 90       	pop	r0
     7d4:	cf 91       	pop	r28
     7d6:	df 91       	pop	r29
     7d8:	08 95       	ret

000007da <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     7da:	df 93       	push	r29
     7dc:	cf 93       	push	r28
     7de:	00 d0       	rcall	.+0      	; 0x7e0 <prvCheckDelayedList+0x6>
     7e0:	00 d0       	rcall	.+0      	; 0x7e2 <prvCheckDelayedList+0x8>
     7e2:	cd b7       	in	r28, 0x3d	; 61
     7e4:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     7e6:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskGetTickCount>
     7ea:	20 91 6d 00 	lds	r18, 0x006D
     7ee:	30 91 6e 00 	lds	r19, 0x006E
     7f2:	82 1b       	sub	r24, r18
     7f4:	93 0b       	sbc	r25, r19
     7f6:	90 93 70 00 	sts	0x0070, r25
     7fa:	80 93 6f 00 	sts	0x006F, r24
     7fe:	85 c0       	rjmp	.+266    	; 0x90a <__stack+0xab>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     800:	80 91 6b 00 	lds	r24, 0x006B
     804:	90 91 6c 00 	lds	r25, 0x006C
     808:	01 96       	adiw	r24, 0x01	; 1
     80a:	90 93 6c 00 	sts	0x006C, r25
     80e:	80 93 6b 00 	sts	0x006B, r24
		xPassedTicks--;
     812:	80 91 6f 00 	lds	r24, 0x006F
     816:	90 91 70 00 	lds	r25, 0x0070
     81a:	01 97       	sbiw	r24, 0x01	; 1
     81c:	90 93 70 00 	sts	0x0070, r25
     820:	80 93 6f 00 	sts	0x006F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     824:	80 91 6b 00 	lds	r24, 0x006B
     828:	90 91 6c 00 	lds	r25, 0x006C
     82c:	00 97       	sbiw	r24, 0x00	; 0
     82e:	09 f0       	breq	.+2      	; 0x832 <prvCheckDelayedList+0x58>
     830:	64 c0       	rjmp	.+200    	; 0x8fa <__stack+0x9b>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     832:	80 91 95 00 	lds	r24, 0x0095
     836:	90 91 96 00 	lds	r25, 0x0096
     83a:	9a 83       	std	Y+2, r25	; 0x02
     83c:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     83e:	80 91 97 00 	lds	r24, 0x0097
     842:	90 91 98 00 	lds	r25, 0x0098
     846:	90 93 96 00 	sts	0x0096, r25
     84a:	80 93 95 00 	sts	0x0095, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     84e:	89 81       	ldd	r24, Y+1	; 0x01
     850:	9a 81       	ldd	r25, Y+2	; 0x02
     852:	90 93 98 00 	sts	0x0098, r25
     856:	80 93 97 00 	sts	0x0097, r24
     85a:	4f c0       	rjmp	.+158    	; 0x8fa <__stack+0x9b>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     85c:	e0 91 95 00 	lds	r30, 0x0095
     860:	f0 91 96 00 	lds	r31, 0x0096
     864:	05 80       	ldd	r0, Z+5	; 0x05
     866:	f6 81       	ldd	r31, Z+6	; 0x06
     868:	e0 2d       	mov	r30, r0
     86a:	86 81       	ldd	r24, Z+6	; 0x06
     86c:	97 81       	ldd	r25, Z+7	; 0x07
     86e:	9c 83       	std	Y+4, r25	; 0x04
     870:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     872:	eb 81       	ldd	r30, Y+3	; 0x03
     874:	fc 81       	ldd	r31, Y+4	; 0x04
     876:	22 81       	ldd	r18, Z+2	; 0x02
     878:	33 81       	ldd	r19, Z+3	; 0x03
     87a:	80 91 6b 00 	lds	r24, 0x006B
     87e:	90 91 6c 00 	lds	r25, 0x006C
     882:	82 17       	cp	r24, r18
     884:	93 07       	cpc	r25, r19
     886:	08 f4       	brcc	.+2      	; 0x88a <__stack+0x2b>
     888:	40 c0       	rjmp	.+128    	; 0x90a <__stack+0xab>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     88a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     88c:	8b 81       	ldd	r24, Y+3	; 0x03
     88e:	9c 81       	ldd	r25, Y+4	; 0x04
     890:	02 96       	adiw	r24, 0x02	; 2
     892:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     896:	eb 81       	ldd	r30, Y+3	; 0x03
     898:	fc 81       	ldd	r31, Y+4	; 0x04
     89a:	84 89       	ldd	r24, Z+20	; 0x14
     89c:	95 89       	ldd	r25, Z+21	; 0x15
     89e:	00 97       	sbiw	r24, 0x00	; 0
     8a0:	29 f0       	breq	.+10     	; 0x8ac <__stack+0x4d>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     8a2:	8b 81       	ldd	r24, Y+3	; 0x03
     8a4:	9c 81       	ldd	r25, Y+4	; 0x04
     8a6:	0c 96       	adiw	r24, 0x0c	; 12
     8a8:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     8ac:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     8ae:	eb 81       	ldd	r30, Y+3	; 0x03
     8b0:	fc 81       	ldd	r31, Y+4	; 0x04
     8b2:	96 89       	ldd	r25, Z+22	; 0x16
     8b4:	80 91 6a 00 	lds	r24, 0x006A
     8b8:	89 17       	cp	r24, r25
     8ba:	28 f4       	brcc	.+10     	; 0x8c6 <__stack+0x67>
     8bc:	eb 81       	ldd	r30, Y+3	; 0x03
     8be:	fc 81       	ldd	r31, Y+4	; 0x04
     8c0:	86 89       	ldd	r24, Z+22	; 0x16
     8c2:	80 93 6a 00 	sts	0x006A, r24
     8c6:	eb 81       	ldd	r30, Y+3	; 0x03
     8c8:	fc 81       	ldd	r31, Y+4	; 0x04
     8ca:	86 89       	ldd	r24, Z+22	; 0x16
     8cc:	28 2f       	mov	r18, r24
     8ce:	30 e0       	ldi	r19, 0x00	; 0
     8d0:	c9 01       	movw	r24, r18
     8d2:	88 0f       	add	r24, r24
     8d4:	99 1f       	adc	r25, r25
     8d6:	88 0f       	add	r24, r24
     8d8:	99 1f       	adc	r25, r25
     8da:	88 0f       	add	r24, r24
     8dc:	99 1f       	adc	r25, r25
     8de:	82 0f       	add	r24, r18
     8e0:	93 1f       	adc	r25, r19
     8e2:	ac 01       	movw	r20, r24
     8e4:	4f 58       	subi	r20, 0x8F	; 143
     8e6:	5f 4f       	sbci	r21, 0xFF	; 255
     8e8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ea:	9c 81       	ldd	r25, Y+4	; 0x04
     8ec:	9c 01       	movw	r18, r24
     8ee:	2e 5f       	subi	r18, 0xFE	; 254
     8f0:	3f 4f       	sbci	r19, 0xFF	; 255
     8f2:	ca 01       	movw	r24, r20
     8f4:	b9 01       	movw	r22, r18
     8f6:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     8fa:	e0 91 95 00 	lds	r30, 0x0095
     8fe:	f0 91 96 00 	lds	r31, 0x0096
     902:	80 81       	ld	r24, Z
     904:	88 23       	and	r24, r24
     906:	09 f0       	breq	.+2      	; 0x90a <__stack+0xab>
     908:	a9 cf       	rjmp	.-174    	; 0x85c <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     90a:	80 91 6f 00 	lds	r24, 0x006F
     90e:	90 91 70 00 	lds	r25, 0x0070
     912:	00 97       	sbiw	r24, 0x00	; 0
     914:	09 f0       	breq	.+2      	; 0x918 <__stack+0xb9>
     916:	74 cf       	rjmp	.-280    	; 0x800 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     918:	80 91 6b 00 	lds	r24, 0x006B
     91c:	90 91 6c 00 	lds	r25, 0x006C
     920:	90 93 6e 00 	sts	0x006E, r25
     924:	80 93 6d 00 	sts	0x006D, r24
}
     928:	0f 90       	pop	r0
     92a:	0f 90       	pop	r0
     92c:	0f 90       	pop	r0
     92e:	0f 90       	pop	r0
     930:	cf 91       	pop	r28
     932:	df 91       	pop	r29
     934:	08 95       	ret

00000936 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     936:	df 93       	push	r29
     938:	cf 93       	push	r28
     93a:	00 d0       	rcall	.+0      	; 0x93c <vCoRoutineSchedule+0x6>
     93c:	cd b7       	in	r28, 0x3d	; 61
     93e:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     940:	0e 94 a3 03 	call	0x746	; 0x746 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     944:	0e 94 ed 03 	call	0x7da	; 0x7da <prvCheckDelayedList>
     948:	0a c0       	rjmp	.+20     	; 0x95e <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     94a:	80 91 6a 00 	lds	r24, 0x006A
     94e:	88 23       	and	r24, r24
     950:	09 f4       	brne	.+2      	; 0x954 <vCoRoutineSchedule+0x1e>
     952:	66 c0       	rjmp	.+204    	; 0xa20 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     954:	80 91 6a 00 	lds	r24, 0x006A
     958:	81 50       	subi	r24, 0x01	; 1
     95a:	80 93 6a 00 	sts	0x006A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     95e:	80 91 6a 00 	lds	r24, 0x006A
     962:	28 2f       	mov	r18, r24
     964:	30 e0       	ldi	r19, 0x00	; 0
     966:	c9 01       	movw	r24, r18
     968:	88 0f       	add	r24, r24
     96a:	99 1f       	adc	r25, r25
     96c:	88 0f       	add	r24, r24
     96e:	99 1f       	adc	r25, r25
     970:	88 0f       	add	r24, r24
     972:	99 1f       	adc	r25, r25
     974:	82 0f       	add	r24, r18
     976:	93 1f       	adc	r25, r19
     978:	fc 01       	movw	r30, r24
     97a:	ef 58       	subi	r30, 0x8F	; 143
     97c:	ff 4f       	sbci	r31, 0xFF	; 255
     97e:	80 81       	ld	r24, Z
     980:	88 23       	and	r24, r24
     982:	19 f3       	breq	.-58     	; 0x94a <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     984:	80 91 6a 00 	lds	r24, 0x006A
     988:	28 2f       	mov	r18, r24
     98a:	30 e0       	ldi	r19, 0x00	; 0
     98c:	c9 01       	movw	r24, r18
     98e:	88 0f       	add	r24, r24
     990:	99 1f       	adc	r25, r25
     992:	88 0f       	add	r24, r24
     994:	99 1f       	adc	r25, r25
     996:	88 0f       	add	r24, r24
     998:	99 1f       	adc	r25, r25
     99a:	82 0f       	add	r24, r18
     99c:	93 1f       	adc	r25, r19
     99e:	8f 58       	subi	r24, 0x8F	; 143
     9a0:	9f 4f       	sbci	r25, 0xFF	; 255
     9a2:	9a 83       	std	Y+2, r25	; 0x02
     9a4:	89 83       	std	Y+1, r24	; 0x01
     9a6:	e9 81       	ldd	r30, Y+1	; 0x01
     9a8:	fa 81       	ldd	r31, Y+2	; 0x02
     9aa:	01 80       	ldd	r0, Z+1	; 0x01
     9ac:	f2 81       	ldd	r31, Z+2	; 0x02
     9ae:	e0 2d       	mov	r30, r0
     9b0:	82 81       	ldd	r24, Z+2	; 0x02
     9b2:	93 81       	ldd	r25, Z+3	; 0x03
     9b4:	e9 81       	ldd	r30, Y+1	; 0x01
     9b6:	fa 81       	ldd	r31, Y+2	; 0x02
     9b8:	92 83       	std	Z+2, r25	; 0x02
     9ba:	81 83       	std	Z+1, r24	; 0x01
     9bc:	e9 81       	ldd	r30, Y+1	; 0x01
     9be:	fa 81       	ldd	r31, Y+2	; 0x02
     9c0:	21 81       	ldd	r18, Z+1	; 0x01
     9c2:	32 81       	ldd	r19, Z+2	; 0x02
     9c4:	89 81       	ldd	r24, Y+1	; 0x01
     9c6:	9a 81       	ldd	r25, Y+2	; 0x02
     9c8:	03 96       	adiw	r24, 0x03	; 3
     9ca:	28 17       	cp	r18, r24
     9cc:	39 07       	cpc	r19, r25
     9ce:	59 f4       	brne	.+22     	; 0x9e6 <vCoRoutineSchedule+0xb0>
     9d0:	e9 81       	ldd	r30, Y+1	; 0x01
     9d2:	fa 81       	ldd	r31, Y+2	; 0x02
     9d4:	01 80       	ldd	r0, Z+1	; 0x01
     9d6:	f2 81       	ldd	r31, Z+2	; 0x02
     9d8:	e0 2d       	mov	r30, r0
     9da:	82 81       	ldd	r24, Z+2	; 0x02
     9dc:	93 81       	ldd	r25, Z+3	; 0x03
     9de:	e9 81       	ldd	r30, Y+1	; 0x01
     9e0:	fa 81       	ldd	r31, Y+2	; 0x02
     9e2:	92 83       	std	Z+2, r25	; 0x02
     9e4:	81 83       	std	Z+1, r24	; 0x01
     9e6:	e9 81       	ldd	r30, Y+1	; 0x01
     9e8:	fa 81       	ldd	r31, Y+2	; 0x02
     9ea:	01 80       	ldd	r0, Z+1	; 0x01
     9ec:	f2 81       	ldd	r31, Z+2	; 0x02
     9ee:	e0 2d       	mov	r30, r0
     9f0:	86 81       	ldd	r24, Z+6	; 0x06
     9f2:	97 81       	ldd	r25, Z+7	; 0x07
     9f4:	90 93 69 00 	sts	0x0069, r25
     9f8:	80 93 68 00 	sts	0x0068, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     9fc:	e0 91 68 00 	lds	r30, 0x0068
     a00:	f0 91 69 00 	lds	r31, 0x0069
     a04:	40 81       	ld	r20, Z
     a06:	51 81       	ldd	r21, Z+1	; 0x01
     a08:	80 91 68 00 	lds	r24, 0x0068
     a0c:	90 91 69 00 	lds	r25, 0x0069
     a10:	e0 91 68 00 	lds	r30, 0x0068
     a14:	f0 91 69 00 	lds	r31, 0x0069
     a18:	27 89       	ldd	r18, Z+23	; 0x17
     a1a:	62 2f       	mov	r22, r18
     a1c:	fa 01       	movw	r30, r20
     a1e:	09 95       	icall

	return;
}
     a20:	0f 90       	pop	r0
     a22:	0f 90       	pop	r0
     a24:	cf 91       	pop	r28
     a26:	df 91       	pop	r29
     a28:	08 95       	ret

00000a2a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     a2a:	df 93       	push	r29
     a2c:	cf 93       	push	r28
     a2e:	0f 92       	push	r0
     a30:	cd b7       	in	r28, 0x3d	; 61
     a32:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     a34:	19 82       	std	Y+1, r1	; 0x01
     a36:	13 c0       	rjmp	.+38     	; 0xa5e <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     a38:	89 81       	ldd	r24, Y+1	; 0x01
     a3a:	28 2f       	mov	r18, r24
     a3c:	30 e0       	ldi	r19, 0x00	; 0
     a3e:	c9 01       	movw	r24, r18
     a40:	88 0f       	add	r24, r24
     a42:	99 1f       	adc	r25, r25
     a44:	88 0f       	add	r24, r24
     a46:	99 1f       	adc	r25, r25
     a48:	88 0f       	add	r24, r24
     a4a:	99 1f       	adc	r25, r25
     a4c:	82 0f       	add	r24, r18
     a4e:	93 1f       	adc	r25, r19
     a50:	8f 58       	subi	r24, 0x8F	; 143
     a52:	9f 4f       	sbci	r25, 0xFF	; 255
     a54:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     a58:	89 81       	ldd	r24, Y+1	; 0x01
     a5a:	8f 5f       	subi	r24, 0xFF	; 255
     a5c:	89 83       	std	Y+1, r24	; 0x01
     a5e:	89 81       	ldd	r24, Y+1	; 0x01
     a60:	82 30       	cpi	r24, 0x02	; 2
     a62:	50 f3       	brcs	.-44     	; 0xa38 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     a64:	83 e8       	ldi	r24, 0x83	; 131
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     a6c:	8c e8       	ldi	r24, 0x8C	; 140
     a6e:	90 e0       	ldi	r25, 0x00	; 0
     a70:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     a74:	89 e9       	ldi	r24, 0x99	; 153
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     a7c:	83 e8       	ldi	r24, 0x83	; 131
     a7e:	90 e0       	ldi	r25, 0x00	; 0
     a80:	90 93 96 00 	sts	0x0096, r25
     a84:	80 93 95 00 	sts	0x0095, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     a88:	8c e8       	ldi	r24, 0x8C	; 140
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	90 93 98 00 	sts	0x0098, r25
     a90:	80 93 97 00 	sts	0x0097, r24
}
     a94:	0f 90       	pop	r0
     a96:	cf 91       	pop	r28
     a98:	df 91       	pop	r29
     a9a:	08 95       	ret

00000a9c <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     a9c:	df 93       	push	r29
     a9e:	cf 93       	push	r28
     aa0:	00 d0       	rcall	.+0      	; 0xaa2 <xCoRoutineRemoveFromEventList+0x6>
     aa2:	00 d0       	rcall	.+0      	; 0xaa4 <xCoRoutineRemoveFromEventList+0x8>
     aa4:	0f 92       	push	r0
     aa6:	cd b7       	in	r28, 0x3d	; 61
     aa8:	de b7       	in	r29, 0x3e	; 62
     aaa:	9d 83       	std	Y+5, r25	; 0x05
     aac:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     aae:	ec 81       	ldd	r30, Y+4	; 0x04
     ab0:	fd 81       	ldd	r31, Y+5	; 0x05
     ab2:	05 80       	ldd	r0, Z+5	; 0x05
     ab4:	f6 81       	ldd	r31, Z+6	; 0x06
     ab6:	e0 2d       	mov	r30, r0
     ab8:	86 81       	ldd	r24, Z+6	; 0x06
     aba:	97 81       	ldd	r25, Z+7	; 0x07
     abc:	9b 83       	std	Y+3, r25	; 0x03
     abe:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     ac0:	8a 81       	ldd	r24, Y+2	; 0x02
     ac2:	9b 81       	ldd	r25, Y+3	; 0x03
     ac4:	0c 96       	adiw	r24, 0x0c	; 12
     ac6:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     aca:	8a 81       	ldd	r24, Y+2	; 0x02
     acc:	9b 81       	ldd	r25, Y+3	; 0x03
     ace:	9c 01       	movw	r18, r24
     ad0:	24 5f       	subi	r18, 0xF4	; 244
     ad2:	3f 4f       	sbci	r19, 0xFF	; 255
     ad4:	89 e9       	ldi	r24, 0x99	; 153
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	b9 01       	movw	r22, r18
     ada:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     ade:	ea 81       	ldd	r30, Y+2	; 0x02
     ae0:	fb 81       	ldd	r31, Y+3	; 0x03
     ae2:	96 89       	ldd	r25, Z+22	; 0x16
     ae4:	e0 91 68 00 	lds	r30, 0x0068
     ae8:	f0 91 69 00 	lds	r31, 0x0069
     aec:	86 89       	ldd	r24, Z+22	; 0x16
     aee:	98 17       	cp	r25, r24
     af0:	18 f0       	brcs	.+6      	; 0xaf8 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     af2:	81 e0       	ldi	r24, 0x01	; 1
     af4:	89 83       	std	Y+1, r24	; 0x01
     af6:	01 c0       	rjmp	.+2      	; 0xafa <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     af8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     afa:	89 81       	ldd	r24, Y+1	; 0x01
}
     afc:	0f 90       	pop	r0
     afe:	0f 90       	pop	r0
     b00:	0f 90       	pop	r0
     b02:	0f 90       	pop	r0
     b04:	0f 90       	pop	r0
     b06:	cf 91       	pop	r28
     b08:	df 91       	pop	r29
     b0a:	08 95       	ret

00000b0c <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     b0c:	df 93       	push	r29
     b0e:	cf 93       	push	r28
     b10:	00 d0       	rcall	.+0      	; 0xb12 <pvPortMalloc+0x6>
     b12:	00 d0       	rcall	.+0      	; 0xb14 <pvPortMalloc+0x8>
     b14:	cd b7       	in	r28, 0x3d	; 61
     b16:	de b7       	in	r29, 0x3e	; 62
     b18:	9c 83       	std	Y+4, r25	; 0x04
     b1a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     b1c:	1a 82       	std	Y+2, r1	; 0x02
     b1e:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     b20:	0e 94 f6 10 	call	0x21ec	; 0x21ec <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     b24:	80 91 a2 00 	lds	r24, 0x00A2
     b28:	90 91 a3 00 	lds	r25, 0x00A3
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	3c 81       	ldd	r19, Y+4	; 0x04
     b30:	82 0f       	add	r24, r18
     b32:	93 1f       	adc	r25, r19
     b34:	23 e0       	ldi	r18, 0x03	; 3
     b36:	88 3e       	cpi	r24, 0xE8	; 232
     b38:	92 07       	cpc	r25, r18
     b3a:	18 f5       	brcc	.+70     	; 0xb82 <pvPortMalloc+0x76>
     b3c:	20 91 a2 00 	lds	r18, 0x00A2
     b40:	30 91 a3 00 	lds	r19, 0x00A3
     b44:	8b 81       	ldd	r24, Y+3	; 0x03
     b46:	9c 81       	ldd	r25, Y+4	; 0x04
     b48:	28 0f       	add	r18, r24
     b4a:	39 1f       	adc	r19, r25
     b4c:	80 91 a2 00 	lds	r24, 0x00A2
     b50:	90 91 a3 00 	lds	r25, 0x00A3
     b54:	82 17       	cp	r24, r18
     b56:	93 07       	cpc	r25, r19
     b58:	a0 f4       	brcc	.+40     	; 0xb82 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     b5a:	80 91 a2 00 	lds	r24, 0x00A2
     b5e:	90 91 a3 00 	lds	r25, 0x00A3
     b62:	8c 55       	subi	r24, 0x5C	; 92
     b64:	9f 4f       	sbci	r25, 0xFF	; 255
     b66:	9a 83       	std	Y+2, r25	; 0x02
     b68:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     b6a:	20 91 a2 00 	lds	r18, 0x00A2
     b6e:	30 91 a3 00 	lds	r19, 0x00A3
     b72:	8b 81       	ldd	r24, Y+3	; 0x03
     b74:	9c 81       	ldd	r25, Y+4	; 0x04
     b76:	82 0f       	add	r24, r18
     b78:	93 1f       	adc	r25, r19
     b7a:	90 93 a3 00 	sts	0x00A3, r25
     b7e:	80 93 a2 00 	sts	0x00A2, r24
		}	
	}
	xTaskResumeAll();
     b82:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     b86:	89 81       	ldd	r24, Y+1	; 0x01
     b88:	9a 81       	ldd	r25, Y+2	; 0x02
}
     b8a:	0f 90       	pop	r0
     b8c:	0f 90       	pop	r0
     b8e:	0f 90       	pop	r0
     b90:	0f 90       	pop	r0
     b92:	cf 91       	pop	r28
     b94:	df 91       	pop	r29
     b96:	08 95       	ret

00000b98 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     b98:	df 93       	push	r29
     b9a:	cf 93       	push	r28
     b9c:	00 d0       	rcall	.+0      	; 0xb9e <vPortFree+0x6>
     b9e:	cd b7       	in	r28, 0x3d	; 61
     ba0:	de b7       	in	r29, 0x3e	; 62
     ba2:	9a 83       	std	Y+2, r25	; 0x02
     ba4:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     ba6:	0f 90       	pop	r0
     ba8:	0f 90       	pop	r0
     baa:	cf 91       	pop	r28
     bac:	df 91       	pop	r29
     bae:	08 95       	ret

00000bb0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     bb0:	df 93       	push	r29
     bb2:	cf 93       	push	r28
     bb4:	cd b7       	in	r28, 0x3d	; 61
     bb6:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     bb8:	10 92 a3 00 	sts	0x00A3, r1
     bbc:	10 92 a2 00 	sts	0x00A2, r1
}
     bc0:	cf 91       	pop	r28
     bc2:	df 91       	pop	r29
     bc4:	08 95       	ret

00000bc6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     bc6:	df 93       	push	r29
     bc8:	cf 93       	push	r28
     bca:	cd b7       	in	r28, 0x3d	; 61
     bcc:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     bce:	20 91 a2 00 	lds	r18, 0x00A2
     bd2:	30 91 a3 00 	lds	r19, 0x00A3
     bd6:	88 ee       	ldi	r24, 0xE8	; 232
     bd8:	93 e0       	ldi	r25, 0x03	; 3
     bda:	82 1b       	sub	r24, r18
     bdc:	93 0b       	sbc	r25, r19
}
     bde:	cf 91       	pop	r28
     be0:	df 91       	pop	r29
     be2:	08 95       	ret

00000be4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     be4:	df 93       	push	r29
     be6:	cf 93       	push	r28
     be8:	00 d0       	rcall	.+0      	; 0xbea <vListInitialise+0x6>
     bea:	cd b7       	in	r28, 0x3d	; 61
     bec:	de b7       	in	r29, 0x3e	; 62
     bee:	9a 83       	std	Y+2, r25	; 0x02
     bf0:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     bf2:	89 81       	ldd	r24, Y+1	; 0x01
     bf4:	9a 81       	ldd	r25, Y+2	; 0x02
     bf6:	03 96       	adiw	r24, 0x03	; 3
     bf8:	e9 81       	ldd	r30, Y+1	; 0x01
     bfa:	fa 81       	ldd	r31, Y+2	; 0x02
     bfc:	92 83       	std	Z+2, r25	; 0x02
     bfe:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c00:	e9 81       	ldd	r30, Y+1	; 0x01
     c02:	fa 81       	ldd	r31, Y+2	; 0x02
     c04:	8f ef       	ldi	r24, 0xFF	; 255
     c06:	9f ef       	ldi	r25, 0xFF	; 255
     c08:	94 83       	std	Z+4, r25	; 0x04
     c0a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     c0c:	89 81       	ldd	r24, Y+1	; 0x01
     c0e:	9a 81       	ldd	r25, Y+2	; 0x02
     c10:	03 96       	adiw	r24, 0x03	; 3
     c12:	e9 81       	ldd	r30, Y+1	; 0x01
     c14:	fa 81       	ldd	r31, Y+2	; 0x02
     c16:	96 83       	std	Z+6, r25	; 0x06
     c18:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	03 96       	adiw	r24, 0x03	; 3
     c20:	e9 81       	ldd	r30, Y+1	; 0x01
     c22:	fa 81       	ldd	r31, Y+2	; 0x02
     c24:	90 87       	std	Z+8, r25	; 0x08
     c26:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     c28:	e9 81       	ldd	r30, Y+1	; 0x01
     c2a:	fa 81       	ldd	r31, Y+2	; 0x02
     c2c:	10 82       	st	Z, r1
}
     c2e:	0f 90       	pop	r0
     c30:	0f 90       	pop	r0
     c32:	cf 91       	pop	r28
     c34:	df 91       	pop	r29
     c36:	08 95       	ret

00000c38 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     c38:	df 93       	push	r29
     c3a:	cf 93       	push	r28
     c3c:	00 d0       	rcall	.+0      	; 0xc3e <vListInitialiseItem+0x6>
     c3e:	cd b7       	in	r28, 0x3d	; 61
     c40:	de b7       	in	r29, 0x3e	; 62
     c42:	9a 83       	std	Y+2, r25	; 0x02
     c44:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     c46:	e9 81       	ldd	r30, Y+1	; 0x01
     c48:	fa 81       	ldd	r31, Y+2	; 0x02
     c4a:	11 86       	std	Z+9, r1	; 0x09
     c4c:	10 86       	std	Z+8, r1	; 0x08
}
     c4e:	0f 90       	pop	r0
     c50:	0f 90       	pop	r0
     c52:	cf 91       	pop	r28
     c54:	df 91       	pop	r29
     c56:	08 95       	ret

00000c58 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     c58:	df 93       	push	r29
     c5a:	cf 93       	push	r28
     c5c:	00 d0       	rcall	.+0      	; 0xc5e <vListInsertEnd+0x6>
     c5e:	00 d0       	rcall	.+0      	; 0xc60 <vListInsertEnd+0x8>
     c60:	00 d0       	rcall	.+0      	; 0xc62 <vListInsertEnd+0xa>
     c62:	cd b7       	in	r28, 0x3d	; 61
     c64:	de b7       	in	r29, 0x3e	; 62
     c66:	9c 83       	std	Y+4, r25	; 0x04
     c68:	8b 83       	std	Y+3, r24	; 0x03
     c6a:	7e 83       	std	Y+6, r23	; 0x06
     c6c:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     c6e:	eb 81       	ldd	r30, Y+3	; 0x03
     c70:	fc 81       	ldd	r31, Y+4	; 0x04
     c72:	81 81       	ldd	r24, Z+1	; 0x01
     c74:	92 81       	ldd	r25, Z+2	; 0x02
     c76:	9a 83       	std	Y+2, r25	; 0x02
     c78:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     c7a:	e9 81       	ldd	r30, Y+1	; 0x01
     c7c:	fa 81       	ldd	r31, Y+2	; 0x02
     c7e:	82 81       	ldd	r24, Z+2	; 0x02
     c80:	93 81       	ldd	r25, Z+3	; 0x03
     c82:	ed 81       	ldd	r30, Y+5	; 0x05
     c84:	fe 81       	ldd	r31, Y+6	; 0x06
     c86:	93 83       	std	Z+3, r25	; 0x03
     c88:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     c8a:	eb 81       	ldd	r30, Y+3	; 0x03
     c8c:	fc 81       	ldd	r31, Y+4	; 0x04
     c8e:	81 81       	ldd	r24, Z+1	; 0x01
     c90:	92 81       	ldd	r25, Z+2	; 0x02
     c92:	ed 81       	ldd	r30, Y+5	; 0x05
     c94:	fe 81       	ldd	r31, Y+6	; 0x06
     c96:	95 83       	std	Z+5, r25	; 0x05
     c98:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     c9a:	e9 81       	ldd	r30, Y+1	; 0x01
     c9c:	fa 81       	ldd	r31, Y+2	; 0x02
     c9e:	02 80       	ldd	r0, Z+2	; 0x02
     ca0:	f3 81       	ldd	r31, Z+3	; 0x03
     ca2:	e0 2d       	mov	r30, r0
     ca4:	8d 81       	ldd	r24, Y+5	; 0x05
     ca6:	9e 81       	ldd	r25, Y+6	; 0x06
     ca8:	95 83       	std	Z+5, r25	; 0x05
     caa:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     cac:	8d 81       	ldd	r24, Y+5	; 0x05
     cae:	9e 81       	ldd	r25, Y+6	; 0x06
     cb0:	e9 81       	ldd	r30, Y+1	; 0x01
     cb2:	fa 81       	ldd	r31, Y+2	; 0x02
     cb4:	93 83       	std	Z+3, r25	; 0x03
     cb6:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     cb8:	8d 81       	ldd	r24, Y+5	; 0x05
     cba:	9e 81       	ldd	r25, Y+6	; 0x06
     cbc:	eb 81       	ldd	r30, Y+3	; 0x03
     cbe:	fc 81       	ldd	r31, Y+4	; 0x04
     cc0:	92 83       	std	Z+2, r25	; 0x02
     cc2:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     cc4:	ed 81       	ldd	r30, Y+5	; 0x05
     cc6:	fe 81       	ldd	r31, Y+6	; 0x06
     cc8:	8b 81       	ldd	r24, Y+3	; 0x03
     cca:	9c 81       	ldd	r25, Y+4	; 0x04
     ccc:	91 87       	std	Z+9, r25	; 0x09
     cce:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     cd0:	eb 81       	ldd	r30, Y+3	; 0x03
     cd2:	fc 81       	ldd	r31, Y+4	; 0x04
     cd4:	80 81       	ld	r24, Z
     cd6:	8f 5f       	subi	r24, 0xFF	; 255
     cd8:	eb 81       	ldd	r30, Y+3	; 0x03
     cda:	fc 81       	ldd	r31, Y+4	; 0x04
     cdc:	80 83       	st	Z, r24
}
     cde:	26 96       	adiw	r28, 0x06	; 6
     ce0:	0f b6       	in	r0, 0x3f	; 63
     ce2:	f8 94       	cli
     ce4:	de bf       	out	0x3e, r29	; 62
     ce6:	0f be       	out	0x3f, r0	; 63
     ce8:	cd bf       	out	0x3d, r28	; 61
     cea:	cf 91       	pop	r28
     cec:	df 91       	pop	r29
     cee:	08 95       	ret

00000cf0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     cf0:	df 93       	push	r29
     cf2:	cf 93       	push	r28
     cf4:	cd b7       	in	r28, 0x3d	; 61
     cf6:	de b7       	in	r29, 0x3e	; 62
     cf8:	28 97       	sbiw	r28, 0x08	; 8
     cfa:	0f b6       	in	r0, 0x3f	; 63
     cfc:	f8 94       	cli
     cfe:	de bf       	out	0x3e, r29	; 62
     d00:	0f be       	out	0x3f, r0	; 63
     d02:	cd bf       	out	0x3d, r28	; 61
     d04:	9e 83       	std	Y+6, r25	; 0x06
     d06:	8d 83       	std	Y+5, r24	; 0x05
     d08:	78 87       	std	Y+8, r23	; 0x08
     d0a:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     d0c:	ef 81       	ldd	r30, Y+7	; 0x07
     d0e:	f8 85       	ldd	r31, Y+8	; 0x08
     d10:	80 81       	ld	r24, Z
     d12:	91 81       	ldd	r25, Z+1	; 0x01
     d14:	9a 83       	std	Y+2, r25	; 0x02
     d16:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d18:	89 81       	ldd	r24, Y+1	; 0x01
     d1a:	9a 81       	ldd	r25, Y+2	; 0x02
     d1c:	2f ef       	ldi	r18, 0xFF	; 255
     d1e:	8f 3f       	cpi	r24, 0xFF	; 255
     d20:	92 07       	cpc	r25, r18
     d22:	39 f4       	brne	.+14     	; 0xd32 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d24:	ed 81       	ldd	r30, Y+5	; 0x05
     d26:	fe 81       	ldd	r31, Y+6	; 0x06
     d28:	87 81       	ldd	r24, Z+7	; 0x07
     d2a:	90 85       	ldd	r25, Z+8	; 0x08
     d2c:	9c 83       	std	Y+4, r25	; 0x04
     d2e:	8b 83       	std	Y+3, r24	; 0x03
     d30:	18 c0       	rjmp	.+48     	; 0xd62 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     d32:	8d 81       	ldd	r24, Y+5	; 0x05
     d34:	9e 81       	ldd	r25, Y+6	; 0x06
     d36:	03 96       	adiw	r24, 0x03	; 3
     d38:	9c 83       	std	Y+4, r25	; 0x04
     d3a:	8b 83       	std	Y+3, r24	; 0x03
     d3c:	06 c0       	rjmp	.+12     	; 0xd4a <vListInsert+0x5a>
     d3e:	eb 81       	ldd	r30, Y+3	; 0x03
     d40:	fc 81       	ldd	r31, Y+4	; 0x04
     d42:	82 81       	ldd	r24, Z+2	; 0x02
     d44:	93 81       	ldd	r25, Z+3	; 0x03
     d46:	9c 83       	std	Y+4, r25	; 0x04
     d48:	8b 83       	std	Y+3, r24	; 0x03
     d4a:	eb 81       	ldd	r30, Y+3	; 0x03
     d4c:	fc 81       	ldd	r31, Y+4	; 0x04
     d4e:	02 80       	ldd	r0, Z+2	; 0x02
     d50:	f3 81       	ldd	r31, Z+3	; 0x03
     d52:	e0 2d       	mov	r30, r0
     d54:	20 81       	ld	r18, Z
     d56:	31 81       	ldd	r19, Z+1	; 0x01
     d58:	89 81       	ldd	r24, Y+1	; 0x01
     d5a:	9a 81       	ldd	r25, Y+2	; 0x02
     d5c:	82 17       	cp	r24, r18
     d5e:	93 07       	cpc	r25, r19
     d60:	70 f7       	brcc	.-36     	; 0xd3e <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     d62:	eb 81       	ldd	r30, Y+3	; 0x03
     d64:	fc 81       	ldd	r31, Y+4	; 0x04
     d66:	82 81       	ldd	r24, Z+2	; 0x02
     d68:	93 81       	ldd	r25, Z+3	; 0x03
     d6a:	ef 81       	ldd	r30, Y+7	; 0x07
     d6c:	f8 85       	ldd	r31, Y+8	; 0x08
     d6e:	93 83       	std	Z+3, r25	; 0x03
     d70:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     d72:	ef 81       	ldd	r30, Y+7	; 0x07
     d74:	f8 85       	ldd	r31, Y+8	; 0x08
     d76:	02 80       	ldd	r0, Z+2	; 0x02
     d78:	f3 81       	ldd	r31, Z+3	; 0x03
     d7a:	e0 2d       	mov	r30, r0
     d7c:	8f 81       	ldd	r24, Y+7	; 0x07
     d7e:	98 85       	ldd	r25, Y+8	; 0x08
     d80:	95 83       	std	Z+5, r25	; 0x05
     d82:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     d84:	ef 81       	ldd	r30, Y+7	; 0x07
     d86:	f8 85       	ldd	r31, Y+8	; 0x08
     d88:	8b 81       	ldd	r24, Y+3	; 0x03
     d8a:	9c 81       	ldd	r25, Y+4	; 0x04
     d8c:	95 83       	std	Z+5, r25	; 0x05
     d8e:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     d90:	8f 81       	ldd	r24, Y+7	; 0x07
     d92:	98 85       	ldd	r25, Y+8	; 0x08
     d94:	eb 81       	ldd	r30, Y+3	; 0x03
     d96:	fc 81       	ldd	r31, Y+4	; 0x04
     d98:	93 83       	std	Z+3, r25	; 0x03
     d9a:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d9c:	ef 81       	ldd	r30, Y+7	; 0x07
     d9e:	f8 85       	ldd	r31, Y+8	; 0x08
     da0:	8d 81       	ldd	r24, Y+5	; 0x05
     da2:	9e 81       	ldd	r25, Y+6	; 0x06
     da4:	91 87       	std	Z+9, r25	; 0x09
     da6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     da8:	ed 81       	ldd	r30, Y+5	; 0x05
     daa:	fe 81       	ldd	r31, Y+6	; 0x06
     dac:	80 81       	ld	r24, Z
     dae:	8f 5f       	subi	r24, 0xFF	; 255
     db0:	ed 81       	ldd	r30, Y+5	; 0x05
     db2:	fe 81       	ldd	r31, Y+6	; 0x06
     db4:	80 83       	st	Z, r24
}
     db6:	28 96       	adiw	r28, 0x08	; 8
     db8:	0f b6       	in	r0, 0x3f	; 63
     dba:	f8 94       	cli
     dbc:	de bf       	out	0x3e, r29	; 62
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	cd bf       	out	0x3d, r28	; 61
     dc2:	cf 91       	pop	r28
     dc4:	df 91       	pop	r29
     dc6:	08 95       	ret

00000dc8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     dc8:	df 93       	push	r29
     dca:	cf 93       	push	r28
     dcc:	00 d0       	rcall	.+0      	; 0xdce <vListRemove+0x6>
     dce:	00 d0       	rcall	.+0      	; 0xdd0 <vListRemove+0x8>
     dd0:	cd b7       	in	r28, 0x3d	; 61
     dd2:	de b7       	in	r29, 0x3e	; 62
     dd4:	9c 83       	std	Y+4, r25	; 0x04
     dd6:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     dd8:	eb 81       	ldd	r30, Y+3	; 0x03
     dda:	fc 81       	ldd	r31, Y+4	; 0x04
     ddc:	a2 81       	ldd	r26, Z+2	; 0x02
     dde:	b3 81       	ldd	r27, Z+3	; 0x03
     de0:	eb 81       	ldd	r30, Y+3	; 0x03
     de2:	fc 81       	ldd	r31, Y+4	; 0x04
     de4:	84 81       	ldd	r24, Z+4	; 0x04
     de6:	95 81       	ldd	r25, Z+5	; 0x05
     de8:	15 96       	adiw	r26, 0x05	; 5
     dea:	9c 93       	st	X, r25
     dec:	8e 93       	st	-X, r24
     dee:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     df0:	eb 81       	ldd	r30, Y+3	; 0x03
     df2:	fc 81       	ldd	r31, Y+4	; 0x04
     df4:	a4 81       	ldd	r26, Z+4	; 0x04
     df6:	b5 81       	ldd	r27, Z+5	; 0x05
     df8:	eb 81       	ldd	r30, Y+3	; 0x03
     dfa:	fc 81       	ldd	r31, Y+4	; 0x04
     dfc:	82 81       	ldd	r24, Z+2	; 0x02
     dfe:	93 81       	ldd	r25, Z+3	; 0x03
     e00:	13 96       	adiw	r26, 0x03	; 3
     e02:	9c 93       	st	X, r25
     e04:	8e 93       	st	-X, r24
     e06:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     e08:	eb 81       	ldd	r30, Y+3	; 0x03
     e0a:	fc 81       	ldd	r31, Y+4	; 0x04
     e0c:	80 85       	ldd	r24, Z+8	; 0x08
     e0e:	91 85       	ldd	r25, Z+9	; 0x09
     e10:	9a 83       	std	Y+2, r25	; 0x02
     e12:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e14:	e9 81       	ldd	r30, Y+1	; 0x01
     e16:	fa 81       	ldd	r31, Y+2	; 0x02
     e18:	21 81       	ldd	r18, Z+1	; 0x01
     e1a:	32 81       	ldd	r19, Z+2	; 0x02
     e1c:	8b 81       	ldd	r24, Y+3	; 0x03
     e1e:	9c 81       	ldd	r25, Y+4	; 0x04
     e20:	28 17       	cp	r18, r24
     e22:	39 07       	cpc	r19, r25
     e24:	41 f4       	brne	.+16     	; 0xe36 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e26:	eb 81       	ldd	r30, Y+3	; 0x03
     e28:	fc 81       	ldd	r31, Y+4	; 0x04
     e2a:	84 81       	ldd	r24, Z+4	; 0x04
     e2c:	95 81       	ldd	r25, Z+5	; 0x05
     e2e:	e9 81       	ldd	r30, Y+1	; 0x01
     e30:	fa 81       	ldd	r31, Y+2	; 0x02
     e32:	92 83       	std	Z+2, r25	; 0x02
     e34:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     e36:	eb 81       	ldd	r30, Y+3	; 0x03
     e38:	fc 81       	ldd	r31, Y+4	; 0x04
     e3a:	11 86       	std	Z+9, r1	; 0x09
     e3c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     e3e:	e9 81       	ldd	r30, Y+1	; 0x01
     e40:	fa 81       	ldd	r31, Y+2	; 0x02
     e42:	80 81       	ld	r24, Z
     e44:	81 50       	subi	r24, 0x01	; 1
     e46:	e9 81       	ldd	r30, Y+1	; 0x01
     e48:	fa 81       	ldd	r31, Y+2	; 0x02
     e4a:	80 83       	st	Z, r24
}
     e4c:	0f 90       	pop	r0
     e4e:	0f 90       	pop	r0
     e50:	0f 90       	pop	r0
     e52:	0f 90       	pop	r0
     e54:	cf 91       	pop	r28
     e56:	df 91       	pop	r29
     e58:	08 95       	ret

00000e5a <main>:
void LED_3(void *pv);



void main(void)
{
     e5a:	af 92       	push	r10
     e5c:	bf 92       	push	r11
     e5e:	cf 92       	push	r12
     e60:	df 92       	push	r13
     e62:	ef 92       	push	r14
     e64:	ff 92       	push	r15
     e66:	0f 93       	push	r16
     e68:	df 93       	push	r29
     e6a:	cf 93       	push	r28
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62

	PORT_VoidInit();
     e70:	0e 94 8e 02 	call	0x51c	; 0x51c <PORT_VoidInit>
	//CLCD_voidInit();

//	xTaskCreate(&LCD_1,NULL,250,NULL,0,NULL);
//	xTaskCreate(&LCD_2,NULL,250,NULL,0,NULL);
	xTaskCreate(&LED_3,NULL,100,NULL,3,NULL);
     e74:	8e e4       	ldi	r24, 0x4E	; 78
     e76:	97 e0       	ldi	r25, 0x07	; 7
     e78:	60 e0       	ldi	r22, 0x00	; 0
     e7a:	70 e0       	ldi	r23, 0x00	; 0
     e7c:	44 e6       	ldi	r20, 0x64	; 100
     e7e:	50 e0       	ldi	r21, 0x00	; 0
     e80:	20 e0       	ldi	r18, 0x00	; 0
     e82:	30 e0       	ldi	r19, 0x00	; 0
     e84:	03 e0       	ldi	r16, 0x03	; 3
     e86:	ee 24       	eor	r14, r14
     e88:	ff 24       	eor	r15, r15
     e8a:	cc 24       	eor	r12, r12
     e8c:	dd 24       	eor	r13, r13
     e8e:	aa 24       	eor	r10, r10
     e90:	bb 24       	eor	r11, r11
     e92:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskGenericCreate>
	vTaskStartScheduler();
     e96:	0e 94 b3 10 	call	0x2166	; 0x2166 <vTaskStartScheduler>
     e9a:	ff cf       	rjmp	.-2      	; 0xe9a <main+0x40>

00000e9c <LED_3>:
//		vTaskDelay(1000);
//	}
//
//}
void LED_3(void *pv)
{
     e9c:	df 93       	push	r29
     e9e:	cf 93       	push	r28
     ea0:	00 d0       	rcall	.+0      	; 0xea2 <LED_3+0x6>
     ea2:	cd b7       	in	r28, 0x3d	; 61
     ea4:	de b7       	in	r29, 0x3e	; 62
     ea6:	9a 83       	std	Y+2, r25	; 0x02
     ea8:	89 83       	std	Y+1, r24	; 0x01
	static u8 Local_u8LedState = 0;

	while(1)
	{TOGGLE_BIT(Local_u8LedState,0);
     eaa:	90 91 8c 04 	lds	r25, 0x048C
     eae:	81 e0       	ldi	r24, 0x01	; 1
     eb0:	89 27       	eor	r24, r25
     eb2:	80 93 8c 04 	sts	0x048C, r24
	DIO_u8SetPinValue(DIO_u8PORTC,DIO_u8PIN2,Local_u8LedState);
     eb6:	90 91 8c 04 	lds	r25, 0x048C
     eba:	82 e0       	ldi	r24, 0x02	; 2
     ebc:	62 e0       	ldi	r22, 0x02	; 2
     ebe:	49 2f       	mov	r20, r25
     ec0:	0e 94 49 00 	call	0x92	; 0x92 <DIO_u8SetPinValue>
	vTaskDelay(3000 );
     ec4:	88 eb       	ldi	r24, 0xB8	; 184
     ec6:	9b e0       	ldi	r25, 0x0B	; 11
     ec8:	0e 94 7e 10 	call	0x20fc	; 0x20fc <vTaskDelay>
     ecc:	ee cf       	rjmp	.-36     	; 0xeaa <LED_3+0xe>

00000ece <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     ece:	df 93       	push	r29
     ed0:	cf 93       	push	r28
     ed2:	cd b7       	in	r28, 0x3d	; 61
     ed4:	de b7       	in	r29, 0x3e	; 62
     ed6:	28 97       	sbiw	r28, 0x08	; 8
     ed8:	0f b6       	in	r0, 0x3f	; 63
     eda:	f8 94       	cli
     edc:	de bf       	out	0x3e, r29	; 62
     ede:	0f be       	out	0x3f, r0	; 63
     ee0:	cd bf       	out	0x3d, r28	; 61
     ee2:	9c 83       	std	Y+4, r25	; 0x04
     ee4:	8b 83       	std	Y+3, r24	; 0x03
     ee6:	7e 83       	std	Y+6, r23	; 0x06
     ee8:	6d 83       	std	Y+5, r22	; 0x05
     eea:	58 87       	std	Y+8, r21	; 0x08
     eec:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     eee:	eb 81       	ldd	r30, Y+3	; 0x03
     ef0:	fc 81       	ldd	r31, Y+4	; 0x04
     ef2:	81 e1       	ldi	r24, 0x11	; 17
     ef4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ef6:	8b 81       	ldd	r24, Y+3	; 0x03
     ef8:	9c 81       	ldd	r25, Y+4	; 0x04
     efa:	01 97       	sbiw	r24, 0x01	; 1
     efc:	9c 83       	std	Y+4, r25	; 0x04
     efe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     f00:	eb 81       	ldd	r30, Y+3	; 0x03
     f02:	fc 81       	ldd	r31, Y+4	; 0x04
     f04:	82 e2       	ldi	r24, 0x22	; 34
     f06:	80 83       	st	Z, r24
	pxTopOfStack--;
     f08:	8b 81       	ldd	r24, Y+3	; 0x03
     f0a:	9c 81       	ldd	r25, Y+4	; 0x04
     f0c:	01 97       	sbiw	r24, 0x01	; 1
     f0e:	9c 83       	std	Y+4, r25	; 0x04
     f10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     f12:	eb 81       	ldd	r30, Y+3	; 0x03
     f14:	fc 81       	ldd	r31, Y+4	; 0x04
     f16:	83 e3       	ldi	r24, 0x33	; 51
     f18:	80 83       	st	Z, r24
	pxTopOfStack--;
     f1a:	8b 81       	ldd	r24, Y+3	; 0x03
     f1c:	9c 81       	ldd	r25, Y+4	; 0x04
     f1e:	01 97       	sbiw	r24, 0x01	; 1
     f20:	9c 83       	std	Y+4, r25	; 0x04
     f22:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     f24:	8d 81       	ldd	r24, Y+5	; 0x05
     f26:	9e 81       	ldd	r25, Y+6	; 0x06
     f28:	9a 83       	std	Y+2, r25	; 0x02
     f2a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     f2c:	89 81       	ldd	r24, Y+1	; 0x01
     f2e:	eb 81       	ldd	r30, Y+3	; 0x03
     f30:	fc 81       	ldd	r31, Y+4	; 0x04
     f32:	80 83       	st	Z, r24
	pxTopOfStack--;
     f34:	8b 81       	ldd	r24, Y+3	; 0x03
     f36:	9c 81       	ldd	r25, Y+4	; 0x04
     f38:	01 97       	sbiw	r24, 0x01	; 1
     f3a:	9c 83       	std	Y+4, r25	; 0x04
     f3c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	9a 81       	ldd	r25, Y+2	; 0x02
     f42:	89 2f       	mov	r24, r25
     f44:	99 27       	eor	r25, r25
     f46:	9a 83       	std	Y+2, r25	; 0x02
     f48:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     f4a:	89 81       	ldd	r24, Y+1	; 0x01
     f4c:	eb 81       	ldd	r30, Y+3	; 0x03
     f4e:	fc 81       	ldd	r31, Y+4	; 0x04
     f50:	80 83       	st	Z, r24
	pxTopOfStack--;
     f52:	8b 81       	ldd	r24, Y+3	; 0x03
     f54:	9c 81       	ldd	r25, Y+4	; 0x04
     f56:	01 97       	sbiw	r24, 0x01	; 1
     f58:	9c 83       	std	Y+4, r25	; 0x04
     f5a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     f5c:	eb 81       	ldd	r30, Y+3	; 0x03
     f5e:	fc 81       	ldd	r31, Y+4	; 0x04
     f60:	10 82       	st	Z, r1
	pxTopOfStack--;
     f62:	8b 81       	ldd	r24, Y+3	; 0x03
     f64:	9c 81       	ldd	r25, Y+4	; 0x04
     f66:	01 97       	sbiw	r24, 0x01	; 1
     f68:	9c 83       	std	Y+4, r25	; 0x04
     f6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     f6c:	eb 81       	ldd	r30, Y+3	; 0x03
     f6e:	fc 81       	ldd	r31, Y+4	; 0x04
     f70:	80 e8       	ldi	r24, 0x80	; 128
     f72:	80 83       	st	Z, r24
	pxTopOfStack--;
     f74:	8b 81       	ldd	r24, Y+3	; 0x03
     f76:	9c 81       	ldd	r25, Y+4	; 0x04
     f78:	01 97       	sbiw	r24, 0x01	; 1
     f7a:	9c 83       	std	Y+4, r25	; 0x04
     f7c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     f7e:	eb 81       	ldd	r30, Y+3	; 0x03
     f80:	fc 81       	ldd	r31, Y+4	; 0x04
     f82:	10 82       	st	Z, r1
	pxTopOfStack--;
     f84:	8b 81       	ldd	r24, Y+3	; 0x03
     f86:	9c 81       	ldd	r25, Y+4	; 0x04
     f88:	01 97       	sbiw	r24, 0x01	; 1
     f8a:	9c 83       	std	Y+4, r25	; 0x04
     f8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     f8e:	eb 81       	ldd	r30, Y+3	; 0x03
     f90:	fc 81       	ldd	r31, Y+4	; 0x04
     f92:	82 e0       	ldi	r24, 0x02	; 2
     f94:	80 83       	st	Z, r24
	pxTopOfStack--;
     f96:	8b 81       	ldd	r24, Y+3	; 0x03
     f98:	9c 81       	ldd	r25, Y+4	; 0x04
     f9a:	01 97       	sbiw	r24, 0x01	; 1
     f9c:	9c 83       	std	Y+4, r25	; 0x04
     f9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     fa0:	eb 81       	ldd	r30, Y+3	; 0x03
     fa2:	fc 81       	ldd	r31, Y+4	; 0x04
     fa4:	83 e0       	ldi	r24, 0x03	; 3
     fa6:	80 83       	st	Z, r24
	pxTopOfStack--;
     fa8:	8b 81       	ldd	r24, Y+3	; 0x03
     faa:	9c 81       	ldd	r25, Y+4	; 0x04
     fac:	01 97       	sbiw	r24, 0x01	; 1
     fae:	9c 83       	std	Y+4, r25	; 0x04
     fb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     fb2:	eb 81       	ldd	r30, Y+3	; 0x03
     fb4:	fc 81       	ldd	r31, Y+4	; 0x04
     fb6:	84 e0       	ldi	r24, 0x04	; 4
     fb8:	80 83       	st	Z, r24
	pxTopOfStack--;
     fba:	8b 81       	ldd	r24, Y+3	; 0x03
     fbc:	9c 81       	ldd	r25, Y+4	; 0x04
     fbe:	01 97       	sbiw	r24, 0x01	; 1
     fc0:	9c 83       	std	Y+4, r25	; 0x04
     fc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     fc4:	eb 81       	ldd	r30, Y+3	; 0x03
     fc6:	fc 81       	ldd	r31, Y+4	; 0x04
     fc8:	85 e0       	ldi	r24, 0x05	; 5
     fca:	80 83       	st	Z, r24
	pxTopOfStack--;
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	9c 81       	ldd	r25, Y+4	; 0x04
     fd0:	01 97       	sbiw	r24, 0x01	; 1
     fd2:	9c 83       	std	Y+4, r25	; 0x04
     fd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     fd6:	eb 81       	ldd	r30, Y+3	; 0x03
     fd8:	fc 81       	ldd	r31, Y+4	; 0x04
     fda:	86 e0       	ldi	r24, 0x06	; 6
     fdc:	80 83       	st	Z, r24
	pxTopOfStack--;
     fde:	8b 81       	ldd	r24, Y+3	; 0x03
     fe0:	9c 81       	ldd	r25, Y+4	; 0x04
     fe2:	01 97       	sbiw	r24, 0x01	; 1
     fe4:	9c 83       	std	Y+4, r25	; 0x04
     fe6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     fe8:	eb 81       	ldd	r30, Y+3	; 0x03
     fea:	fc 81       	ldd	r31, Y+4	; 0x04
     fec:	87 e0       	ldi	r24, 0x07	; 7
     fee:	80 83       	st	Z, r24
	pxTopOfStack--;
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	9c 81       	ldd	r25, Y+4	; 0x04
     ff4:	01 97       	sbiw	r24, 0x01	; 1
     ff6:	9c 83       	std	Y+4, r25	; 0x04
     ff8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     ffa:	eb 81       	ldd	r30, Y+3	; 0x03
     ffc:	fc 81       	ldd	r31, Y+4	; 0x04
     ffe:	88 e0       	ldi	r24, 0x08	; 8
    1000:	80 83       	st	Z, r24
	pxTopOfStack--;
    1002:	8b 81       	ldd	r24, Y+3	; 0x03
    1004:	9c 81       	ldd	r25, Y+4	; 0x04
    1006:	01 97       	sbiw	r24, 0x01	; 1
    1008:	9c 83       	std	Y+4, r25	; 0x04
    100a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    100c:	eb 81       	ldd	r30, Y+3	; 0x03
    100e:	fc 81       	ldd	r31, Y+4	; 0x04
    1010:	89 e0       	ldi	r24, 0x09	; 9
    1012:	80 83       	st	Z, r24
	pxTopOfStack--;
    1014:	8b 81       	ldd	r24, Y+3	; 0x03
    1016:	9c 81       	ldd	r25, Y+4	; 0x04
    1018:	01 97       	sbiw	r24, 0x01	; 1
    101a:	9c 83       	std	Y+4, r25	; 0x04
    101c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    101e:	eb 81       	ldd	r30, Y+3	; 0x03
    1020:	fc 81       	ldd	r31, Y+4	; 0x04
    1022:	80 e1       	ldi	r24, 0x10	; 16
    1024:	80 83       	st	Z, r24
	pxTopOfStack--;
    1026:	8b 81       	ldd	r24, Y+3	; 0x03
    1028:	9c 81       	ldd	r25, Y+4	; 0x04
    102a:	01 97       	sbiw	r24, 0x01	; 1
    102c:	9c 83       	std	Y+4, r25	; 0x04
    102e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1030:	eb 81       	ldd	r30, Y+3	; 0x03
    1032:	fc 81       	ldd	r31, Y+4	; 0x04
    1034:	81 e1       	ldi	r24, 0x11	; 17
    1036:	80 83       	st	Z, r24
	pxTopOfStack--;
    1038:	8b 81       	ldd	r24, Y+3	; 0x03
    103a:	9c 81       	ldd	r25, Y+4	; 0x04
    103c:	01 97       	sbiw	r24, 0x01	; 1
    103e:	9c 83       	std	Y+4, r25	; 0x04
    1040:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1042:	eb 81       	ldd	r30, Y+3	; 0x03
    1044:	fc 81       	ldd	r31, Y+4	; 0x04
    1046:	82 e1       	ldi	r24, 0x12	; 18
    1048:	80 83       	st	Z, r24
	pxTopOfStack--;
    104a:	8b 81       	ldd	r24, Y+3	; 0x03
    104c:	9c 81       	ldd	r25, Y+4	; 0x04
    104e:	01 97       	sbiw	r24, 0x01	; 1
    1050:	9c 83       	std	Y+4, r25	; 0x04
    1052:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1054:	eb 81       	ldd	r30, Y+3	; 0x03
    1056:	fc 81       	ldd	r31, Y+4	; 0x04
    1058:	83 e1       	ldi	r24, 0x13	; 19
    105a:	80 83       	st	Z, r24
	pxTopOfStack--;
    105c:	8b 81       	ldd	r24, Y+3	; 0x03
    105e:	9c 81       	ldd	r25, Y+4	; 0x04
    1060:	01 97       	sbiw	r24, 0x01	; 1
    1062:	9c 83       	std	Y+4, r25	; 0x04
    1064:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	84 e1       	ldi	r24, 0x14	; 20
    106c:	80 83       	st	Z, r24
	pxTopOfStack--;
    106e:	8b 81       	ldd	r24, Y+3	; 0x03
    1070:	9c 81       	ldd	r25, Y+4	; 0x04
    1072:	01 97       	sbiw	r24, 0x01	; 1
    1074:	9c 83       	std	Y+4, r25	; 0x04
    1076:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1078:	eb 81       	ldd	r30, Y+3	; 0x03
    107a:	fc 81       	ldd	r31, Y+4	; 0x04
    107c:	85 e1       	ldi	r24, 0x15	; 21
    107e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1080:	8b 81       	ldd	r24, Y+3	; 0x03
    1082:	9c 81       	ldd	r25, Y+4	; 0x04
    1084:	01 97       	sbiw	r24, 0x01	; 1
    1086:	9c 83       	std	Y+4, r25	; 0x04
    1088:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    108a:	eb 81       	ldd	r30, Y+3	; 0x03
    108c:	fc 81       	ldd	r31, Y+4	; 0x04
    108e:	86 e1       	ldi	r24, 0x16	; 22
    1090:	80 83       	st	Z, r24
	pxTopOfStack--;
    1092:	8b 81       	ldd	r24, Y+3	; 0x03
    1094:	9c 81       	ldd	r25, Y+4	; 0x04
    1096:	01 97       	sbiw	r24, 0x01	; 1
    1098:	9c 83       	std	Y+4, r25	; 0x04
    109a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    109c:	eb 81       	ldd	r30, Y+3	; 0x03
    109e:	fc 81       	ldd	r31, Y+4	; 0x04
    10a0:	87 e1       	ldi	r24, 0x17	; 23
    10a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    10a4:	8b 81       	ldd	r24, Y+3	; 0x03
    10a6:	9c 81       	ldd	r25, Y+4	; 0x04
    10a8:	01 97       	sbiw	r24, 0x01	; 1
    10aa:	9c 83       	std	Y+4, r25	; 0x04
    10ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    10ae:	eb 81       	ldd	r30, Y+3	; 0x03
    10b0:	fc 81       	ldd	r31, Y+4	; 0x04
    10b2:	88 e1       	ldi	r24, 0x18	; 24
    10b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    10b6:	8b 81       	ldd	r24, Y+3	; 0x03
    10b8:	9c 81       	ldd	r25, Y+4	; 0x04
    10ba:	01 97       	sbiw	r24, 0x01	; 1
    10bc:	9c 83       	std	Y+4, r25	; 0x04
    10be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    10c0:	eb 81       	ldd	r30, Y+3	; 0x03
    10c2:	fc 81       	ldd	r31, Y+4	; 0x04
    10c4:	89 e1       	ldi	r24, 0x19	; 25
    10c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    10c8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ca:	9c 81       	ldd	r25, Y+4	; 0x04
    10cc:	01 97       	sbiw	r24, 0x01	; 1
    10ce:	9c 83       	std	Y+4, r25	; 0x04
    10d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    10d2:	eb 81       	ldd	r30, Y+3	; 0x03
    10d4:	fc 81       	ldd	r31, Y+4	; 0x04
    10d6:	80 e2       	ldi	r24, 0x20	; 32
    10d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    10da:	8b 81       	ldd	r24, Y+3	; 0x03
    10dc:	9c 81       	ldd	r25, Y+4	; 0x04
    10de:	01 97       	sbiw	r24, 0x01	; 1
    10e0:	9c 83       	std	Y+4, r25	; 0x04
    10e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    10e4:	eb 81       	ldd	r30, Y+3	; 0x03
    10e6:	fc 81       	ldd	r31, Y+4	; 0x04
    10e8:	81 e2       	ldi	r24, 0x21	; 33
    10ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ec:	8b 81       	ldd	r24, Y+3	; 0x03
    10ee:	9c 81       	ldd	r25, Y+4	; 0x04
    10f0:	01 97       	sbiw	r24, 0x01	; 1
    10f2:	9c 83       	std	Y+4, r25	; 0x04
    10f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    10f6:	eb 81       	ldd	r30, Y+3	; 0x03
    10f8:	fc 81       	ldd	r31, Y+4	; 0x04
    10fa:	82 e2       	ldi	r24, 0x22	; 34
    10fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    10fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1100:	9c 81       	ldd	r25, Y+4	; 0x04
    1102:	01 97       	sbiw	r24, 0x01	; 1
    1104:	9c 83       	std	Y+4, r25	; 0x04
    1106:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1108:	eb 81       	ldd	r30, Y+3	; 0x03
    110a:	fc 81       	ldd	r31, Y+4	; 0x04
    110c:	83 e2       	ldi	r24, 0x23	; 35
    110e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1110:	8b 81       	ldd	r24, Y+3	; 0x03
    1112:	9c 81       	ldd	r25, Y+4	; 0x04
    1114:	01 97       	sbiw	r24, 0x01	; 1
    1116:	9c 83       	std	Y+4, r25	; 0x04
    1118:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    111a:	8f 81       	ldd	r24, Y+7	; 0x07
    111c:	98 85       	ldd	r25, Y+8	; 0x08
    111e:	9a 83       	std	Y+2, r25	; 0x02
    1120:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1122:	89 81       	ldd	r24, Y+1	; 0x01
    1124:	eb 81       	ldd	r30, Y+3	; 0x03
    1126:	fc 81       	ldd	r31, Y+4	; 0x04
    1128:	80 83       	st	Z, r24
	pxTopOfStack--;
    112a:	8b 81       	ldd	r24, Y+3	; 0x03
    112c:	9c 81       	ldd	r25, Y+4	; 0x04
    112e:	01 97       	sbiw	r24, 0x01	; 1
    1130:	9c 83       	std	Y+4, r25	; 0x04
    1132:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1134:	89 81       	ldd	r24, Y+1	; 0x01
    1136:	9a 81       	ldd	r25, Y+2	; 0x02
    1138:	89 2f       	mov	r24, r25
    113a:	99 27       	eor	r25, r25
    113c:	9a 83       	std	Y+2, r25	; 0x02
    113e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1140:	89 81       	ldd	r24, Y+1	; 0x01
    1142:	eb 81       	ldd	r30, Y+3	; 0x03
    1144:	fc 81       	ldd	r31, Y+4	; 0x04
    1146:	80 83       	st	Z, r24
	pxTopOfStack--;
    1148:	8b 81       	ldd	r24, Y+3	; 0x03
    114a:	9c 81       	ldd	r25, Y+4	; 0x04
    114c:	01 97       	sbiw	r24, 0x01	; 1
    114e:	9c 83       	std	Y+4, r25	; 0x04
    1150:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1152:	eb 81       	ldd	r30, Y+3	; 0x03
    1154:	fc 81       	ldd	r31, Y+4	; 0x04
    1156:	86 e2       	ldi	r24, 0x26	; 38
    1158:	80 83       	st	Z, r24
	pxTopOfStack--;
    115a:	8b 81       	ldd	r24, Y+3	; 0x03
    115c:	9c 81       	ldd	r25, Y+4	; 0x04
    115e:	01 97       	sbiw	r24, 0x01	; 1
    1160:	9c 83       	std	Y+4, r25	; 0x04
    1162:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1164:	eb 81       	ldd	r30, Y+3	; 0x03
    1166:	fc 81       	ldd	r31, Y+4	; 0x04
    1168:	87 e2       	ldi	r24, 0x27	; 39
    116a:	80 83       	st	Z, r24
	pxTopOfStack--;
    116c:	8b 81       	ldd	r24, Y+3	; 0x03
    116e:	9c 81       	ldd	r25, Y+4	; 0x04
    1170:	01 97       	sbiw	r24, 0x01	; 1
    1172:	9c 83       	std	Y+4, r25	; 0x04
    1174:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1176:	eb 81       	ldd	r30, Y+3	; 0x03
    1178:	fc 81       	ldd	r31, Y+4	; 0x04
    117a:	88 e2       	ldi	r24, 0x28	; 40
    117c:	80 83       	st	Z, r24
	pxTopOfStack--;
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	9c 81       	ldd	r25, Y+4	; 0x04
    1182:	01 97       	sbiw	r24, 0x01	; 1
    1184:	9c 83       	std	Y+4, r25	; 0x04
    1186:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1188:	eb 81       	ldd	r30, Y+3	; 0x03
    118a:	fc 81       	ldd	r31, Y+4	; 0x04
    118c:	89 e2       	ldi	r24, 0x29	; 41
    118e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1190:	8b 81       	ldd	r24, Y+3	; 0x03
    1192:	9c 81       	ldd	r25, Y+4	; 0x04
    1194:	01 97       	sbiw	r24, 0x01	; 1
    1196:	9c 83       	std	Y+4, r25	; 0x04
    1198:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    119a:	eb 81       	ldd	r30, Y+3	; 0x03
    119c:	fc 81       	ldd	r31, Y+4	; 0x04
    119e:	80 e3       	ldi	r24, 0x30	; 48
    11a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    11a2:	8b 81       	ldd	r24, Y+3	; 0x03
    11a4:	9c 81       	ldd	r25, Y+4	; 0x04
    11a6:	01 97       	sbiw	r24, 0x01	; 1
    11a8:	9c 83       	std	Y+4, r25	; 0x04
    11aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    11ac:	eb 81       	ldd	r30, Y+3	; 0x03
    11ae:	fc 81       	ldd	r31, Y+4	; 0x04
    11b0:	81 e3       	ldi	r24, 0x31	; 49
    11b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    11b4:	8b 81       	ldd	r24, Y+3	; 0x03
    11b6:	9c 81       	ldd	r25, Y+4	; 0x04
    11b8:	01 97       	sbiw	r24, 0x01	; 1
    11ba:	9c 83       	std	Y+4, r25	; 0x04
    11bc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    11be:	8b 81       	ldd	r24, Y+3	; 0x03
    11c0:	9c 81       	ldd	r25, Y+4	; 0x04
}
    11c2:	28 96       	adiw	r28, 0x08	; 8
    11c4:	0f b6       	in	r0, 0x3f	; 63
    11c6:	f8 94       	cli
    11c8:	de bf       	out	0x3e, r29	; 62
    11ca:	0f be       	out	0x3f, r0	; 63
    11cc:	cd bf       	out	0x3d, r28	; 61
    11ce:	cf 91       	pop	r28
    11d0:	df 91       	pop	r29
    11d2:	08 95       	ret

000011d4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    11d4:	df 93       	push	r29
    11d6:	cf 93       	push	r28
    11d8:	cd b7       	in	r28, 0x3d	; 61
    11da:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    11dc:	0e 94 da 09 	call	0x13b4	; 0x13b4 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    11e0:	a0 91 8d 04 	lds	r26, 0x048D
    11e4:	b0 91 8e 04 	lds	r27, 0x048E
    11e8:	cd 91       	ld	r28, X+
    11ea:	cd bf       	out	0x3d, r28	; 61
    11ec:	dd 91       	ld	r29, X+
    11ee:	de bf       	out	0x3e, r29	; 62
    11f0:	ff 91       	pop	r31
    11f2:	ef 91       	pop	r30
    11f4:	df 91       	pop	r29
    11f6:	cf 91       	pop	r28
    11f8:	bf 91       	pop	r27
    11fa:	af 91       	pop	r26
    11fc:	9f 91       	pop	r25
    11fe:	8f 91       	pop	r24
    1200:	7f 91       	pop	r23
    1202:	6f 91       	pop	r22
    1204:	5f 91       	pop	r21
    1206:	4f 91       	pop	r20
    1208:	3f 91       	pop	r19
    120a:	2f 91       	pop	r18
    120c:	1f 91       	pop	r17
    120e:	0f 91       	pop	r16
    1210:	ff 90       	pop	r15
    1212:	ef 90       	pop	r14
    1214:	df 90       	pop	r13
    1216:	cf 90       	pop	r12
    1218:	bf 90       	pop	r11
    121a:	af 90       	pop	r10
    121c:	9f 90       	pop	r9
    121e:	8f 90       	pop	r8
    1220:	7f 90       	pop	r7
    1222:	6f 90       	pop	r6
    1224:	5f 90       	pop	r5
    1226:	4f 90       	pop	r4
    1228:	3f 90       	pop	r3
    122a:	2f 90       	pop	r2
    122c:	1f 90       	pop	r1
    122e:	0f 90       	pop	r0
    1230:	0f be       	out	0x3f, r0	; 63
    1232:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1234:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1236:	81 e0       	ldi	r24, 0x01	; 1
}
    1238:	cf 91       	pop	r28
    123a:	df 91       	pop	r29
    123c:	08 95       	ret

0000123e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    123e:	df 93       	push	r29
    1240:	cf 93       	push	r28
    1242:	cd b7       	in	r28, 0x3d	; 61
    1244:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1246:	cf 91       	pop	r28
    1248:	df 91       	pop	r29
    124a:	08 95       	ret

0000124c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    124c:	0f 92       	push	r0
    124e:	0f b6       	in	r0, 0x3f	; 63
    1250:	f8 94       	cli
    1252:	0f 92       	push	r0
    1254:	1f 92       	push	r1
    1256:	11 24       	eor	r1, r1
    1258:	2f 92       	push	r2
    125a:	3f 92       	push	r3
    125c:	4f 92       	push	r4
    125e:	5f 92       	push	r5
    1260:	6f 92       	push	r6
    1262:	7f 92       	push	r7
    1264:	8f 92       	push	r8
    1266:	9f 92       	push	r9
    1268:	af 92       	push	r10
    126a:	bf 92       	push	r11
    126c:	cf 92       	push	r12
    126e:	df 92       	push	r13
    1270:	ef 92       	push	r14
    1272:	ff 92       	push	r15
    1274:	0f 93       	push	r16
    1276:	1f 93       	push	r17
    1278:	2f 93       	push	r18
    127a:	3f 93       	push	r19
    127c:	4f 93       	push	r20
    127e:	5f 93       	push	r21
    1280:	6f 93       	push	r22
    1282:	7f 93       	push	r23
    1284:	8f 93       	push	r24
    1286:	9f 93       	push	r25
    1288:	af 93       	push	r26
    128a:	bf 93       	push	r27
    128c:	cf 93       	push	r28
    128e:	df 93       	push	r29
    1290:	ef 93       	push	r30
    1292:	ff 93       	push	r31
    1294:	a0 91 8d 04 	lds	r26, 0x048D
    1298:	b0 91 8e 04 	lds	r27, 0x048E
    129c:	0d b6       	in	r0, 0x3d	; 61
    129e:	0d 92       	st	X+, r0
    12a0:	0e b6       	in	r0, 0x3e	; 62
    12a2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    12a4:	0e 94 96 12 	call	0x252c	; 0x252c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    12a8:	a0 91 8d 04 	lds	r26, 0x048D
    12ac:	b0 91 8e 04 	lds	r27, 0x048E
    12b0:	cd 91       	ld	r28, X+
    12b2:	cd bf       	out	0x3d, r28	; 61
    12b4:	dd 91       	ld	r29, X+
    12b6:	de bf       	out	0x3e, r29	; 62
    12b8:	ff 91       	pop	r31
    12ba:	ef 91       	pop	r30
    12bc:	df 91       	pop	r29
    12be:	cf 91       	pop	r28
    12c0:	bf 91       	pop	r27
    12c2:	af 91       	pop	r26
    12c4:	9f 91       	pop	r25
    12c6:	8f 91       	pop	r24
    12c8:	7f 91       	pop	r23
    12ca:	6f 91       	pop	r22
    12cc:	5f 91       	pop	r21
    12ce:	4f 91       	pop	r20
    12d0:	3f 91       	pop	r19
    12d2:	2f 91       	pop	r18
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	ef 90       	pop	r14
    12dc:	df 90       	pop	r13
    12de:	cf 90       	pop	r12
    12e0:	bf 90       	pop	r11
    12e2:	af 90       	pop	r10
    12e4:	9f 90       	pop	r9
    12e6:	8f 90       	pop	r8
    12e8:	7f 90       	pop	r7
    12ea:	6f 90       	pop	r6
    12ec:	5f 90       	pop	r5
    12ee:	4f 90       	pop	r4
    12f0:	3f 90       	pop	r3
    12f2:	2f 90       	pop	r2
    12f4:	1f 90       	pop	r1
    12f6:	0f 90       	pop	r0
    12f8:	0f be       	out	0x3f, r0	; 63
    12fa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12fc:	08 95       	ret

000012fe <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12fe:	0f 92       	push	r0
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	0f 92       	push	r0
    1306:	1f 92       	push	r1
    1308:	11 24       	eor	r1, r1
    130a:	2f 92       	push	r2
    130c:	3f 92       	push	r3
    130e:	4f 92       	push	r4
    1310:	5f 92       	push	r5
    1312:	6f 92       	push	r6
    1314:	7f 92       	push	r7
    1316:	8f 92       	push	r8
    1318:	9f 92       	push	r9
    131a:	af 92       	push	r10
    131c:	bf 92       	push	r11
    131e:	cf 92       	push	r12
    1320:	df 92       	push	r13
    1322:	ef 92       	push	r14
    1324:	ff 92       	push	r15
    1326:	0f 93       	push	r16
    1328:	1f 93       	push	r17
    132a:	2f 93       	push	r18
    132c:	3f 93       	push	r19
    132e:	4f 93       	push	r20
    1330:	5f 93       	push	r21
    1332:	6f 93       	push	r22
    1334:	7f 93       	push	r23
    1336:	8f 93       	push	r24
    1338:	9f 93       	push	r25
    133a:	af 93       	push	r26
    133c:	bf 93       	push	r27
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	ef 93       	push	r30
    1344:	ff 93       	push	r31
    1346:	a0 91 8d 04 	lds	r26, 0x048D
    134a:	b0 91 8e 04 	lds	r27, 0x048E
    134e:	0d b6       	in	r0, 0x3d	; 61
    1350:	0d 92       	st	X+, r0
    1352:	0e b6       	in	r0, 0x3e	; 62
    1354:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1356:	0e 94 c1 11 	call	0x2382	; 0x2382 <vTaskIncrementTick>
	vTaskSwitchContext();
    135a:	0e 94 96 12 	call	0x252c	; 0x252c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    135e:	a0 91 8d 04 	lds	r26, 0x048D
    1362:	b0 91 8e 04 	lds	r27, 0x048E
    1366:	cd 91       	ld	r28, X+
    1368:	cd bf       	out	0x3d, r28	; 61
    136a:	dd 91       	ld	r29, X+
    136c:	de bf       	out	0x3e, r29	; 62
    136e:	ff 91       	pop	r31
    1370:	ef 91       	pop	r30
    1372:	df 91       	pop	r29
    1374:	cf 91       	pop	r28
    1376:	bf 91       	pop	r27
    1378:	af 91       	pop	r26
    137a:	9f 91       	pop	r25
    137c:	8f 91       	pop	r24
    137e:	7f 91       	pop	r23
    1380:	6f 91       	pop	r22
    1382:	5f 91       	pop	r21
    1384:	4f 91       	pop	r20
    1386:	3f 91       	pop	r19
    1388:	2f 91       	pop	r18
    138a:	1f 91       	pop	r17
    138c:	0f 91       	pop	r16
    138e:	ff 90       	pop	r15
    1390:	ef 90       	pop	r14
    1392:	df 90       	pop	r13
    1394:	cf 90       	pop	r12
    1396:	bf 90       	pop	r11
    1398:	af 90       	pop	r10
    139a:	9f 90       	pop	r9
    139c:	8f 90       	pop	r8
    139e:	7f 90       	pop	r7
    13a0:	6f 90       	pop	r6
    13a2:	5f 90       	pop	r5
    13a4:	4f 90       	pop	r4
    13a6:	3f 90       	pop	r3
    13a8:	2f 90       	pop	r2
    13aa:	1f 90       	pop	r1
    13ac:	0f 90       	pop	r0
    13ae:	0f be       	out	0x3f, r0	; 63
    13b0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13b2:	08 95       	ret

000013b4 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    13b4:	df 93       	push	r29
    13b6:	cf 93       	push	r28
    13b8:	00 d0       	rcall	.+0      	; 0x13ba <prvSetupTimerInterrupt+0x6>
    13ba:	00 d0       	rcall	.+0      	; 0x13bc <prvSetupTimerInterrupt+0x8>
    13bc:	00 d0       	rcall	.+0      	; 0x13be <prvSetupTimerInterrupt+0xa>
    13be:	cd b7       	in	r28, 0x3d	; 61
    13c0:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    13c2:	80 e8       	ldi	r24, 0x80	; 128
    13c4:	9e e3       	ldi	r25, 0x3E	; 62
    13c6:	a0 e0       	ldi	r26, 0x00	; 0
    13c8:	b0 e0       	ldi	r27, 0x00	; 0
    13ca:	8b 83       	std	Y+3, r24	; 0x03
    13cc:	9c 83       	std	Y+4, r25	; 0x04
    13ce:	ad 83       	std	Y+5, r26	; 0x05
    13d0:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    13d2:	8b 81       	ldd	r24, Y+3	; 0x03
    13d4:	9c 81       	ldd	r25, Y+4	; 0x04
    13d6:	ad 81       	ldd	r26, Y+5	; 0x05
    13d8:	be 81       	ldd	r27, Y+6	; 0x06
    13da:	68 94       	set
    13dc:	15 f8       	bld	r1, 5
    13de:	b6 95       	lsr	r27
    13e0:	a7 95       	ror	r26
    13e2:	97 95       	ror	r25
    13e4:	87 95       	ror	r24
    13e6:	16 94       	lsr	r1
    13e8:	d1 f7       	brne	.-12     	; 0x13de <prvSetupTimerInterrupt+0x2a>
    13ea:	8b 83       	std	Y+3, r24	; 0x03
    13ec:	9c 83       	std	Y+4, r25	; 0x04
    13ee:	ad 83       	std	Y+5, r26	; 0x05
    13f0:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    13f2:	8b 81       	ldd	r24, Y+3	; 0x03
    13f4:	9c 81       	ldd	r25, Y+4	; 0x04
    13f6:	ad 81       	ldd	r26, Y+5	; 0x05
    13f8:	be 81       	ldd	r27, Y+6	; 0x06
    13fa:	01 97       	sbiw	r24, 0x01	; 1
    13fc:	a1 09       	sbc	r26, r1
    13fe:	b1 09       	sbc	r27, r1
    1400:	8b 83       	std	Y+3, r24	; 0x03
    1402:	9c 83       	std	Y+4, r25	; 0x04
    1404:	ad 83       	std	Y+5, r26	; 0x05
    1406:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1408:	8b 81       	ldd	r24, Y+3	; 0x03
    140a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    140c:	8b 81       	ldd	r24, Y+3	; 0x03
    140e:	9c 81       	ldd	r25, Y+4	; 0x04
    1410:	ad 81       	ldd	r26, Y+5	; 0x05
    1412:	be 81       	ldd	r27, Y+6	; 0x06
    1414:	89 2f       	mov	r24, r25
    1416:	9a 2f       	mov	r25, r26
    1418:	ab 2f       	mov	r26, r27
    141a:	bb 27       	eor	r27, r27
    141c:	8b 83       	std	Y+3, r24	; 0x03
    141e:	9c 83       	std	Y+4, r25	; 0x04
    1420:	ad 83       	std	Y+5, r26	; 0x05
    1422:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1424:	8b 81       	ldd	r24, Y+3	; 0x03
    1426:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1428:	eb e4       	ldi	r30, 0x4B	; 75
    142a:	f0 e0       	ldi	r31, 0x00	; 0
    142c:	8a 81       	ldd	r24, Y+2	; 0x02
    142e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1430:	ea e4       	ldi	r30, 0x4A	; 74
    1432:	f0 e0       	ldi	r31, 0x00	; 0
    1434:	89 81       	ldd	r24, Y+1	; 0x01
    1436:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1438:	8b e0       	ldi	r24, 0x0B	; 11
    143a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    143c:	ee e4       	ldi	r30, 0x4E	; 78
    143e:	f0 e0       	ldi	r31, 0x00	; 0
    1440:	89 81       	ldd	r24, Y+1	; 0x01
    1442:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1444:	e9 e5       	ldi	r30, 0x59	; 89
    1446:	f0 e0       	ldi	r31, 0x00	; 0
    1448:	80 81       	ld	r24, Z
    144a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    144c:	89 81       	ldd	r24, Y+1	; 0x01
    144e:	80 61       	ori	r24, 0x10	; 16
    1450:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1452:	e9 e5       	ldi	r30, 0x59	; 89
    1454:	f0 e0       	ldi	r31, 0x00	; 0
    1456:	89 81       	ldd	r24, Y+1	; 0x01
    1458:	80 83       	st	Z, r24
}
    145a:	26 96       	adiw	r28, 0x06	; 6
    145c:	0f b6       	in	r0, 0x3f	; 63
    145e:	f8 94       	cli
    1460:	de bf       	out	0x3e, r29	; 62
    1462:	0f be       	out	0x3f, r0	; 63
    1464:	cd bf       	out	0x3d, r28	; 61
    1466:	cf 91       	pop	r28
    1468:	df 91       	pop	r29
    146a:	08 95       	ret

0000146c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    146c:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYieldFromTick>
		asm volatile ( "reti" );
    1470:	18 95       	reti

00001472 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1472:	df 93       	push	r29
    1474:	cf 93       	push	r28
    1476:	cd b7       	in	r28, 0x3d	; 61
    1478:	de b7       	in	r29, 0x3e	; 62
    147a:	28 97       	sbiw	r28, 0x08	; 8
    147c:	0f b6       	in	r0, 0x3f	; 63
    147e:	f8 94       	cli
    1480:	de bf       	out	0x3e, r29	; 62
    1482:	0f be       	out	0x3f, r0	; 63
    1484:	cd bf       	out	0x3d, r28	; 61
    1486:	8f 83       	std	Y+7, r24	; 0x07
    1488:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    148a:	1a 82       	std	Y+2, r1	; 0x02
    148c:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    148e:	8f 81       	ldd	r24, Y+7	; 0x07
    1490:	88 23       	and	r24, r24
    1492:	09 f4       	brne	.+2      	; 0x1496 <xQueueCreate+0x24>
    1494:	8c c0       	rjmp	.+280    	; 0x15ae <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1496:	8f e1       	ldi	r24, 0x1F	; 31
    1498:	90 e0       	ldi	r25, 0x00	; 0
    149a:	0e 94 86 05 	call	0xb0c	; 0xb0c <pvPortMalloc>
    149e:	9e 83       	std	Y+6, r25	; 0x06
    14a0:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    14a2:	8d 81       	ldd	r24, Y+5	; 0x05
    14a4:	9e 81       	ldd	r25, Y+6	; 0x06
    14a6:	00 97       	sbiw	r24, 0x00	; 0
    14a8:	09 f4       	brne	.+2      	; 0x14ac <xQueueCreate+0x3a>
    14aa:	81 c0       	rjmp	.+258    	; 0x15ae <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    14ac:	8f 81       	ldd	r24, Y+7	; 0x07
    14ae:	28 2f       	mov	r18, r24
    14b0:	30 e0       	ldi	r19, 0x00	; 0
    14b2:	88 85       	ldd	r24, Y+8	; 0x08
    14b4:	88 2f       	mov	r24, r24
    14b6:	90 e0       	ldi	r25, 0x00	; 0
    14b8:	ac 01       	movw	r20, r24
    14ba:	24 9f       	mul	r18, r20
    14bc:	c0 01       	movw	r24, r0
    14be:	25 9f       	mul	r18, r21
    14c0:	90 0d       	add	r25, r0
    14c2:	34 9f       	mul	r19, r20
    14c4:	90 0d       	add	r25, r0
    14c6:	11 24       	eor	r1, r1
    14c8:	01 96       	adiw	r24, 0x01	; 1
    14ca:	9c 83       	std	Y+4, r25	; 0x04
    14cc:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    14ce:	8b 81       	ldd	r24, Y+3	; 0x03
    14d0:	9c 81       	ldd	r25, Y+4	; 0x04
    14d2:	0e 94 86 05 	call	0xb0c	; 0xb0c <pvPortMalloc>
    14d6:	ed 81       	ldd	r30, Y+5	; 0x05
    14d8:	fe 81       	ldd	r31, Y+6	; 0x06
    14da:	91 83       	std	Z+1, r25	; 0x01
    14dc:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    14de:	ed 81       	ldd	r30, Y+5	; 0x05
    14e0:	fe 81       	ldd	r31, Y+6	; 0x06
    14e2:	80 81       	ld	r24, Z
    14e4:	91 81       	ldd	r25, Z+1	; 0x01
    14e6:	00 97       	sbiw	r24, 0x00	; 0
    14e8:	09 f4       	brne	.+2      	; 0x14ec <xQueueCreate+0x7a>
    14ea:	5d c0       	rjmp	.+186    	; 0x15a6 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    14ec:	ed 81       	ldd	r30, Y+5	; 0x05
    14ee:	fe 81       	ldd	r31, Y+6	; 0x06
    14f0:	40 81       	ld	r20, Z
    14f2:	51 81       	ldd	r21, Z+1	; 0x01
    14f4:	8f 81       	ldd	r24, Y+7	; 0x07
    14f6:	28 2f       	mov	r18, r24
    14f8:	30 e0       	ldi	r19, 0x00	; 0
    14fa:	88 85       	ldd	r24, Y+8	; 0x08
    14fc:	88 2f       	mov	r24, r24
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	bc 01       	movw	r22, r24
    1502:	26 9f       	mul	r18, r22
    1504:	c0 01       	movw	r24, r0
    1506:	27 9f       	mul	r18, r23
    1508:	90 0d       	add	r25, r0
    150a:	36 9f       	mul	r19, r22
    150c:	90 0d       	add	r25, r0
    150e:	11 24       	eor	r1, r1
    1510:	84 0f       	add	r24, r20
    1512:	95 1f       	adc	r25, r21
    1514:	ed 81       	ldd	r30, Y+5	; 0x05
    1516:	fe 81       	ldd	r31, Y+6	; 0x06
    1518:	93 83       	std	Z+3, r25	; 0x03
    151a:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    151c:	ed 81       	ldd	r30, Y+5	; 0x05
    151e:	fe 81       	ldd	r31, Y+6	; 0x06
    1520:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1522:	ed 81       	ldd	r30, Y+5	; 0x05
    1524:	fe 81       	ldd	r31, Y+6	; 0x06
    1526:	80 81       	ld	r24, Z
    1528:	91 81       	ldd	r25, Z+1	; 0x01
    152a:	ed 81       	ldd	r30, Y+5	; 0x05
    152c:	fe 81       	ldd	r31, Y+6	; 0x06
    152e:	95 83       	std	Z+5, r25	; 0x05
    1530:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1532:	ed 81       	ldd	r30, Y+5	; 0x05
    1534:	fe 81       	ldd	r31, Y+6	; 0x06
    1536:	40 81       	ld	r20, Z
    1538:	51 81       	ldd	r21, Z+1	; 0x01
    153a:	8f 81       	ldd	r24, Y+7	; 0x07
    153c:	88 2f       	mov	r24, r24
    153e:	90 e0       	ldi	r25, 0x00	; 0
    1540:	9c 01       	movw	r18, r24
    1542:	21 50       	subi	r18, 0x01	; 1
    1544:	30 40       	sbci	r19, 0x00	; 0
    1546:	88 85       	ldd	r24, Y+8	; 0x08
    1548:	88 2f       	mov	r24, r24
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	bc 01       	movw	r22, r24
    154e:	26 9f       	mul	r18, r22
    1550:	c0 01       	movw	r24, r0
    1552:	27 9f       	mul	r18, r23
    1554:	90 0d       	add	r25, r0
    1556:	36 9f       	mul	r19, r22
    1558:	90 0d       	add	r25, r0
    155a:	11 24       	eor	r1, r1
    155c:	84 0f       	add	r24, r20
    155e:	95 1f       	adc	r25, r21
    1560:	ed 81       	ldd	r30, Y+5	; 0x05
    1562:	fe 81       	ldd	r31, Y+6	; 0x06
    1564:	97 83       	std	Z+7, r25	; 0x07
    1566:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1568:	ed 81       	ldd	r30, Y+5	; 0x05
    156a:	fe 81       	ldd	r31, Y+6	; 0x06
    156c:	8f 81       	ldd	r24, Y+7	; 0x07
    156e:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1570:	ed 81       	ldd	r30, Y+5	; 0x05
    1572:	fe 81       	ldd	r31, Y+6	; 0x06
    1574:	88 85       	ldd	r24, Y+8	; 0x08
    1576:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1578:	ed 81       	ldd	r30, Y+5	; 0x05
    157a:	fe 81       	ldd	r31, Y+6	; 0x06
    157c:	8f ef       	ldi	r24, 0xFF	; 255
    157e:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1580:	ed 81       	ldd	r30, Y+5	; 0x05
    1582:	fe 81       	ldd	r31, Y+6	; 0x06
    1584:	8f ef       	ldi	r24, 0xFF	; 255
    1586:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1588:	8d 81       	ldd	r24, Y+5	; 0x05
    158a:	9e 81       	ldd	r25, Y+6	; 0x06
    158c:	08 96       	adiw	r24, 0x08	; 8
    158e:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1592:	8d 81       	ldd	r24, Y+5	; 0x05
    1594:	9e 81       	ldd	r25, Y+6	; 0x06
    1596:	41 96       	adiw	r24, 0x11	; 17
    1598:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    159c:	8d 81       	ldd	r24, Y+5	; 0x05
    159e:	9e 81       	ldd	r25, Y+6	; 0x06
    15a0:	9a 83       	std	Y+2, r25	; 0x02
    15a2:	89 83       	std	Y+1, r24	; 0x01
    15a4:	04 c0       	rjmp	.+8      	; 0x15ae <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    15a6:	8d 81       	ldd	r24, Y+5	; 0x05
    15a8:	9e 81       	ldd	r25, Y+6	; 0x06
    15aa:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    15ae:	89 81       	ldd	r24, Y+1	; 0x01
    15b0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    15b2:	28 96       	adiw	r28, 0x08	; 8
    15b4:	0f b6       	in	r0, 0x3f	; 63
    15b6:	f8 94       	cli
    15b8:	de bf       	out	0x3e, r29	; 62
    15ba:	0f be       	out	0x3f, r0	; 63
    15bc:	cd bf       	out	0x3d, r28	; 61
    15be:	cf 91       	pop	r28
    15c0:	df 91       	pop	r29
    15c2:	08 95       	ret

000015c4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    15c4:	df 93       	push	r29
    15c6:	cf 93       	push	r28
    15c8:	cd b7       	in	r28, 0x3d	; 61
    15ca:	de b7       	in	r29, 0x3e	; 62
    15cc:	2c 97       	sbiw	r28, 0x0c	; 12
    15ce:	0f b6       	in	r0, 0x3f	; 63
    15d0:	f8 94       	cli
    15d2:	de bf       	out	0x3e, r29	; 62
    15d4:	0f be       	out	0x3f, r0	; 63
    15d6:	cd bf       	out	0x3d, r28	; 61
    15d8:	9e 83       	std	Y+6, r25	; 0x06
    15da:	8d 83       	std	Y+5, r24	; 0x05
    15dc:	78 87       	std	Y+8, r23	; 0x08
    15de:	6f 83       	std	Y+7, r22	; 0x07
    15e0:	5a 87       	std	Y+10, r21	; 0x0a
    15e2:	49 87       	std	Y+9, r20	; 0x09
    15e4:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    15e6:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    15e8:	0f b6       	in	r0, 0x3f	; 63
    15ea:	f8 94       	cli
    15ec:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    15ee:	ed 81       	ldd	r30, Y+5	; 0x05
    15f0:	fe 81       	ldd	r31, Y+6	; 0x06
    15f2:	92 8d       	ldd	r25, Z+26	; 0x1a
    15f4:	ed 81       	ldd	r30, Y+5	; 0x05
    15f6:	fe 81       	ldd	r31, Y+6	; 0x06
    15f8:	83 8d       	ldd	r24, Z+27	; 0x1b
    15fa:	98 17       	cp	r25, r24
    15fc:	d8 f4       	brcc	.+54     	; 0x1634 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    15fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1600:	9e 81       	ldd	r25, Y+6	; 0x06
    1602:	2f 81       	ldd	r18, Y+7	; 0x07
    1604:	38 85       	ldd	r19, Y+8	; 0x08
    1606:	b9 01       	movw	r22, r18
    1608:	4b 85       	ldd	r20, Y+11	; 0x0b
    160a:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    160e:	ed 81       	ldd	r30, Y+5	; 0x05
    1610:	fe 81       	ldd	r31, Y+6	; 0x06
    1612:	81 89       	ldd	r24, Z+17	; 0x11
    1614:	88 23       	and	r24, r24
    1616:	49 f0       	breq	.+18     	; 0x162a <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1618:	8d 81       	ldd	r24, Y+5	; 0x05
    161a:	9e 81       	ldd	r25, Y+6	; 0x06
    161c:	41 96       	adiw	r24, 0x11	; 17
    161e:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskRemoveFromEventList>
    1622:	81 30       	cpi	r24, 0x01	; 1
    1624:	11 f4       	brne	.+4      	; 0x162a <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1626:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    162a:	0f 90       	pop	r0
    162c:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    162e:	81 e0       	ldi	r24, 0x01	; 1
    1630:	8c 87       	std	Y+12, r24	; 0x0c
    1632:	5c c0       	rjmp	.+184    	; 0x16ec <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1634:	89 85       	ldd	r24, Y+9	; 0x09
    1636:	9a 85       	ldd	r25, Y+10	; 0x0a
    1638:	00 97       	sbiw	r24, 0x00	; 0
    163a:	21 f4       	brne	.+8      	; 0x1644 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    163c:	0f 90       	pop	r0
    163e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1640:	1c 86       	std	Y+12, r1	; 0x0c
    1642:	54 c0       	rjmp	.+168    	; 0x16ec <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1644:	89 81       	ldd	r24, Y+1	; 0x01
    1646:	88 23       	and	r24, r24
    1648:	31 f4       	brne	.+12     	; 0x1656 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    164a:	ce 01       	movw	r24, r28
    164c:	02 96       	adiw	r24, 0x02	; 2
    164e:	0e 94 9a 13 	call	0x2734	; 0x2734 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1652:	81 e0       	ldi	r24, 0x01	; 1
    1654:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1656:	0f 90       	pop	r0
    1658:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    165a:	0e 94 f6 10 	call	0x21ec	; 0x21ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	f8 94       	cli
    1662:	0f 92       	push	r0
    1664:	ed 81       	ldd	r30, Y+5	; 0x05
    1666:	fe 81       	ldd	r31, Y+6	; 0x06
    1668:	85 8d       	ldd	r24, Z+29	; 0x1d
    166a:	8f 3f       	cpi	r24, 0xFF	; 255
    166c:	19 f4       	brne	.+6      	; 0x1674 <xQueueGenericSend+0xb0>
    166e:	ed 81       	ldd	r30, Y+5	; 0x05
    1670:	fe 81       	ldd	r31, Y+6	; 0x06
    1672:	15 8e       	std	Z+29, r1	; 0x1d
    1674:	ed 81       	ldd	r30, Y+5	; 0x05
    1676:	fe 81       	ldd	r31, Y+6	; 0x06
    1678:	86 8d       	ldd	r24, Z+30	; 0x1e
    167a:	8f 3f       	cpi	r24, 0xFF	; 255
    167c:	19 f4       	brne	.+6      	; 0x1684 <xQueueGenericSend+0xc0>
    167e:	ed 81       	ldd	r30, Y+5	; 0x05
    1680:	fe 81       	ldd	r31, Y+6	; 0x06
    1682:	16 8e       	std	Z+30, r1	; 0x1e
    1684:	0f 90       	pop	r0
    1686:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1688:	ce 01       	movw	r24, r28
    168a:	02 96       	adiw	r24, 0x02	; 2
    168c:	9e 01       	movw	r18, r28
    168e:	27 5f       	subi	r18, 0xF7	; 247
    1690:	3f 4f       	sbci	r19, 0xFF	; 255
    1692:	b9 01       	movw	r22, r18
    1694:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskCheckForTimeOut>
    1698:	88 23       	and	r24, r24
    169a:	09 f5       	brne	.+66     	; 0x16de <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    169c:	8d 81       	ldd	r24, Y+5	; 0x05
    169e:	9e 81       	ldd	r25, Y+6	; 0x06
    16a0:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <prvIsQueueFull>
    16a4:	88 23       	and	r24, r24
    16a6:	a1 f0       	breq	.+40     	; 0x16d0 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16a8:	8d 81       	ldd	r24, Y+5	; 0x05
    16aa:	9e 81       	ldd	r25, Y+6	; 0x06
    16ac:	08 96       	adiw	r24, 0x08	; 8
    16ae:	29 85       	ldd	r18, Y+9	; 0x09
    16b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    16b2:	b9 01       	movw	r22, r18
    16b4:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    16b8:	8d 81       	ldd	r24, Y+5	; 0x05
    16ba:	9e 81       	ldd	r25, Y+6	; 0x06
    16bc:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    16c0:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>
    16c4:	88 23       	and	r24, r24
    16c6:	09 f0       	breq	.+2      	; 0x16ca <xQueueGenericSend+0x106>
    16c8:	8f cf       	rjmp	.-226    	; 0x15e8 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    16ca:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
    16ce:	8c cf       	rjmp	.-232    	; 0x15e8 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    16d0:	8d 81       	ldd	r24, Y+5	; 0x05
    16d2:	9e 81       	ldd	r25, Y+6	; 0x06
    16d4:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16d8:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>
    16dc:	85 cf       	rjmp	.-246    	; 0x15e8 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    16de:	8d 81       	ldd	r24, Y+5	; 0x05
    16e0:	9e 81       	ldd	r25, Y+6	; 0x06
    16e2:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16e6:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    16ea:	1c 86       	std	Y+12, r1	; 0x0c
    16ec:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    16ee:	2c 96       	adiw	r28, 0x0c	; 12
    16f0:	0f b6       	in	r0, 0x3f	; 63
    16f2:	f8 94       	cli
    16f4:	de bf       	out	0x3e, r29	; 62
    16f6:	0f be       	out	0x3f, r0	; 63
    16f8:	cd bf       	out	0x3d, r28	; 61
    16fa:	cf 91       	pop	r28
    16fc:	df 91       	pop	r29
    16fe:	08 95       	ret

00001700 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1700:	df 93       	push	r29
    1702:	cf 93       	push	r28
    1704:	cd b7       	in	r28, 0x3d	; 61
    1706:	de b7       	in	r29, 0x3e	; 62
    1708:	29 97       	sbiw	r28, 0x09	; 9
    170a:	0f b6       	in	r0, 0x3f	; 63
    170c:	f8 94       	cli
    170e:	de bf       	out	0x3e, r29	; 62
    1710:	0f be       	out	0x3f, r0	; 63
    1712:	cd bf       	out	0x3d, r28	; 61
    1714:	9c 83       	std	Y+4, r25	; 0x04
    1716:	8b 83       	std	Y+3, r24	; 0x03
    1718:	7e 83       	std	Y+6, r23	; 0x06
    171a:	6d 83       	std	Y+5, r22	; 0x05
    171c:	58 87       	std	Y+8, r21	; 0x08
    171e:	4f 83       	std	Y+7, r20	; 0x07
    1720:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1722:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1724:	eb 81       	ldd	r30, Y+3	; 0x03
    1726:	fc 81       	ldd	r31, Y+4	; 0x04
    1728:	92 8d       	ldd	r25, Z+26	; 0x1a
    172a:	eb 81       	ldd	r30, Y+3	; 0x03
    172c:	fc 81       	ldd	r31, Y+4	; 0x04
    172e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1730:	98 17       	cp	r25, r24
    1732:	40 f5       	brcc	.+80     	; 0x1784 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1734:	8b 81       	ldd	r24, Y+3	; 0x03
    1736:	9c 81       	ldd	r25, Y+4	; 0x04
    1738:	2d 81       	ldd	r18, Y+5	; 0x05
    173a:	3e 81       	ldd	r19, Y+6	; 0x06
    173c:	b9 01       	movw	r22, r18
    173e:	49 85       	ldd	r20, Y+9	; 0x09
    1740:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1744:	eb 81       	ldd	r30, Y+3	; 0x03
    1746:	fc 81       	ldd	r31, Y+4	; 0x04
    1748:	86 8d       	ldd	r24, Z+30	; 0x1e
    174a:	8f 3f       	cpi	r24, 0xFF	; 255
    174c:	89 f4       	brne	.+34     	; 0x1770 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    174e:	eb 81       	ldd	r30, Y+3	; 0x03
    1750:	fc 81       	ldd	r31, Y+4	; 0x04
    1752:	81 89       	ldd	r24, Z+17	; 0x11
    1754:	88 23       	and	r24, r24
    1756:	99 f0       	breq	.+38     	; 0x177e <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1758:	8b 81       	ldd	r24, Y+3	; 0x03
    175a:	9c 81       	ldd	r25, Y+4	; 0x04
    175c:	41 96       	adiw	r24, 0x11	; 17
    175e:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskRemoveFromEventList>
    1762:	88 23       	and	r24, r24
    1764:	61 f0       	breq	.+24     	; 0x177e <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1766:	ef 81       	ldd	r30, Y+7	; 0x07
    1768:	f8 85       	ldd	r31, Y+8	; 0x08
    176a:	81 e0       	ldi	r24, 0x01	; 1
    176c:	80 83       	st	Z, r24
    176e:	07 c0       	rjmp	.+14     	; 0x177e <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1770:	eb 81       	ldd	r30, Y+3	; 0x03
    1772:	fc 81       	ldd	r31, Y+4	; 0x04
    1774:	86 8d       	ldd	r24, Z+30	; 0x1e
    1776:	8f 5f       	subi	r24, 0xFF	; 255
    1778:	eb 81       	ldd	r30, Y+3	; 0x03
    177a:	fc 81       	ldd	r31, Y+4	; 0x04
    177c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    177e:	81 e0       	ldi	r24, 0x01	; 1
    1780:	8a 83       	std	Y+2, r24	; 0x02
    1782:	01 c0       	rjmp	.+2      	; 0x1786 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1784:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1786:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1788:	29 96       	adiw	r28, 0x09	; 9
    178a:	0f b6       	in	r0, 0x3f	; 63
    178c:	f8 94       	cli
    178e:	de bf       	out	0x3e, r29	; 62
    1790:	0f be       	out	0x3f, r0	; 63
    1792:	cd bf       	out	0x3d, r28	; 61
    1794:	cf 91       	pop	r28
    1796:	df 91       	pop	r29
    1798:	08 95       	ret

0000179a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    179a:	df 93       	push	r29
    179c:	cf 93       	push	r28
    179e:	cd b7       	in	r28, 0x3d	; 61
    17a0:	de b7       	in	r29, 0x3e	; 62
    17a2:	2e 97       	sbiw	r28, 0x0e	; 14
    17a4:	0f b6       	in	r0, 0x3f	; 63
    17a6:	f8 94       	cli
    17a8:	de bf       	out	0x3e, r29	; 62
    17aa:	0f be       	out	0x3f, r0	; 63
    17ac:	cd bf       	out	0x3d, r28	; 61
    17ae:	98 87       	std	Y+8, r25	; 0x08
    17b0:	8f 83       	std	Y+7, r24	; 0x07
    17b2:	7a 87       	std	Y+10, r23	; 0x0a
    17b4:	69 87       	std	Y+9, r22	; 0x09
    17b6:	5c 87       	std	Y+12, r21	; 0x0c
    17b8:	4b 87       	std	Y+11, r20	; 0x0b
    17ba:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    17bc:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    17be:	0f b6       	in	r0, 0x3f	; 63
    17c0:	f8 94       	cli
    17c2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    17c4:	ef 81       	ldd	r30, Y+7	; 0x07
    17c6:	f8 85       	ldd	r31, Y+8	; 0x08
    17c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    17ca:	88 23       	and	r24, r24
    17cc:	09 f4       	brne	.+2      	; 0x17d0 <xQueueGenericReceive+0x36>
    17ce:	3f c0       	rjmp	.+126    	; 0x184e <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    17d0:	ef 81       	ldd	r30, Y+7	; 0x07
    17d2:	f8 85       	ldd	r31, Y+8	; 0x08
    17d4:	86 81       	ldd	r24, Z+6	; 0x06
    17d6:	97 81       	ldd	r25, Z+7	; 0x07
    17d8:	9a 83       	std	Y+2, r25	; 0x02
    17da:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    17dc:	8f 81       	ldd	r24, Y+7	; 0x07
    17de:	98 85       	ldd	r25, Y+8	; 0x08
    17e0:	29 85       	ldd	r18, Y+9	; 0x09
    17e2:	3a 85       	ldd	r19, Y+10	; 0x0a
    17e4:	b9 01       	movw	r22, r18
    17e6:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    17ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    17ec:	88 23       	and	r24, r24
    17ee:	b1 f4       	brne	.+44     	; 0x181c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    17f0:	ef 81       	ldd	r30, Y+7	; 0x07
    17f2:	f8 85       	ldd	r31, Y+8	; 0x08
    17f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    17f6:	81 50       	subi	r24, 0x01	; 1
    17f8:	ef 81       	ldd	r30, Y+7	; 0x07
    17fa:	f8 85       	ldd	r31, Y+8	; 0x08
    17fc:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17fe:	ef 81       	ldd	r30, Y+7	; 0x07
    1800:	f8 85       	ldd	r31, Y+8	; 0x08
    1802:	80 85       	ldd	r24, Z+8	; 0x08
    1804:	88 23       	and	r24, r24
    1806:	f1 f0       	breq	.+60     	; 0x1844 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1808:	8f 81       	ldd	r24, Y+7	; 0x07
    180a:	98 85       	ldd	r25, Y+8	; 0x08
    180c:	08 96       	adiw	r24, 0x08	; 8
    180e:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskRemoveFromEventList>
    1812:	81 30       	cpi	r24, 0x01	; 1
    1814:	b9 f4       	brne	.+46     	; 0x1844 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1816:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
    181a:	14 c0       	rjmp	.+40     	; 0x1844 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    181c:	ef 81       	ldd	r30, Y+7	; 0x07
    181e:	f8 85       	ldd	r31, Y+8	; 0x08
    1820:	89 81       	ldd	r24, Y+1	; 0x01
    1822:	9a 81       	ldd	r25, Y+2	; 0x02
    1824:	97 83       	std	Z+7, r25	; 0x07
    1826:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1828:	ef 81       	ldd	r30, Y+7	; 0x07
    182a:	f8 85       	ldd	r31, Y+8	; 0x08
    182c:	81 89       	ldd	r24, Z+17	; 0x11
    182e:	88 23       	and	r24, r24
    1830:	49 f0       	breq	.+18     	; 0x1844 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1832:	8f 81       	ldd	r24, Y+7	; 0x07
    1834:	98 85       	ldd	r25, Y+8	; 0x08
    1836:	41 96       	adiw	r24, 0x11	; 17
    1838:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskRemoveFromEventList>
    183c:	88 23       	and	r24, r24
    183e:	11 f0       	breq	.+4      	; 0x1844 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1840:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1844:	0f 90       	pop	r0
    1846:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1848:	81 e0       	ldi	r24, 0x01	; 1
    184a:	8e 87       	std	Y+14, r24	; 0x0e
    184c:	5c c0       	rjmp	.+184    	; 0x1906 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    184e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1850:	9c 85       	ldd	r25, Y+12	; 0x0c
    1852:	00 97       	sbiw	r24, 0x00	; 0
    1854:	21 f4       	brne	.+8      	; 0x185e <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1856:	0f 90       	pop	r0
    1858:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    185a:	1e 86       	std	Y+14, r1	; 0x0e
    185c:	54 c0       	rjmp	.+168    	; 0x1906 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    185e:	8b 81       	ldd	r24, Y+3	; 0x03
    1860:	88 23       	and	r24, r24
    1862:	31 f4       	brne	.+12     	; 0x1870 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1864:	ce 01       	movw	r24, r28
    1866:	04 96       	adiw	r24, 0x04	; 4
    1868:	0e 94 9a 13 	call	0x2734	; 0x2734 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    186c:	81 e0       	ldi	r24, 0x01	; 1
    186e:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1870:	0f 90       	pop	r0
    1872:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1874:	0e 94 f6 10 	call	0x21ec	; 0x21ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1878:	0f b6       	in	r0, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	0f 92       	push	r0
    187e:	ef 81       	ldd	r30, Y+7	; 0x07
    1880:	f8 85       	ldd	r31, Y+8	; 0x08
    1882:	85 8d       	ldd	r24, Z+29	; 0x1d
    1884:	8f 3f       	cpi	r24, 0xFF	; 255
    1886:	19 f4       	brne	.+6      	; 0x188e <xQueueGenericReceive+0xf4>
    1888:	ef 81       	ldd	r30, Y+7	; 0x07
    188a:	f8 85       	ldd	r31, Y+8	; 0x08
    188c:	15 8e       	std	Z+29, r1	; 0x1d
    188e:	ef 81       	ldd	r30, Y+7	; 0x07
    1890:	f8 85       	ldd	r31, Y+8	; 0x08
    1892:	86 8d       	ldd	r24, Z+30	; 0x1e
    1894:	8f 3f       	cpi	r24, 0xFF	; 255
    1896:	19 f4       	brne	.+6      	; 0x189e <xQueueGenericReceive+0x104>
    1898:	ef 81       	ldd	r30, Y+7	; 0x07
    189a:	f8 85       	ldd	r31, Y+8	; 0x08
    189c:	16 8e       	std	Z+30, r1	; 0x1e
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18a2:	ce 01       	movw	r24, r28
    18a4:	04 96       	adiw	r24, 0x04	; 4
    18a6:	9e 01       	movw	r18, r28
    18a8:	25 5f       	subi	r18, 0xF5	; 245
    18aa:	3f 4f       	sbci	r19, 0xFF	; 255
    18ac:	b9 01       	movw	r22, r18
    18ae:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskCheckForTimeOut>
    18b2:	88 23       	and	r24, r24
    18b4:	09 f5       	brne	.+66     	; 0x18f8 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18b6:	8f 81       	ldd	r24, Y+7	; 0x07
    18b8:	98 85       	ldd	r25, Y+8	; 0x08
    18ba:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <prvIsQueueEmpty>
    18be:	88 23       	and	r24, r24
    18c0:	a1 f0       	breq	.+40     	; 0x18ea <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18c2:	8f 81       	ldd	r24, Y+7	; 0x07
    18c4:	98 85       	ldd	r25, Y+8	; 0x08
    18c6:	41 96       	adiw	r24, 0x11	; 17
    18c8:	2b 85       	ldd	r18, Y+11	; 0x0b
    18ca:	3c 85       	ldd	r19, Y+12	; 0x0c
    18cc:	b9 01       	movw	r22, r18
    18ce:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18d2:	8f 81       	ldd	r24, Y+7	; 0x07
    18d4:	98 85       	ldd	r25, Y+8	; 0x08
    18d6:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18da:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>
    18de:	88 23       	and	r24, r24
    18e0:	09 f0       	breq	.+2      	; 0x18e4 <xQueueGenericReceive+0x14a>
    18e2:	6d cf       	rjmp	.-294    	; 0x17be <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    18e4:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
    18e8:	6a cf       	rjmp	.-300    	; 0x17be <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18ea:	8f 81       	ldd	r24, Y+7	; 0x07
    18ec:	98 85       	ldd	r25, Y+8	; 0x08
    18ee:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18f2:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>
    18f6:	63 cf       	rjmp	.-314    	; 0x17be <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    18f8:	8f 81       	ldd	r24, Y+7	; 0x07
    18fa:	98 85       	ldd	r25, Y+8	; 0x08
    18fc:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1900:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1904:	1e 86       	std	Y+14, r1	; 0x0e
    1906:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1908:	2e 96       	adiw	r28, 0x0e	; 14
    190a:	0f b6       	in	r0, 0x3f	; 63
    190c:	f8 94       	cli
    190e:	de bf       	out	0x3e, r29	; 62
    1910:	0f be       	out	0x3f, r0	; 63
    1912:	cd bf       	out	0x3d, r28	; 61
    1914:	cf 91       	pop	r28
    1916:	df 91       	pop	r29
    1918:	08 95       	ret

0000191a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    191a:	df 93       	push	r29
    191c:	cf 93       	push	r28
    191e:	cd b7       	in	r28, 0x3d	; 61
    1920:	de b7       	in	r29, 0x3e	; 62
    1922:	28 97       	sbiw	r28, 0x08	; 8
    1924:	0f b6       	in	r0, 0x3f	; 63
    1926:	f8 94       	cli
    1928:	de bf       	out	0x3e, r29	; 62
    192a:	0f be       	out	0x3f, r0	; 63
    192c:	cd bf       	out	0x3d, r28	; 61
    192e:	9c 83       	std	Y+4, r25	; 0x04
    1930:	8b 83       	std	Y+3, r24	; 0x03
    1932:	7e 83       	std	Y+6, r23	; 0x06
    1934:	6d 83       	std	Y+5, r22	; 0x05
    1936:	58 87       	std	Y+8, r21	; 0x08
    1938:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    193a:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    193c:	eb 81       	ldd	r30, Y+3	; 0x03
    193e:	fc 81       	ldd	r31, Y+4	; 0x04
    1940:	82 8d       	ldd	r24, Z+26	; 0x1a
    1942:	88 23       	and	r24, r24
    1944:	71 f1       	breq	.+92     	; 0x19a2 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1946:	8b 81       	ldd	r24, Y+3	; 0x03
    1948:	9c 81       	ldd	r25, Y+4	; 0x04
    194a:	2d 81       	ldd	r18, Y+5	; 0x05
    194c:	3e 81       	ldd	r19, Y+6	; 0x06
    194e:	b9 01       	movw	r22, r18
    1950:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1954:	eb 81       	ldd	r30, Y+3	; 0x03
    1956:	fc 81       	ldd	r31, Y+4	; 0x04
    1958:	82 8d       	ldd	r24, Z+26	; 0x1a
    195a:	81 50       	subi	r24, 0x01	; 1
    195c:	eb 81       	ldd	r30, Y+3	; 0x03
    195e:	fc 81       	ldd	r31, Y+4	; 0x04
    1960:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1962:	eb 81       	ldd	r30, Y+3	; 0x03
    1964:	fc 81       	ldd	r31, Y+4	; 0x04
    1966:	85 8d       	ldd	r24, Z+29	; 0x1d
    1968:	8f 3f       	cpi	r24, 0xFF	; 255
    196a:	89 f4       	brne	.+34     	; 0x198e <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    196c:	eb 81       	ldd	r30, Y+3	; 0x03
    196e:	fc 81       	ldd	r31, Y+4	; 0x04
    1970:	80 85       	ldd	r24, Z+8	; 0x08
    1972:	88 23       	and	r24, r24
    1974:	99 f0       	breq	.+38     	; 0x199c <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1976:	8b 81       	ldd	r24, Y+3	; 0x03
    1978:	9c 81       	ldd	r25, Y+4	; 0x04
    197a:	08 96       	adiw	r24, 0x08	; 8
    197c:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskRemoveFromEventList>
    1980:	88 23       	and	r24, r24
    1982:	61 f0       	breq	.+24     	; 0x199c <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1984:	ef 81       	ldd	r30, Y+7	; 0x07
    1986:	f8 85       	ldd	r31, Y+8	; 0x08
    1988:	81 e0       	ldi	r24, 0x01	; 1
    198a:	80 83       	st	Z, r24
    198c:	07 c0       	rjmp	.+14     	; 0x199c <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    198e:	eb 81       	ldd	r30, Y+3	; 0x03
    1990:	fc 81       	ldd	r31, Y+4	; 0x04
    1992:	85 8d       	ldd	r24, Z+29	; 0x1d
    1994:	8f 5f       	subi	r24, 0xFF	; 255
    1996:	eb 81       	ldd	r30, Y+3	; 0x03
    1998:	fc 81       	ldd	r31, Y+4	; 0x04
    199a:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	8a 83       	std	Y+2, r24	; 0x02
    19a0:	01 c0       	rjmp	.+2      	; 0x19a4 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    19a2:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    19a4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    19a6:	28 96       	adiw	r28, 0x08	; 8
    19a8:	0f b6       	in	r0, 0x3f	; 63
    19aa:	f8 94       	cli
    19ac:	de bf       	out	0x3e, r29	; 62
    19ae:	0f be       	out	0x3f, r0	; 63
    19b0:	cd bf       	out	0x3d, r28	; 61
    19b2:	cf 91       	pop	r28
    19b4:	df 91       	pop	r29
    19b6:	08 95       	ret

000019b8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    19b8:	df 93       	push	r29
    19ba:	cf 93       	push	r28
    19bc:	00 d0       	rcall	.+0      	; 0x19be <uxQueueMessagesWaiting+0x6>
    19be:	0f 92       	push	r0
    19c0:	cd b7       	in	r28, 0x3d	; 61
    19c2:	de b7       	in	r29, 0x3e	; 62
    19c4:	9b 83       	std	Y+3, r25	; 0x03
    19c6:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19c8:	0f b6       	in	r0, 0x3f	; 63
    19ca:	f8 94       	cli
    19cc:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    19ce:	ea 81       	ldd	r30, Y+2	; 0x02
    19d0:	fb 81       	ldd	r31, Y+3	; 0x03
    19d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    19d4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    19d6:	0f 90       	pop	r0
    19d8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    19da:	89 81       	ldd	r24, Y+1	; 0x01
}
    19dc:	0f 90       	pop	r0
    19de:	0f 90       	pop	r0
    19e0:	0f 90       	pop	r0
    19e2:	cf 91       	pop	r28
    19e4:	df 91       	pop	r29
    19e6:	08 95       	ret

000019e8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    19e8:	df 93       	push	r29
    19ea:	cf 93       	push	r28
    19ec:	00 d0       	rcall	.+0      	; 0x19ee <uxQueueMessagesWaitingFromISR+0x6>
    19ee:	0f 92       	push	r0
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
    19f4:	9b 83       	std	Y+3, r25	; 0x03
    19f6:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    19f8:	ea 81       	ldd	r30, Y+2	; 0x02
    19fa:	fb 81       	ldd	r31, Y+3	; 0x03
    19fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    19fe:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1a00:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a02:	0f 90       	pop	r0
    1a04:	0f 90       	pop	r0
    1a06:	0f 90       	pop	r0
    1a08:	cf 91       	pop	r28
    1a0a:	df 91       	pop	r29
    1a0c:	08 95       	ret

00001a0e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1a0e:	df 93       	push	r29
    1a10:	cf 93       	push	r28
    1a12:	00 d0       	rcall	.+0      	; 0x1a14 <vQueueDelete+0x6>
    1a14:	cd b7       	in	r28, 0x3d	; 61
    1a16:	de b7       	in	r29, 0x3e	; 62
    1a18:	9a 83       	std	Y+2, r25	; 0x02
    1a1a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1a1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a20:	80 81       	ld	r24, Z
    1a22:	91 81       	ldd	r25, Z+1	; 0x01
    1a24:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortFree>
	vPortFree( pxQueue );
    1a28:	89 81       	ldd	r24, Y+1	; 0x01
    1a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a2c:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortFree>
}
    1a30:	0f 90       	pop	r0
    1a32:	0f 90       	pop	r0
    1a34:	cf 91       	pop	r28
    1a36:	df 91       	pop	r29
    1a38:	08 95       	ret

00001a3a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1a3a:	df 93       	push	r29
    1a3c:	cf 93       	push	r28
    1a3e:	00 d0       	rcall	.+0      	; 0x1a40 <prvCopyDataToQueue+0x6>
    1a40:	00 d0       	rcall	.+0      	; 0x1a42 <prvCopyDataToQueue+0x8>
    1a42:	0f 92       	push	r0
    1a44:	cd b7       	in	r28, 0x3d	; 61
    1a46:	de b7       	in	r29, 0x3e	; 62
    1a48:	9a 83       	std	Y+2, r25	; 0x02
    1a4a:	89 83       	std	Y+1, r24	; 0x01
    1a4c:	7c 83       	std	Y+4, r23	; 0x04
    1a4e:	6b 83       	std	Y+3, r22	; 0x03
    1a50:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1a52:	e9 81       	ldd	r30, Y+1	; 0x01
    1a54:	fa 81       	ldd	r31, Y+2	; 0x02
    1a56:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a58:	88 23       	and	r24, r24
    1a5a:	09 f4       	brne	.+2      	; 0x1a5e <prvCopyDataToQueue+0x24>
    1a5c:	74 c0       	rjmp	.+232    	; 0x1b46 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1a5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1a60:	88 23       	and	r24, r24
    1a62:	99 f5       	brne	.+102    	; 0x1aca <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1a64:	e9 81       	ldd	r30, Y+1	; 0x01
    1a66:	fa 81       	ldd	r31, Y+2	; 0x02
    1a68:	64 81       	ldd	r22, Z+4	; 0x04
    1a6a:	75 81       	ldd	r23, Z+5	; 0x05
    1a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a70:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a72:	48 2f       	mov	r20, r24
    1a74:	50 e0       	ldi	r21, 0x00	; 0
    1a76:	2b 81       	ldd	r18, Y+3	; 0x03
    1a78:	3c 81       	ldd	r19, Y+4	; 0x04
    1a7a:	cb 01       	movw	r24, r22
    1a7c:	b9 01       	movw	r22, r18
    1a7e:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1a82:	e9 81       	ldd	r30, Y+1	; 0x01
    1a84:	fa 81       	ldd	r31, Y+2	; 0x02
    1a86:	24 81       	ldd	r18, Z+4	; 0x04
    1a88:	35 81       	ldd	r19, Z+5	; 0x05
    1a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a90:	88 2f       	mov	r24, r24
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	82 0f       	add	r24, r18
    1a96:	93 1f       	adc	r25, r19
    1a98:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a9c:	95 83       	std	Z+5, r25	; 0x05
    1a9e:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1aa0:	e9 81       	ldd	r30, Y+1	; 0x01
    1aa2:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa4:	24 81       	ldd	r18, Z+4	; 0x04
    1aa6:	35 81       	ldd	r19, Z+5	; 0x05
    1aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    1aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    1aac:	82 81       	ldd	r24, Z+2	; 0x02
    1aae:	93 81       	ldd	r25, Z+3	; 0x03
    1ab0:	28 17       	cp	r18, r24
    1ab2:	39 07       	cpc	r19, r25
    1ab4:	08 f4       	brcc	.+2      	; 0x1ab8 <prvCopyDataToQueue+0x7e>
    1ab6:	47 c0       	rjmp	.+142    	; 0x1b46 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1ab8:	e9 81       	ldd	r30, Y+1	; 0x01
    1aba:	fa 81       	ldd	r31, Y+2	; 0x02
    1abc:	80 81       	ld	r24, Z
    1abe:	91 81       	ldd	r25, Z+1	; 0x01
    1ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ac4:	95 83       	std	Z+5, r25	; 0x05
    1ac6:	84 83       	std	Z+4, r24	; 0x04
    1ac8:	3e c0       	rjmp	.+124    	; 0x1b46 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1aca:	e9 81       	ldd	r30, Y+1	; 0x01
    1acc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ace:	66 81       	ldd	r22, Z+6	; 0x06
    1ad0:	77 81       	ldd	r23, Z+7	; 0x07
    1ad2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ad4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ad6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ad8:	48 2f       	mov	r20, r24
    1ada:	50 e0       	ldi	r21, 0x00	; 0
    1adc:	2b 81       	ldd	r18, Y+3	; 0x03
    1ade:	3c 81       	ldd	r19, Y+4	; 0x04
    1ae0:	cb 01       	movw	r24, r22
    1ae2:	b9 01       	movw	r22, r18
    1ae4:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1ae8:	e9 81       	ldd	r30, Y+1	; 0x01
    1aea:	fa 81       	ldd	r31, Y+2	; 0x02
    1aec:	26 81       	ldd	r18, Z+6	; 0x06
    1aee:	37 81       	ldd	r19, Z+7	; 0x07
    1af0:	e9 81       	ldd	r30, Y+1	; 0x01
    1af2:	fa 81       	ldd	r31, Y+2	; 0x02
    1af4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1af6:	88 2f       	mov	r24, r24
    1af8:	90 e0       	ldi	r25, 0x00	; 0
    1afa:	90 95       	com	r25
    1afc:	81 95       	neg	r24
    1afe:	9f 4f       	sbci	r25, 0xFF	; 255
    1b00:	82 0f       	add	r24, r18
    1b02:	93 1f       	adc	r25, r19
    1b04:	e9 81       	ldd	r30, Y+1	; 0x01
    1b06:	fa 81       	ldd	r31, Y+2	; 0x02
    1b08:	97 83       	std	Z+7, r25	; 0x07
    1b0a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1b0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b10:	26 81       	ldd	r18, Z+6	; 0x06
    1b12:	37 81       	ldd	r19, Z+7	; 0x07
    1b14:	e9 81       	ldd	r30, Y+1	; 0x01
    1b16:	fa 81       	ldd	r31, Y+2	; 0x02
    1b18:	80 81       	ld	r24, Z
    1b1a:	91 81       	ldd	r25, Z+1	; 0x01
    1b1c:	28 17       	cp	r18, r24
    1b1e:	39 07       	cpc	r19, r25
    1b20:	90 f4       	brcc	.+36     	; 0x1b46 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1b22:	e9 81       	ldd	r30, Y+1	; 0x01
    1b24:	fa 81       	ldd	r31, Y+2	; 0x02
    1b26:	22 81       	ldd	r18, Z+2	; 0x02
    1b28:	33 81       	ldd	r19, Z+3	; 0x03
    1b2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b30:	88 2f       	mov	r24, r24
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	90 95       	com	r25
    1b36:	81 95       	neg	r24
    1b38:	9f 4f       	sbci	r25, 0xFF	; 255
    1b3a:	82 0f       	add	r24, r18
    1b3c:	93 1f       	adc	r25, r19
    1b3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b40:	fa 81       	ldd	r31, Y+2	; 0x02
    1b42:	97 83       	std	Z+7, r25	; 0x07
    1b44:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1b46:	e9 81       	ldd	r30, Y+1	; 0x01
    1b48:	fa 81       	ldd	r31, Y+2	; 0x02
    1b4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b4c:	8f 5f       	subi	r24, 0xFF	; 255
    1b4e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b50:	fa 81       	ldd	r31, Y+2	; 0x02
    1b52:	82 8f       	std	Z+26, r24	; 0x1a
}
    1b54:	0f 90       	pop	r0
    1b56:	0f 90       	pop	r0
    1b58:	0f 90       	pop	r0
    1b5a:	0f 90       	pop	r0
    1b5c:	0f 90       	pop	r0
    1b5e:	cf 91       	pop	r28
    1b60:	df 91       	pop	r29
    1b62:	08 95       	ret

00001b64 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1b64:	df 93       	push	r29
    1b66:	cf 93       	push	r28
    1b68:	00 d0       	rcall	.+0      	; 0x1b6a <prvCopyDataFromQueue+0x6>
    1b6a:	00 d0       	rcall	.+0      	; 0x1b6c <prvCopyDataFromQueue+0x8>
    1b6c:	cd b7       	in	r28, 0x3d	; 61
    1b6e:	de b7       	in	r29, 0x3e	; 62
    1b70:	9a 83       	std	Y+2, r25	; 0x02
    1b72:	89 83       	std	Y+1, r24	; 0x01
    1b74:	7c 83       	std	Y+4, r23	; 0x04
    1b76:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1b78:	e9 81       	ldd	r30, Y+1	; 0x01
    1b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b7c:	80 81       	ld	r24, Z
    1b7e:	91 81       	ldd	r25, Z+1	; 0x01
    1b80:	00 97       	sbiw	r24, 0x00	; 0
    1b82:	89 f1       	breq	.+98     	; 0x1be6 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1b84:	e9 81       	ldd	r30, Y+1	; 0x01
    1b86:	fa 81       	ldd	r31, Y+2	; 0x02
    1b88:	26 81       	ldd	r18, Z+6	; 0x06
    1b8a:	37 81       	ldd	r19, Z+7	; 0x07
    1b8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b90:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b92:	88 2f       	mov	r24, r24
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	82 0f       	add	r24, r18
    1b98:	93 1f       	adc	r25, r19
    1b9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b9e:	97 83       	std	Z+7, r25	; 0x07
    1ba0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1ba2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ba4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ba6:	26 81       	ldd	r18, Z+6	; 0x06
    1ba8:	37 81       	ldd	r19, Z+7	; 0x07
    1baa:	e9 81       	ldd	r30, Y+1	; 0x01
    1bac:	fa 81       	ldd	r31, Y+2	; 0x02
    1bae:	82 81       	ldd	r24, Z+2	; 0x02
    1bb0:	93 81       	ldd	r25, Z+3	; 0x03
    1bb2:	28 17       	cp	r18, r24
    1bb4:	39 07       	cpc	r19, r25
    1bb6:	40 f0       	brcs	.+16     	; 0x1bc8 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1bb8:	e9 81       	ldd	r30, Y+1	; 0x01
    1bba:	fa 81       	ldd	r31, Y+2	; 0x02
    1bbc:	80 81       	ld	r24, Z
    1bbe:	91 81       	ldd	r25, Z+1	; 0x01
    1bc0:	e9 81       	ldd	r30, Y+1	; 0x01
    1bc2:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc4:	97 83       	std	Z+7, r25	; 0x07
    1bc6:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1bc8:	e9 81       	ldd	r30, Y+1	; 0x01
    1bca:	fa 81       	ldd	r31, Y+2	; 0x02
    1bcc:	46 81       	ldd	r20, Z+6	; 0x06
    1bce:	57 81       	ldd	r21, Z+7	; 0x07
    1bd0:	e9 81       	ldd	r30, Y+1	; 0x01
    1bd2:	fa 81       	ldd	r31, Y+2	; 0x02
    1bd4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bd6:	28 2f       	mov	r18, r24
    1bd8:	30 e0       	ldi	r19, 0x00	; 0
    1bda:	8b 81       	ldd	r24, Y+3	; 0x03
    1bdc:	9c 81       	ldd	r25, Y+4	; 0x04
    1bde:	ba 01       	movw	r22, r20
    1be0:	a9 01       	movw	r20, r18
    1be2:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <memcpy>
	}
}
    1be6:	0f 90       	pop	r0
    1be8:	0f 90       	pop	r0
    1bea:	0f 90       	pop	r0
    1bec:	0f 90       	pop	r0
    1bee:	cf 91       	pop	r28
    1bf0:	df 91       	pop	r29
    1bf2:	08 95       	ret

00001bf4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1bf4:	df 93       	push	r29
    1bf6:	cf 93       	push	r28
    1bf8:	00 d0       	rcall	.+0      	; 0x1bfa <prvUnlockQueue+0x6>
    1bfa:	cd b7       	in	r28, 0x3d	; 61
    1bfc:	de b7       	in	r29, 0x3e	; 62
    1bfe:	9a 83       	std	Y+2, r25	; 0x02
    1c00:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1c02:	0f b6       	in	r0, 0x3f	; 63
    1c04:	f8 94       	cli
    1c06:	0f 92       	push	r0
    1c08:	15 c0       	rjmp	.+42     	; 0x1c34 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c0e:	81 89       	ldd	r24, Z+17	; 0x11
    1c10:	88 23       	and	r24, r24
    1c12:	a9 f0       	breq	.+42     	; 0x1c3e <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c14:	89 81       	ldd	r24, Y+1	; 0x01
    1c16:	9a 81       	ldd	r25, Y+2	; 0x02
    1c18:	41 96       	adiw	r24, 0x11	; 17
    1c1a:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskRemoveFromEventList>
    1c1e:	88 23       	and	r24, r24
    1c20:	11 f0       	breq	.+4      	; 0x1c26 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1c22:	0e 94 10 14 	call	0x2820	; 0x2820 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1c26:	e9 81       	ldd	r30, Y+1	; 0x01
    1c28:	fa 81       	ldd	r31, Y+2	; 0x02
    1c2a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c2c:	81 50       	subi	r24, 0x01	; 1
    1c2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c30:	fa 81       	ldd	r31, Y+2	; 0x02
    1c32:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1c34:	e9 81       	ldd	r30, Y+1	; 0x01
    1c36:	fa 81       	ldd	r31, Y+2	; 0x02
    1c38:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c3a:	18 16       	cp	r1, r24
    1c3c:	34 f3       	brlt	.-52     	; 0x1c0a <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c40:	fa 81       	ldd	r31, Y+2	; 0x02
    1c42:	8f ef       	ldi	r24, 0xFF	; 255
    1c44:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1c46:	0f 90       	pop	r0
    1c48:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1c4a:	0f b6       	in	r0, 0x3f	; 63
    1c4c:	f8 94       	cli
    1c4e:	0f 92       	push	r0
    1c50:	15 c0       	rjmp	.+42     	; 0x1c7c <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c52:	e9 81       	ldd	r30, Y+1	; 0x01
    1c54:	fa 81       	ldd	r31, Y+2	; 0x02
    1c56:	80 85       	ldd	r24, Z+8	; 0x08
    1c58:	88 23       	and	r24, r24
    1c5a:	a9 f0       	breq	.+42     	; 0x1c86 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c5c:	89 81       	ldd	r24, Y+1	; 0x01
    1c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c60:	08 96       	adiw	r24, 0x08	; 8
    1c62:	0e 94 32 13 	call	0x2664	; 0x2664 <xTaskRemoveFromEventList>
    1c66:	88 23       	and	r24, r24
    1c68:	11 f0       	breq	.+4      	; 0x1c6e <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1c6a:	0e 94 10 14 	call	0x2820	; 0x2820 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1c6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c70:	fa 81       	ldd	r31, Y+2	; 0x02
    1c72:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c74:	81 50       	subi	r24, 0x01	; 1
    1c76:	e9 81       	ldd	r30, Y+1	; 0x01
    1c78:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7a:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c80:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c82:	18 16       	cp	r1, r24
    1c84:	34 f3       	brlt	.-52     	; 0x1c52 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1c86:	e9 81       	ldd	r30, Y+1	; 0x01
    1c88:	fa 81       	ldd	r31, Y+2	; 0x02
    1c8a:	8f ef       	ldi	r24, 0xFF	; 255
    1c8c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1c8e:	0f 90       	pop	r0
    1c90:	0f be       	out	0x3f, r0	; 63
}
    1c92:	0f 90       	pop	r0
    1c94:	0f 90       	pop	r0
    1c96:	cf 91       	pop	r28
    1c98:	df 91       	pop	r29
    1c9a:	08 95       	ret

00001c9c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1c9c:	df 93       	push	r29
    1c9e:	cf 93       	push	r28
    1ca0:	00 d0       	rcall	.+0      	; 0x1ca2 <prvIsQueueEmpty+0x6>
    1ca2:	0f 92       	push	r0
    1ca4:	cd b7       	in	r28, 0x3d	; 61
    1ca6:	de b7       	in	r29, 0x3e	; 62
    1ca8:	9b 83       	std	Y+3, r25	; 0x03
    1caa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1cac:	0f b6       	in	r0, 0x3f	; 63
    1cae:	f8 94       	cli
    1cb0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1cb2:	ea 81       	ldd	r30, Y+2	; 0x02
    1cb4:	fb 81       	ldd	r31, Y+3	; 0x03
    1cb6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cb8:	19 82       	std	Y+1, r1	; 0x01
    1cba:	88 23       	and	r24, r24
    1cbc:	11 f4       	brne	.+4      	; 0x1cc2 <prvIsQueueEmpty+0x26>
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1cc2:	0f 90       	pop	r0
    1cc4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1cc6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1cc8:	0f 90       	pop	r0
    1cca:	0f 90       	pop	r0
    1ccc:	0f 90       	pop	r0
    1cce:	cf 91       	pop	r28
    1cd0:	df 91       	pop	r29
    1cd2:	08 95       	ret

00001cd4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1cd4:	df 93       	push	r29
    1cd6:	cf 93       	push	r28
    1cd8:	00 d0       	rcall	.+0      	; 0x1cda <xQueueIsQueueEmptyFromISR+0x6>
    1cda:	0f 92       	push	r0
    1cdc:	cd b7       	in	r28, 0x3d	; 61
    1cde:	de b7       	in	r29, 0x3e	; 62
    1ce0:	9b 83       	std	Y+3, r25	; 0x03
    1ce2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1ce4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ce6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ce8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cea:	19 82       	std	Y+1, r1	; 0x01
    1cec:	88 23       	and	r24, r24
    1cee:	11 f4       	brne	.+4      	; 0x1cf4 <xQueueIsQueueEmptyFromISR+0x20>
    1cf0:	81 e0       	ldi	r24, 0x01	; 1
    1cf2:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1cf4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1cf6:	0f 90       	pop	r0
    1cf8:	0f 90       	pop	r0
    1cfa:	0f 90       	pop	r0
    1cfc:	cf 91       	pop	r28
    1cfe:	df 91       	pop	r29
    1d00:	08 95       	ret

00001d02 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1d02:	df 93       	push	r29
    1d04:	cf 93       	push	r28
    1d06:	00 d0       	rcall	.+0      	; 0x1d08 <prvIsQueueFull+0x6>
    1d08:	0f 92       	push	r0
    1d0a:	cd b7       	in	r28, 0x3d	; 61
    1d0c:	de b7       	in	r29, 0x3e	; 62
    1d0e:	9b 83       	std	Y+3, r25	; 0x03
    1d10:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1d12:	0f b6       	in	r0, 0x3f	; 63
    1d14:	f8 94       	cli
    1d16:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1d18:	ea 81       	ldd	r30, Y+2	; 0x02
    1d1a:	fb 81       	ldd	r31, Y+3	; 0x03
    1d1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d1e:	ea 81       	ldd	r30, Y+2	; 0x02
    1d20:	fb 81       	ldd	r31, Y+3	; 0x03
    1d22:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d24:	19 82       	std	Y+1, r1	; 0x01
    1d26:	98 17       	cp	r25, r24
    1d28:	11 f4       	brne	.+4      	; 0x1d2e <prvIsQueueFull+0x2c>
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1d2e:	0f 90       	pop	r0
    1d30:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1d32:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d34:	0f 90       	pop	r0
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	cf 91       	pop	r28
    1d3c:	df 91       	pop	r29
    1d3e:	08 95       	ret

00001d40 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1d40:	df 93       	push	r29
    1d42:	cf 93       	push	r28
    1d44:	00 d0       	rcall	.+0      	; 0x1d46 <xQueueIsQueueFullFromISR+0x6>
    1d46:	0f 92       	push	r0
    1d48:	cd b7       	in	r28, 0x3d	; 61
    1d4a:	de b7       	in	r29, 0x3e	; 62
    1d4c:	9b 83       	std	Y+3, r25	; 0x03
    1d4e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1d50:	ea 81       	ldd	r30, Y+2	; 0x02
    1d52:	fb 81       	ldd	r31, Y+3	; 0x03
    1d54:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d56:	ea 81       	ldd	r30, Y+2	; 0x02
    1d58:	fb 81       	ldd	r31, Y+3	; 0x03
    1d5a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d5c:	19 82       	std	Y+1, r1	; 0x01
    1d5e:	98 17       	cp	r25, r24
    1d60:	11 f4       	brne	.+4      	; 0x1d66 <xQueueIsQueueFullFromISR+0x26>
    1d62:	81 e0       	ldi	r24, 0x01	; 1
    1d64:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1d66:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d68:	0f 90       	pop	r0
    1d6a:	0f 90       	pop	r0
    1d6c:	0f 90       	pop	r0
    1d6e:	cf 91       	pop	r28
    1d70:	df 91       	pop	r29
    1d72:	08 95       	ret

00001d74 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1d74:	af 92       	push	r10
    1d76:	bf 92       	push	r11
    1d78:	cf 92       	push	r12
    1d7a:	df 92       	push	r13
    1d7c:	ef 92       	push	r14
    1d7e:	ff 92       	push	r15
    1d80:	0f 93       	push	r16
    1d82:	1f 93       	push	r17
    1d84:	df 93       	push	r29
    1d86:	cf 93       	push	r28
    1d88:	cd b7       	in	r28, 0x3d	; 61
    1d8a:	de b7       	in	r29, 0x3e	; 62
    1d8c:	64 97       	sbiw	r28, 0x14	; 20
    1d8e:	0f b6       	in	r0, 0x3f	; 63
    1d90:	f8 94       	cli
    1d92:	de bf       	out	0x3e, r29	; 62
    1d94:	0f be       	out	0x3f, r0	; 63
    1d96:	cd bf       	out	0x3d, r28	; 61
    1d98:	9f 83       	std	Y+7, r25	; 0x07
    1d9a:	8e 83       	std	Y+6, r24	; 0x06
    1d9c:	79 87       	std	Y+9, r23	; 0x09
    1d9e:	68 87       	std	Y+8, r22	; 0x08
    1da0:	5b 87       	std	Y+11, r21	; 0x0b
    1da2:	4a 87       	std	Y+10, r20	; 0x0a
    1da4:	3d 87       	std	Y+13, r19	; 0x0d
    1da6:	2c 87       	std	Y+12, r18	; 0x0c
    1da8:	0e 87       	std	Y+14, r16	; 0x0e
    1daa:	f8 8a       	std	Y+16, r15	; 0x10
    1dac:	ef 86       	std	Y+15, r14	; 0x0f
    1dae:	da 8a       	std	Y+18, r13	; 0x12
    1db0:	c9 8a       	std	Y+17, r12	; 0x11
    1db2:	bc 8a       	std	Y+20, r11	; 0x14
    1db4:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1db6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1db8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1dba:	29 89       	ldd	r18, Y+17	; 0x11
    1dbc:	3a 89       	ldd	r19, Y+18	; 0x12
    1dbe:	b9 01       	movw	r22, r18
    1dc0:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <prvAllocateTCBAndStack>
    1dc4:	9c 83       	std	Y+4, r25	; 0x04
    1dc6:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	9c 81       	ldd	r25, Y+4	; 0x04
    1dcc:	00 97       	sbiw	r24, 0x00	; 0
    1dce:	09 f4       	brne	.+2      	; 0x1dd2 <xTaskGenericCreate+0x5e>
    1dd0:	99 c0       	rjmp	.+306    	; 0x1f04 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1dd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd6:	27 89       	ldd	r18, Z+23	; 0x17
    1dd8:	30 8d       	ldd	r19, Z+24	; 0x18
    1dda:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ddc:	9b 85       	ldd	r25, Y+11	; 0x0b
    1dde:	01 97       	sbiw	r24, 0x01	; 1
    1de0:	82 0f       	add	r24, r18
    1de2:	93 1f       	adc	r25, r19
    1de4:	9a 83       	std	Y+2, r25	; 0x02
    1de6:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1de8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dea:	9c 81       	ldd	r25, Y+4	; 0x04
    1dec:	28 85       	ldd	r18, Y+8	; 0x08
    1dee:	39 85       	ldd	r19, Y+9	; 0x09
    1df0:	eb 89       	ldd	r30, Y+19	; 0x13
    1df2:	fc 89       	ldd	r31, Y+20	; 0x14
    1df4:	aa 85       	ldd	r26, Y+10	; 0x0a
    1df6:	bb 85       	ldd	r27, Y+11	; 0x0b
    1df8:	b9 01       	movw	r22, r18
    1dfa:	4e 85       	ldd	r20, Y+14	; 0x0e
    1dfc:	9f 01       	movw	r18, r30
    1dfe:	8d 01       	movw	r16, r26
    1e00:	0e 94 24 14 	call	0x2848	; 0x2848 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1e04:	89 81       	ldd	r24, Y+1	; 0x01
    1e06:	9a 81       	ldd	r25, Y+2	; 0x02
    1e08:	2e 81       	ldd	r18, Y+6	; 0x06
    1e0a:	3f 81       	ldd	r19, Y+7	; 0x07
    1e0c:	4c 85       	ldd	r20, Y+12	; 0x0c
    1e0e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1e10:	b9 01       	movw	r22, r18
    1e12:	0e 94 67 07 	call	0xece	; 0xece <pxPortInitialiseStack>
    1e16:	eb 81       	ldd	r30, Y+3	; 0x03
    1e18:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1a:	91 83       	std	Z+1, r25	; 0x01
    1e1c:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1e1e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e20:	98 89       	ldd	r25, Y+16	; 0x10
    1e22:	00 97       	sbiw	r24, 0x00	; 0
    1e24:	31 f0       	breq	.+12     	; 0x1e32 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1e26:	ef 85       	ldd	r30, Y+15	; 0x0f
    1e28:	f8 89       	ldd	r31, Y+16	; 0x10
    1e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2e:	91 83       	std	Z+1, r25	; 0x01
    1e30:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1e32:	0f b6       	in	r0, 0x3f	; 63
    1e34:	f8 94       	cli
    1e36:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1e38:	80 91 90 04 	lds	r24, 0x0490
    1e3c:	8f 5f       	subi	r24, 0xFF	; 255
    1e3e:	80 93 90 04 	sts	0x0490, r24
			if( pxCurrentTCB == NULL )
    1e42:	80 91 8d 04 	lds	r24, 0x048D
    1e46:	90 91 8e 04 	lds	r25, 0x048E
    1e4a:	00 97       	sbiw	r24, 0x00	; 0
    1e4c:	69 f4       	brne	.+26     	; 0x1e68 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e50:	9c 81       	ldd	r25, Y+4	; 0x04
    1e52:	90 93 8e 04 	sts	0x048E, r25
    1e56:	80 93 8d 04 	sts	0x048D, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1e5a:	80 91 90 04 	lds	r24, 0x0490
    1e5e:	81 30       	cpi	r24, 0x01	; 1
    1e60:	a9 f4       	brne	.+42     	; 0x1e8c <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1e62:	0e 94 7b 14 	call	0x28f6	; 0x28f6 <prvInitialiseTaskLists>
    1e66:	12 c0       	rjmp	.+36     	; 0x1e8c <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1e68:	80 91 95 04 	lds	r24, 0x0495
    1e6c:	88 23       	and	r24, r24
    1e6e:	71 f4       	brne	.+28     	; 0x1e8c <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1e70:	e0 91 8d 04 	lds	r30, 0x048D
    1e74:	f0 91 8e 04 	lds	r31, 0x048E
    1e78:	96 89       	ldd	r25, Z+22	; 0x16
    1e7a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e7c:	89 17       	cp	r24, r25
    1e7e:	30 f0       	brcs	.+12     	; 0x1e8c <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1e80:	8b 81       	ldd	r24, Y+3	; 0x03
    1e82:	9c 81       	ldd	r25, Y+4	; 0x04
    1e84:	90 93 8e 04 	sts	0x048E, r25
    1e88:	80 93 8d 04 	sts	0x048D, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1e8c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e8e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e90:	96 89       	ldd	r25, Z+22	; 0x16
    1e92:	80 91 93 04 	lds	r24, 0x0493
    1e96:	89 17       	cp	r24, r25
    1e98:	28 f4       	brcc	.+10     	; 0x1ea4 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1e9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9e:	86 89       	ldd	r24, Z+22	; 0x16
    1ea0:	80 93 93 04 	sts	0x0493, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1ea4:	80 91 9a 04 	lds	r24, 0x049A
    1ea8:	8f 5f       	subi	r24, 0xFF	; 255
    1eaa:	80 93 9a 04 	sts	0x049A, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1eae:	eb 81       	ldd	r30, Y+3	; 0x03
    1eb0:	fc 81       	ldd	r31, Y+4	; 0x04
    1eb2:	96 89       	ldd	r25, Z+22	; 0x16
    1eb4:	80 91 94 04 	lds	r24, 0x0494
    1eb8:	89 17       	cp	r24, r25
    1eba:	28 f4       	brcc	.+10     	; 0x1ec6 <xTaskGenericCreate+0x152>
    1ebc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ebe:	fc 81       	ldd	r31, Y+4	; 0x04
    1ec0:	86 89       	ldd	r24, Z+22	; 0x16
    1ec2:	80 93 94 04 	sts	0x0494, r24
    1ec6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ec8:	fc 81       	ldd	r31, Y+4	; 0x04
    1eca:	86 89       	ldd	r24, Z+22	; 0x16
    1ecc:	28 2f       	mov	r18, r24
    1ece:	30 e0       	ldi	r19, 0x00	; 0
    1ed0:	c9 01       	movw	r24, r18
    1ed2:	88 0f       	add	r24, r24
    1ed4:	99 1f       	adc	r25, r25
    1ed6:	88 0f       	add	r24, r24
    1ed8:	99 1f       	adc	r25, r25
    1eda:	88 0f       	add	r24, r24
    1edc:	99 1f       	adc	r25, r25
    1ede:	82 0f       	add	r24, r18
    1ee0:	93 1f       	adc	r25, r19
    1ee2:	ac 01       	movw	r20, r24
    1ee4:	45 56       	subi	r20, 0x65	; 101
    1ee6:	5b 4f       	sbci	r21, 0xFB	; 251
    1ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eea:	9c 81       	ldd	r25, Y+4	; 0x04
    1eec:	9c 01       	movw	r18, r24
    1eee:	2e 5f       	subi	r18, 0xFE	; 254
    1ef0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef2:	ca 01       	movw	r24, r20
    1ef4:	b9 01       	movw	r22, r18
    1ef6:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>

			xReturn = pdPASS;
    1efa:	81 e0       	ldi	r24, 0x01	; 1
    1efc:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1efe:	0f 90       	pop	r0
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	02 c0       	rjmp	.+4      	; 0x1f08 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f04:	8f ef       	ldi	r24, 0xFF	; 255
    1f06:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1f08:	8d 81       	ldd	r24, Y+5	; 0x05
    1f0a:	81 30       	cpi	r24, 0x01	; 1
    1f0c:	71 f4       	brne	.+28     	; 0x1f2a <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1f0e:	80 91 95 04 	lds	r24, 0x0495
    1f12:	88 23       	and	r24, r24
    1f14:	51 f0       	breq	.+20     	; 0x1f2a <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1f16:	e0 91 8d 04 	lds	r30, 0x048D
    1f1a:	f0 91 8e 04 	lds	r31, 0x048E
    1f1e:	96 89       	ldd	r25, Z+22	; 0x16
    1f20:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f22:	98 17       	cp	r25, r24
    1f24:	10 f4       	brcc	.+4      	; 0x1f2a <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1f26:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
			}
		}
	}

	return xReturn;
    1f2a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1f2c:	64 96       	adiw	r28, 0x14	; 20
    1f2e:	0f b6       	in	r0, 0x3f	; 63
    1f30:	f8 94       	cli
    1f32:	de bf       	out	0x3e, r29	; 62
    1f34:	0f be       	out	0x3f, r0	; 63
    1f36:	cd bf       	out	0x3d, r28	; 61
    1f38:	cf 91       	pop	r28
    1f3a:	df 91       	pop	r29
    1f3c:	1f 91       	pop	r17
    1f3e:	0f 91       	pop	r16
    1f40:	ff 90       	pop	r15
    1f42:	ef 90       	pop	r14
    1f44:	df 90       	pop	r13
    1f46:	cf 90       	pop	r12
    1f48:	bf 90       	pop	r11
    1f4a:	af 90       	pop	r10
    1f4c:	08 95       	ret

00001f4e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1f4e:	df 93       	push	r29
    1f50:	cf 93       	push	r28
    1f52:	00 d0       	rcall	.+0      	; 0x1f54 <vTaskDelete+0x6>
    1f54:	00 d0       	rcall	.+0      	; 0x1f56 <vTaskDelete+0x8>
    1f56:	00 d0       	rcall	.+0      	; 0x1f58 <vTaskDelete+0xa>
    1f58:	cd b7       	in	r28, 0x3d	; 61
    1f5a:	de b7       	in	r29, 0x3e	; 62
    1f5c:	9c 83       	std	Y+4, r25	; 0x04
    1f5e:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1f60:	0f b6       	in	r0, 0x3f	; 63
    1f62:	f8 94       	cli
    1f64:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1f66:	20 91 8d 04 	lds	r18, 0x048D
    1f6a:	30 91 8e 04 	lds	r19, 0x048E
    1f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f70:	9c 81       	ldd	r25, Y+4	; 0x04
    1f72:	82 17       	cp	r24, r18
    1f74:	93 07       	cpc	r25, r19
    1f76:	11 f4       	brne	.+4      	; 0x1f7c <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1f78:	1c 82       	std	Y+4, r1	; 0x04
    1f7a:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f80:	00 97       	sbiw	r24, 0x00	; 0
    1f82:	39 f4       	brne	.+14     	; 0x1f92 <vTaskDelete+0x44>
    1f84:	80 91 8d 04 	lds	r24, 0x048D
    1f88:	90 91 8e 04 	lds	r25, 0x048E
    1f8c:	9e 83       	std	Y+6, r25	; 0x06
    1f8e:	8d 83       	std	Y+5, r24	; 0x05
    1f90:	04 c0       	rjmp	.+8      	; 0x1f9a <vTaskDelete+0x4c>
    1f92:	8b 81       	ldd	r24, Y+3	; 0x03
    1f94:	9c 81       	ldd	r25, Y+4	; 0x04
    1f96:	9e 83       	std	Y+6, r25	; 0x06
    1f98:	8d 83       	std	Y+5, r24	; 0x05
    1f9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f9e:	9a 83       	std	Y+2, r25	; 0x02
    1fa0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1fa2:	89 81       	ldd	r24, Y+1	; 0x01
    1fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa6:	02 96       	adiw	r24, 0x02	; 2
    1fa8:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1fac:	e9 81       	ldd	r30, Y+1	; 0x01
    1fae:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb0:	84 89       	ldd	r24, Z+20	; 0x14
    1fb2:	95 89       	ldd	r25, Z+21	; 0x15
    1fb4:	00 97       	sbiw	r24, 0x00	; 0
    1fb6:	29 f0       	breq	.+10     	; 0x1fc2 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1fb8:	89 81       	ldd	r24, Y+1	; 0x01
    1fba:	9a 81       	ldd	r25, Y+2	; 0x02
    1fbc:	0c 96       	adiw	r24, 0x0c	; 12
    1fbe:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1fc2:	89 81       	ldd	r24, Y+1	; 0x01
    1fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fc6:	9c 01       	movw	r18, r24
    1fc8:	2e 5f       	subi	r18, 0xFE	; 254
    1fca:	3f 4f       	sbci	r19, 0xFF	; 255
    1fcc:	8e ed       	ldi	r24, 0xDE	; 222
    1fce:	94 e0       	ldi	r25, 0x04	; 4
    1fd0:	b9 01       	movw	r22, r18
    1fd2:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1fd6:	80 91 8f 04 	lds	r24, 0x048F
    1fda:	8f 5f       	subi	r24, 0xFF	; 255
    1fdc:	80 93 8f 04 	sts	0x048F, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1fe0:	80 91 9a 04 	lds	r24, 0x049A
    1fe4:	8f 5f       	subi	r24, 0xFF	; 255
    1fe6:	80 93 9a 04 	sts	0x049A, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1fea:	0f 90       	pop	r0
    1fec:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1fee:	80 91 95 04 	lds	r24, 0x0495
    1ff2:	88 23       	and	r24, r24
    1ff4:	31 f0       	breq	.+12     	; 0x2002 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffa:	00 97       	sbiw	r24, 0x00	; 0
    1ffc:	11 f4       	brne	.+4      	; 0x2002 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1ffe:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
			}
		}
	}
    2002:	26 96       	adiw	r28, 0x06	; 6
    2004:	0f b6       	in	r0, 0x3f	; 63
    2006:	f8 94       	cli
    2008:	de bf       	out	0x3e, r29	; 62
    200a:	0f be       	out	0x3f, r0	; 63
    200c:	cd bf       	out	0x3d, r28	; 61
    200e:	cf 91       	pop	r28
    2010:	df 91       	pop	r29
    2012:	08 95       	ret

00002014 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2014:	df 93       	push	r29
    2016:	cf 93       	push	r28
    2018:	cd b7       	in	r28, 0x3d	; 61
    201a:	de b7       	in	r29, 0x3e	; 62
    201c:	28 97       	sbiw	r28, 0x08	; 8
    201e:	0f b6       	in	r0, 0x3f	; 63
    2020:	f8 94       	cli
    2022:	de bf       	out	0x3e, r29	; 62
    2024:	0f be       	out	0x3f, r0	; 63
    2026:	cd bf       	out	0x3d, r28	; 61
    2028:	9e 83       	std	Y+6, r25	; 0x06
    202a:	8d 83       	std	Y+5, r24	; 0x05
    202c:	78 87       	std	Y+8, r23	; 0x08
    202e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2030:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2032:	0e 94 f6 10 	call	0x21ec	; 0x21ec <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2036:	ed 81       	ldd	r30, Y+5	; 0x05
    2038:	fe 81       	ldd	r31, Y+6	; 0x06
    203a:	20 81       	ld	r18, Z
    203c:	31 81       	ldd	r19, Z+1	; 0x01
    203e:	8f 81       	ldd	r24, Y+7	; 0x07
    2040:	98 85       	ldd	r25, Y+8	; 0x08
    2042:	82 0f       	add	r24, r18
    2044:	93 1f       	adc	r25, r19
    2046:	9c 83       	std	Y+4, r25	; 0x04
    2048:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    204a:	ed 81       	ldd	r30, Y+5	; 0x05
    204c:	fe 81       	ldd	r31, Y+6	; 0x06
    204e:	20 81       	ld	r18, Z
    2050:	31 81       	ldd	r19, Z+1	; 0x01
    2052:	80 91 91 04 	lds	r24, 0x0491
    2056:	90 91 92 04 	lds	r25, 0x0492
    205a:	82 17       	cp	r24, r18
    205c:	93 07       	cpc	r25, r19
    205e:	a8 f4       	brcc	.+42     	; 0x208a <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2060:	ed 81       	ldd	r30, Y+5	; 0x05
    2062:	fe 81       	ldd	r31, Y+6	; 0x06
    2064:	20 81       	ld	r18, Z
    2066:	31 81       	ldd	r19, Z+1	; 0x01
    2068:	8b 81       	ldd	r24, Y+3	; 0x03
    206a:	9c 81       	ldd	r25, Y+4	; 0x04
    206c:	82 17       	cp	r24, r18
    206e:	93 07       	cpc	r25, r19
    2070:	00 f5       	brcc	.+64     	; 0x20b2 <vTaskDelayUntil+0x9e>
    2072:	20 91 91 04 	lds	r18, 0x0491
    2076:	30 91 92 04 	lds	r19, 0x0492
    207a:	8b 81       	ldd	r24, Y+3	; 0x03
    207c:	9c 81       	ldd	r25, Y+4	; 0x04
    207e:	28 17       	cp	r18, r24
    2080:	39 07       	cpc	r19, r25
    2082:	b8 f4       	brcc	.+46     	; 0x20b2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2084:	81 e0       	ldi	r24, 0x01	; 1
    2086:	89 83       	std	Y+1, r24	; 0x01
    2088:	14 c0       	rjmp	.+40     	; 0x20b2 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    208a:	ed 81       	ldd	r30, Y+5	; 0x05
    208c:	fe 81       	ldd	r31, Y+6	; 0x06
    208e:	20 81       	ld	r18, Z
    2090:	31 81       	ldd	r19, Z+1	; 0x01
    2092:	8b 81       	ldd	r24, Y+3	; 0x03
    2094:	9c 81       	ldd	r25, Y+4	; 0x04
    2096:	82 17       	cp	r24, r18
    2098:	93 07       	cpc	r25, r19
    209a:	48 f0       	brcs	.+18     	; 0x20ae <vTaskDelayUntil+0x9a>
    209c:	20 91 91 04 	lds	r18, 0x0491
    20a0:	30 91 92 04 	lds	r19, 0x0492
    20a4:	8b 81       	ldd	r24, Y+3	; 0x03
    20a6:	9c 81       	ldd	r25, Y+4	; 0x04
    20a8:	28 17       	cp	r18, r24
    20aa:	39 07       	cpc	r19, r25
    20ac:	10 f4       	brcc	.+4      	; 0x20b2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    20ae:	81 e0       	ldi	r24, 0x01	; 1
    20b0:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    20b2:	ed 81       	ldd	r30, Y+5	; 0x05
    20b4:	fe 81       	ldd	r31, Y+6	; 0x06
    20b6:	8b 81       	ldd	r24, Y+3	; 0x03
    20b8:	9c 81       	ldd	r25, Y+4	; 0x04
    20ba:	91 83       	std	Z+1, r25	; 0x01
    20bc:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    20be:	89 81       	ldd	r24, Y+1	; 0x01
    20c0:	88 23       	and	r24, r24
    20c2:	59 f0       	breq	.+22     	; 0x20da <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    20c4:	80 91 8d 04 	lds	r24, 0x048D
    20c8:	90 91 8e 04 	lds	r25, 0x048E
    20cc:	02 96       	adiw	r24, 0x02	; 2
    20ce:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    20d2:	8b 81       	ldd	r24, Y+3	; 0x03
    20d4:	9c 81       	ldd	r25, Y+4	; 0x04
    20d6:	0e 94 f6 14 	call	0x29ec	; 0x29ec <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    20da:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>
    20de:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    20e0:	8a 81       	ldd	r24, Y+2	; 0x02
    20e2:	88 23       	and	r24, r24
    20e4:	11 f4       	brne	.+4      	; 0x20ea <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    20e6:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
		}
	}
    20ea:	28 96       	adiw	r28, 0x08	; 8
    20ec:	0f b6       	in	r0, 0x3f	; 63
    20ee:	f8 94       	cli
    20f0:	de bf       	out	0x3e, r29	; 62
    20f2:	0f be       	out	0x3f, r0	; 63
    20f4:	cd bf       	out	0x3d, r28	; 61
    20f6:	cf 91       	pop	r28
    20f8:	df 91       	pop	r29
    20fa:	08 95       	ret

000020fc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    20fc:	df 93       	push	r29
    20fe:	cf 93       	push	r28
    2100:	00 d0       	rcall	.+0      	; 0x2102 <vTaskDelay+0x6>
    2102:	00 d0       	rcall	.+0      	; 0x2104 <vTaskDelay+0x8>
    2104:	0f 92       	push	r0
    2106:	cd b7       	in	r28, 0x3d	; 61
    2108:	de b7       	in	r29, 0x3e	; 62
    210a:	9d 83       	std	Y+5, r25	; 0x05
    210c:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    210e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2110:	8c 81       	ldd	r24, Y+4	; 0x04
    2112:	9d 81       	ldd	r25, Y+5	; 0x05
    2114:	00 97       	sbiw	r24, 0x00	; 0
    2116:	d1 f0       	breq	.+52     	; 0x214c <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    2118:	0e 94 f6 10 	call	0x21ec	; 0x21ec <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    211c:	20 91 91 04 	lds	r18, 0x0491
    2120:	30 91 92 04 	lds	r19, 0x0492
    2124:	8c 81       	ldd	r24, Y+4	; 0x04
    2126:	9d 81       	ldd	r25, Y+5	; 0x05
    2128:	82 0f       	add	r24, r18
    212a:	93 1f       	adc	r25, r19
    212c:	9b 83       	std	Y+3, r25	; 0x03
    212e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2130:	80 91 8d 04 	lds	r24, 0x048D
    2134:	90 91 8e 04 	lds	r25, 0x048E
    2138:	02 96       	adiw	r24, 0x02	; 2
    213a:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    213e:	8a 81       	ldd	r24, Y+2	; 0x02
    2140:	9b 81       	ldd	r25, Y+3	; 0x03
    2142:	0e 94 f6 14 	call	0x29ec	; 0x29ec <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2146:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>
    214a:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    214c:	89 81       	ldd	r24, Y+1	; 0x01
    214e:	88 23       	and	r24, r24
    2150:	11 f4       	brne	.+4      	; 0x2156 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2152:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
		}
	}
    2156:	0f 90       	pop	r0
    2158:	0f 90       	pop	r0
    215a:	0f 90       	pop	r0
    215c:	0f 90       	pop	r0
    215e:	0f 90       	pop	r0
    2160:	cf 91       	pop	r28
    2162:	df 91       	pop	r29
    2164:	08 95       	ret

00002166 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2166:	af 92       	push	r10
    2168:	bf 92       	push	r11
    216a:	cf 92       	push	r12
    216c:	df 92       	push	r13
    216e:	ef 92       	push	r14
    2170:	ff 92       	push	r15
    2172:	0f 93       	push	r16
    2174:	df 93       	push	r29
    2176:	cf 93       	push	r28
    2178:	0f 92       	push	r0
    217a:	cd b7       	in	r28, 0x3d	; 61
    217c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    217e:	20 e6       	ldi	r18, 0x60	; 96
    2180:	30 e0       	ldi	r19, 0x00	; 0
    2182:	8a e1       	ldi	r24, 0x1A	; 26
    2184:	94 e1       	ldi	r25, 0x14	; 20
    2186:	b9 01       	movw	r22, r18
    2188:	4a ef       	ldi	r20, 0xFA	; 250
    218a:	50 e0       	ldi	r21, 0x00	; 0
    218c:	20 e0       	ldi	r18, 0x00	; 0
    218e:	30 e0       	ldi	r19, 0x00	; 0
    2190:	00 e0       	ldi	r16, 0x00	; 0
    2192:	ee 24       	eor	r14, r14
    2194:	ff 24       	eor	r15, r15
    2196:	cc 24       	eor	r12, r12
    2198:	dd 24       	eor	r13, r13
    219a:	aa 24       	eor	r10, r10
    219c:	bb 24       	eor	r11, r11
    219e:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskGenericCreate>
    21a2:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    21a4:	89 81       	ldd	r24, Y+1	; 0x01
    21a6:	81 30       	cpi	r24, 0x01	; 1
    21a8:	51 f4       	brne	.+20     	; 0x21be <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    21aa:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    21ac:	81 e0       	ldi	r24, 0x01	; 1
    21ae:	80 93 95 04 	sts	0x0495, r24
		xTickCount = ( portTickType ) 0U;
    21b2:	10 92 92 04 	sts	0x0492, r1
    21b6:	10 92 91 04 	sts	0x0491, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    21ba:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    21be:	0f 90       	pop	r0
    21c0:	cf 91       	pop	r28
    21c2:	df 91       	pop	r29
    21c4:	0f 91       	pop	r16
    21c6:	ff 90       	pop	r15
    21c8:	ef 90       	pop	r14
    21ca:	df 90       	pop	r13
    21cc:	cf 90       	pop	r12
    21ce:	bf 90       	pop	r11
    21d0:	af 90       	pop	r10
    21d2:	08 95       	ret

000021d4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    21d4:	df 93       	push	r29
    21d6:	cf 93       	push	r28
    21d8:	cd b7       	in	r28, 0x3d	; 61
    21da:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    21dc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    21de:	10 92 95 04 	sts	0x0495, r1
	vPortEndScheduler();
    21e2:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortEndScheduler>
}
    21e6:	cf 91       	pop	r28
    21e8:	df 91       	pop	r29
    21ea:	08 95       	ret

000021ec <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    21ec:	df 93       	push	r29
    21ee:	cf 93       	push	r28
    21f0:	cd b7       	in	r28, 0x3d	; 61
    21f2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    21f4:	80 91 96 04 	lds	r24, 0x0496
    21f8:	8f 5f       	subi	r24, 0xFF	; 255
    21fa:	80 93 96 04 	sts	0x0496, r24
}
    21fe:	cf 91       	pop	r28
    2200:	df 91       	pop	r29
    2202:	08 95       	ret

00002204 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2204:	df 93       	push	r29
    2206:	cf 93       	push	r28
    2208:	00 d0       	rcall	.+0      	; 0x220a <xTaskResumeAll+0x6>
    220a:	00 d0       	rcall	.+0      	; 0x220c <xTaskResumeAll+0x8>
    220c:	cd b7       	in	r28, 0x3d	; 61
    220e:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2210:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2212:	0f b6       	in	r0, 0x3f	; 63
    2214:	f8 94       	cli
    2216:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2218:	80 91 96 04 	lds	r24, 0x0496
    221c:	81 50       	subi	r24, 0x01	; 1
    221e:	80 93 96 04 	sts	0x0496, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2222:	80 91 96 04 	lds	r24, 0x0496
    2226:	88 23       	and	r24, r24
    2228:	09 f0       	breq	.+2      	; 0x222c <xTaskResumeAll+0x28>
    222a:	6c c0       	rjmp	.+216    	; 0x2304 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    222c:	80 91 90 04 	lds	r24, 0x0490
    2230:	88 23       	and	r24, r24
    2232:	09 f4       	brne	.+2      	; 0x2236 <xTaskResumeAll+0x32>
    2234:	67 c0       	rjmp	.+206    	; 0x2304 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2236:	19 82       	std	Y+1, r1	; 0x01
    2238:	41 c0       	rjmp	.+130    	; 0x22bc <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    223a:	e0 91 da 04 	lds	r30, 0x04DA
    223e:	f0 91 db 04 	lds	r31, 0x04DB
    2242:	86 81       	ldd	r24, Z+6	; 0x06
    2244:	97 81       	ldd	r25, Z+7	; 0x07
    2246:	9c 83       	std	Y+4, r25	; 0x04
    2248:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    224a:	8b 81       	ldd	r24, Y+3	; 0x03
    224c:	9c 81       	ldd	r25, Y+4	; 0x04
    224e:	0c 96       	adiw	r24, 0x0c	; 12
    2250:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2254:	8b 81       	ldd	r24, Y+3	; 0x03
    2256:	9c 81       	ldd	r25, Y+4	; 0x04
    2258:	02 96       	adiw	r24, 0x02	; 2
    225a:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    225e:	eb 81       	ldd	r30, Y+3	; 0x03
    2260:	fc 81       	ldd	r31, Y+4	; 0x04
    2262:	96 89       	ldd	r25, Z+22	; 0x16
    2264:	80 91 94 04 	lds	r24, 0x0494
    2268:	89 17       	cp	r24, r25
    226a:	28 f4       	brcc	.+10     	; 0x2276 <xTaskResumeAll+0x72>
    226c:	eb 81       	ldd	r30, Y+3	; 0x03
    226e:	fc 81       	ldd	r31, Y+4	; 0x04
    2270:	86 89       	ldd	r24, Z+22	; 0x16
    2272:	80 93 94 04 	sts	0x0494, r24
    2276:	eb 81       	ldd	r30, Y+3	; 0x03
    2278:	fc 81       	ldd	r31, Y+4	; 0x04
    227a:	86 89       	ldd	r24, Z+22	; 0x16
    227c:	28 2f       	mov	r18, r24
    227e:	30 e0       	ldi	r19, 0x00	; 0
    2280:	c9 01       	movw	r24, r18
    2282:	88 0f       	add	r24, r24
    2284:	99 1f       	adc	r25, r25
    2286:	88 0f       	add	r24, r24
    2288:	99 1f       	adc	r25, r25
    228a:	88 0f       	add	r24, r24
    228c:	99 1f       	adc	r25, r25
    228e:	82 0f       	add	r24, r18
    2290:	93 1f       	adc	r25, r19
    2292:	85 56       	subi	r24, 0x65	; 101
    2294:	9b 4f       	sbci	r25, 0xFB	; 251
    2296:	2b 81       	ldd	r18, Y+3	; 0x03
    2298:	3c 81       	ldd	r19, Y+4	; 0x04
    229a:	2e 5f       	subi	r18, 0xFE	; 254
    229c:	3f 4f       	sbci	r19, 0xFF	; 255
    229e:	b9 01       	movw	r22, r18
    22a0:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    22a4:	eb 81       	ldd	r30, Y+3	; 0x03
    22a6:	fc 81       	ldd	r31, Y+4	; 0x04
    22a8:	96 89       	ldd	r25, Z+22	; 0x16
    22aa:	e0 91 8d 04 	lds	r30, 0x048D
    22ae:	f0 91 8e 04 	lds	r31, 0x048E
    22b2:	86 89       	ldd	r24, Z+22	; 0x16
    22b4:	98 17       	cp	r25, r24
    22b6:	10 f0       	brcs	.+4      	; 0x22bc <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    22b8:	81 e0       	ldi	r24, 0x01	; 1
    22ba:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    22bc:	80 91 d5 04 	lds	r24, 0x04D5
    22c0:	88 23       	and	r24, r24
    22c2:	09 f0       	breq	.+2      	; 0x22c6 <xTaskResumeAll+0xc2>
    22c4:	ba cf       	rjmp	.-140    	; 0x223a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    22c6:	80 91 97 04 	lds	r24, 0x0497
    22ca:	88 23       	and	r24, r24
    22cc:	71 f0       	breq	.+28     	; 0x22ea <xTaskResumeAll+0xe6>
    22ce:	07 c0       	rjmp	.+14     	; 0x22de <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    22d0:	0e 94 c1 11 	call	0x2382	; 0x2382 <vTaskIncrementTick>
						--uxMissedTicks;
    22d4:	80 91 97 04 	lds	r24, 0x0497
    22d8:	81 50       	subi	r24, 0x01	; 1
    22da:	80 93 97 04 	sts	0x0497, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    22de:	80 91 97 04 	lds	r24, 0x0497
    22e2:	88 23       	and	r24, r24
    22e4:	a9 f7       	brne	.-22     	; 0x22d0 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    22e6:	81 e0       	ldi	r24, 0x01	; 1
    22e8:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    22ea:	89 81       	ldd	r24, Y+1	; 0x01
    22ec:	81 30       	cpi	r24, 0x01	; 1
    22ee:	21 f0       	breq	.+8      	; 0x22f8 <xTaskResumeAll+0xf4>
    22f0:	80 91 98 04 	lds	r24, 0x0498
    22f4:	81 30       	cpi	r24, 0x01	; 1
    22f6:	31 f4       	brne	.+12     	; 0x2304 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    22f8:	81 e0       	ldi	r24, 0x01	; 1
    22fa:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    22fc:	10 92 98 04 	sts	0x0498, r1
					portYIELD_WITHIN_API();
    2300:	0e 94 26 09 	call	0x124c	; 0x124c <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2304:	0f 90       	pop	r0
    2306:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2308:	8a 81       	ldd	r24, Y+2	; 0x02
}
    230a:	0f 90       	pop	r0
    230c:	0f 90       	pop	r0
    230e:	0f 90       	pop	r0
    2310:	0f 90       	pop	r0
    2312:	cf 91       	pop	r28
    2314:	df 91       	pop	r29
    2316:	08 95       	ret

00002318 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2318:	df 93       	push	r29
    231a:	cf 93       	push	r28
    231c:	00 d0       	rcall	.+0      	; 0x231e <xTaskGetTickCount+0x6>
    231e:	cd b7       	in	r28, 0x3d	; 61
    2320:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2322:	0f b6       	in	r0, 0x3f	; 63
    2324:	f8 94       	cli
    2326:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2328:	80 91 91 04 	lds	r24, 0x0491
    232c:	90 91 92 04 	lds	r25, 0x0492
    2330:	9a 83       	std	Y+2, r25	; 0x02
    2332:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2334:	0f 90       	pop	r0
    2336:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2338:	89 81       	ldd	r24, Y+1	; 0x01
    233a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    233c:	0f 90       	pop	r0
    233e:	0f 90       	pop	r0
    2340:	cf 91       	pop	r28
    2342:	df 91       	pop	r29
    2344:	08 95       	ret

00002346 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2346:	df 93       	push	r29
    2348:	cf 93       	push	r28
    234a:	00 d0       	rcall	.+0      	; 0x234c <xTaskGetTickCountFromISR+0x6>
    234c:	0f 92       	push	r0
    234e:	cd b7       	in	r28, 0x3d	; 61
    2350:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2352:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2354:	80 91 91 04 	lds	r24, 0x0491
    2358:	90 91 92 04 	lds	r25, 0x0492
    235c:	9b 83       	std	Y+3, r25	; 0x03
    235e:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2360:	8a 81       	ldd	r24, Y+2	; 0x02
    2362:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2364:	0f 90       	pop	r0
    2366:	0f 90       	pop	r0
    2368:	0f 90       	pop	r0
    236a:	cf 91       	pop	r28
    236c:	df 91       	pop	r29
    236e:	08 95       	ret

00002370 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2370:	df 93       	push	r29
    2372:	cf 93       	push	r28
    2374:	cd b7       	in	r28, 0x3d	; 61
    2376:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2378:	80 91 90 04 	lds	r24, 0x0490
}
    237c:	cf 91       	pop	r28
    237e:	df 91       	pop	r29
    2380:	08 95       	ret

00002382 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2382:	df 93       	push	r29
    2384:	cf 93       	push	r28
    2386:	00 d0       	rcall	.+0      	; 0x2388 <vTaskIncrementTick+0x6>
    2388:	00 d0       	rcall	.+0      	; 0x238a <vTaskIncrementTick+0x8>
    238a:	00 d0       	rcall	.+0      	; 0x238c <vTaskIncrementTick+0xa>
    238c:	cd b7       	in	r28, 0x3d	; 61
    238e:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2390:	80 91 96 04 	lds	r24, 0x0496
    2394:	88 23       	and	r24, r24
    2396:	09 f0       	breq	.+2      	; 0x239a <vTaskIncrementTick+0x18>
    2398:	bb c0       	rjmp	.+374    	; 0x2510 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    239a:	80 91 91 04 	lds	r24, 0x0491
    239e:	90 91 92 04 	lds	r25, 0x0492
    23a2:	01 96       	adiw	r24, 0x01	; 1
    23a4:	90 93 92 04 	sts	0x0492, r25
    23a8:	80 93 91 04 	sts	0x0491, r24
		if( xTickCount == ( portTickType ) 0U )
    23ac:	80 91 91 04 	lds	r24, 0x0491
    23b0:	90 91 92 04 	lds	r25, 0x0492
    23b4:	00 97       	sbiw	r24, 0x00	; 0
    23b6:	d1 f5       	brne	.+116    	; 0x242c <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    23b8:	80 91 d1 04 	lds	r24, 0x04D1
    23bc:	90 91 d2 04 	lds	r25, 0x04D2
    23c0:	9c 83       	std	Y+4, r25	; 0x04
    23c2:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    23c4:	80 91 d3 04 	lds	r24, 0x04D3
    23c8:	90 91 d4 04 	lds	r25, 0x04D4
    23cc:	90 93 d2 04 	sts	0x04D2, r25
    23d0:	80 93 d1 04 	sts	0x04D1, r24
			pxOverflowDelayedTaskList = pxTemp;
    23d4:	8b 81       	ldd	r24, Y+3	; 0x03
    23d6:	9c 81       	ldd	r25, Y+4	; 0x04
    23d8:	90 93 d4 04 	sts	0x04D4, r25
    23dc:	80 93 d3 04 	sts	0x04D3, r24
			xNumOfOverflows++;
    23e0:	80 91 99 04 	lds	r24, 0x0499
    23e4:	8f 5f       	subi	r24, 0xFF	; 255
    23e6:	80 93 99 04 	sts	0x0499, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    23ea:	e0 91 d1 04 	lds	r30, 0x04D1
    23ee:	f0 91 d2 04 	lds	r31, 0x04D2
    23f2:	80 81       	ld	r24, Z
    23f4:	88 23       	and	r24, r24
    23f6:	39 f4       	brne	.+14     	; 0x2406 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    23f8:	8f ef       	ldi	r24, 0xFF	; 255
    23fa:	9f ef       	ldi	r25, 0xFF	; 255
    23fc:	90 93 66 00 	sts	0x0066, r25
    2400:	80 93 65 00 	sts	0x0065, r24
    2404:	13 c0       	rjmp	.+38     	; 0x242c <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2406:	e0 91 d1 04 	lds	r30, 0x04D1
    240a:	f0 91 d2 04 	lds	r31, 0x04D2
    240e:	05 80       	ldd	r0, Z+5	; 0x05
    2410:	f6 81       	ldd	r31, Z+6	; 0x06
    2412:	e0 2d       	mov	r30, r0
    2414:	86 81       	ldd	r24, Z+6	; 0x06
    2416:	97 81       	ldd	r25, Z+7	; 0x07
    2418:	9e 83       	std	Y+6, r25	; 0x06
    241a:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    241c:	ed 81       	ldd	r30, Y+5	; 0x05
    241e:	fe 81       	ldd	r31, Y+6	; 0x06
    2420:	82 81       	ldd	r24, Z+2	; 0x02
    2422:	93 81       	ldd	r25, Z+3	; 0x03
    2424:	90 93 66 00 	sts	0x0066, r25
    2428:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    242c:	20 91 91 04 	lds	r18, 0x0491
    2430:	30 91 92 04 	lds	r19, 0x0492
    2434:	80 91 65 00 	lds	r24, 0x0065
    2438:	90 91 66 00 	lds	r25, 0x0066
    243c:	28 17       	cp	r18, r24
    243e:	39 07       	cpc	r19, r25
    2440:	08 f4       	brcc	.+2      	; 0x2444 <vTaskIncrementTick+0xc2>
    2442:	6b c0       	rjmp	.+214    	; 0x251a <vTaskIncrementTick+0x198>
    2444:	e0 91 d1 04 	lds	r30, 0x04D1
    2448:	f0 91 d2 04 	lds	r31, 0x04D2
    244c:	80 81       	ld	r24, Z
    244e:	88 23       	and	r24, r24
    2450:	39 f4       	brne	.+14     	; 0x2460 <vTaskIncrementTick+0xde>
    2452:	8f ef       	ldi	r24, 0xFF	; 255
    2454:	9f ef       	ldi	r25, 0xFF	; 255
    2456:	90 93 66 00 	sts	0x0066, r25
    245a:	80 93 65 00 	sts	0x0065, r24
    245e:	5d c0       	rjmp	.+186    	; 0x251a <vTaskIncrementTick+0x198>
    2460:	e0 91 d1 04 	lds	r30, 0x04D1
    2464:	f0 91 d2 04 	lds	r31, 0x04D2
    2468:	05 80       	ldd	r0, Z+5	; 0x05
    246a:	f6 81       	ldd	r31, Z+6	; 0x06
    246c:	e0 2d       	mov	r30, r0
    246e:	86 81       	ldd	r24, Z+6	; 0x06
    2470:	97 81       	ldd	r25, Z+7	; 0x07
    2472:	9e 83       	std	Y+6, r25	; 0x06
    2474:	8d 83       	std	Y+5, r24	; 0x05
    2476:	ed 81       	ldd	r30, Y+5	; 0x05
    2478:	fe 81       	ldd	r31, Y+6	; 0x06
    247a:	82 81       	ldd	r24, Z+2	; 0x02
    247c:	93 81       	ldd	r25, Z+3	; 0x03
    247e:	9a 83       	std	Y+2, r25	; 0x02
    2480:	89 83       	std	Y+1, r24	; 0x01
    2482:	20 91 91 04 	lds	r18, 0x0491
    2486:	30 91 92 04 	lds	r19, 0x0492
    248a:	89 81       	ldd	r24, Y+1	; 0x01
    248c:	9a 81       	ldd	r25, Y+2	; 0x02
    248e:	28 17       	cp	r18, r24
    2490:	39 07       	cpc	r19, r25
    2492:	38 f4       	brcc	.+14     	; 0x24a2 <vTaskIncrementTick+0x120>
    2494:	89 81       	ldd	r24, Y+1	; 0x01
    2496:	9a 81       	ldd	r25, Y+2	; 0x02
    2498:	90 93 66 00 	sts	0x0066, r25
    249c:	80 93 65 00 	sts	0x0065, r24
    24a0:	3c c0       	rjmp	.+120    	; 0x251a <vTaskIncrementTick+0x198>
    24a2:	8d 81       	ldd	r24, Y+5	; 0x05
    24a4:	9e 81       	ldd	r25, Y+6	; 0x06
    24a6:	02 96       	adiw	r24, 0x02	; 2
    24a8:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
    24ac:	ed 81       	ldd	r30, Y+5	; 0x05
    24ae:	fe 81       	ldd	r31, Y+6	; 0x06
    24b0:	84 89       	ldd	r24, Z+20	; 0x14
    24b2:	95 89       	ldd	r25, Z+21	; 0x15
    24b4:	00 97       	sbiw	r24, 0x00	; 0
    24b6:	29 f0       	breq	.+10     	; 0x24c2 <vTaskIncrementTick+0x140>
    24b8:	8d 81       	ldd	r24, Y+5	; 0x05
    24ba:	9e 81       	ldd	r25, Y+6	; 0x06
    24bc:	0c 96       	adiw	r24, 0x0c	; 12
    24be:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
    24c2:	ed 81       	ldd	r30, Y+5	; 0x05
    24c4:	fe 81       	ldd	r31, Y+6	; 0x06
    24c6:	96 89       	ldd	r25, Z+22	; 0x16
    24c8:	80 91 94 04 	lds	r24, 0x0494
    24cc:	89 17       	cp	r24, r25
    24ce:	28 f4       	brcc	.+10     	; 0x24da <vTaskIncrementTick+0x158>
    24d0:	ed 81       	ldd	r30, Y+5	; 0x05
    24d2:	fe 81       	ldd	r31, Y+6	; 0x06
    24d4:	86 89       	ldd	r24, Z+22	; 0x16
    24d6:	80 93 94 04 	sts	0x0494, r24
    24da:	ed 81       	ldd	r30, Y+5	; 0x05
    24dc:	fe 81       	ldd	r31, Y+6	; 0x06
    24de:	86 89       	ldd	r24, Z+22	; 0x16
    24e0:	28 2f       	mov	r18, r24
    24e2:	30 e0       	ldi	r19, 0x00	; 0
    24e4:	c9 01       	movw	r24, r18
    24e6:	88 0f       	add	r24, r24
    24e8:	99 1f       	adc	r25, r25
    24ea:	88 0f       	add	r24, r24
    24ec:	99 1f       	adc	r25, r25
    24ee:	88 0f       	add	r24, r24
    24f0:	99 1f       	adc	r25, r25
    24f2:	82 0f       	add	r24, r18
    24f4:	93 1f       	adc	r25, r19
    24f6:	ac 01       	movw	r20, r24
    24f8:	45 56       	subi	r20, 0x65	; 101
    24fa:	5b 4f       	sbci	r21, 0xFB	; 251
    24fc:	8d 81       	ldd	r24, Y+5	; 0x05
    24fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2500:	9c 01       	movw	r18, r24
    2502:	2e 5f       	subi	r18, 0xFE	; 254
    2504:	3f 4f       	sbci	r19, 0xFF	; 255
    2506:	ca 01       	movw	r24, r20
    2508:	b9 01       	movw	r22, r18
    250a:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>
    250e:	9a cf       	rjmp	.-204    	; 0x2444 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2510:	80 91 97 04 	lds	r24, 0x0497
    2514:	8f 5f       	subi	r24, 0xFF	; 255
    2516:	80 93 97 04 	sts	0x0497, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    251a:	26 96       	adiw	r28, 0x06	; 6
    251c:	0f b6       	in	r0, 0x3f	; 63
    251e:	f8 94       	cli
    2520:	de bf       	out	0x3e, r29	; 62
    2522:	0f be       	out	0x3f, r0	; 63
    2524:	cd bf       	out	0x3d, r28	; 61
    2526:	cf 91       	pop	r28
    2528:	df 91       	pop	r29
    252a:	08 95       	ret

0000252c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    252c:	df 93       	push	r29
    252e:	cf 93       	push	r28
    2530:	00 d0       	rcall	.+0      	; 0x2532 <vTaskSwitchContext+0x6>
    2532:	cd b7       	in	r28, 0x3d	; 61
    2534:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2536:	80 91 96 04 	lds	r24, 0x0496
    253a:	88 23       	and	r24, r24
    253c:	49 f0       	breq	.+18     	; 0x2550 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    253e:	81 e0       	ldi	r24, 0x01	; 1
    2540:	80 93 98 04 	sts	0x0498, r24
    2544:	54 c0       	rjmp	.+168    	; 0x25ee <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2546:	80 91 94 04 	lds	r24, 0x0494
    254a:	81 50       	subi	r24, 0x01	; 1
    254c:	80 93 94 04 	sts	0x0494, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2550:	80 91 94 04 	lds	r24, 0x0494
    2554:	28 2f       	mov	r18, r24
    2556:	30 e0       	ldi	r19, 0x00	; 0
    2558:	c9 01       	movw	r24, r18
    255a:	88 0f       	add	r24, r24
    255c:	99 1f       	adc	r25, r25
    255e:	88 0f       	add	r24, r24
    2560:	99 1f       	adc	r25, r25
    2562:	88 0f       	add	r24, r24
    2564:	99 1f       	adc	r25, r25
    2566:	82 0f       	add	r24, r18
    2568:	93 1f       	adc	r25, r19
    256a:	fc 01       	movw	r30, r24
    256c:	e5 56       	subi	r30, 0x65	; 101
    256e:	fb 4f       	sbci	r31, 0xFB	; 251
    2570:	80 81       	ld	r24, Z
    2572:	88 23       	and	r24, r24
    2574:	41 f3       	breq	.-48     	; 0x2546 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2576:	80 91 94 04 	lds	r24, 0x0494
    257a:	28 2f       	mov	r18, r24
    257c:	30 e0       	ldi	r19, 0x00	; 0
    257e:	c9 01       	movw	r24, r18
    2580:	88 0f       	add	r24, r24
    2582:	99 1f       	adc	r25, r25
    2584:	88 0f       	add	r24, r24
    2586:	99 1f       	adc	r25, r25
    2588:	88 0f       	add	r24, r24
    258a:	99 1f       	adc	r25, r25
    258c:	82 0f       	add	r24, r18
    258e:	93 1f       	adc	r25, r19
    2590:	85 56       	subi	r24, 0x65	; 101
    2592:	9b 4f       	sbci	r25, 0xFB	; 251
    2594:	9a 83       	std	Y+2, r25	; 0x02
    2596:	89 83       	std	Y+1, r24	; 0x01
    2598:	e9 81       	ldd	r30, Y+1	; 0x01
    259a:	fa 81       	ldd	r31, Y+2	; 0x02
    259c:	01 80       	ldd	r0, Z+1	; 0x01
    259e:	f2 81       	ldd	r31, Z+2	; 0x02
    25a0:	e0 2d       	mov	r30, r0
    25a2:	82 81       	ldd	r24, Z+2	; 0x02
    25a4:	93 81       	ldd	r25, Z+3	; 0x03
    25a6:	e9 81       	ldd	r30, Y+1	; 0x01
    25a8:	fa 81       	ldd	r31, Y+2	; 0x02
    25aa:	92 83       	std	Z+2, r25	; 0x02
    25ac:	81 83       	std	Z+1, r24	; 0x01
    25ae:	e9 81       	ldd	r30, Y+1	; 0x01
    25b0:	fa 81       	ldd	r31, Y+2	; 0x02
    25b2:	21 81       	ldd	r18, Z+1	; 0x01
    25b4:	32 81       	ldd	r19, Z+2	; 0x02
    25b6:	89 81       	ldd	r24, Y+1	; 0x01
    25b8:	9a 81       	ldd	r25, Y+2	; 0x02
    25ba:	03 96       	adiw	r24, 0x03	; 3
    25bc:	28 17       	cp	r18, r24
    25be:	39 07       	cpc	r19, r25
    25c0:	59 f4       	brne	.+22     	; 0x25d8 <vTaskSwitchContext+0xac>
    25c2:	e9 81       	ldd	r30, Y+1	; 0x01
    25c4:	fa 81       	ldd	r31, Y+2	; 0x02
    25c6:	01 80       	ldd	r0, Z+1	; 0x01
    25c8:	f2 81       	ldd	r31, Z+2	; 0x02
    25ca:	e0 2d       	mov	r30, r0
    25cc:	82 81       	ldd	r24, Z+2	; 0x02
    25ce:	93 81       	ldd	r25, Z+3	; 0x03
    25d0:	e9 81       	ldd	r30, Y+1	; 0x01
    25d2:	fa 81       	ldd	r31, Y+2	; 0x02
    25d4:	92 83       	std	Z+2, r25	; 0x02
    25d6:	81 83       	std	Z+1, r24	; 0x01
    25d8:	e9 81       	ldd	r30, Y+1	; 0x01
    25da:	fa 81       	ldd	r31, Y+2	; 0x02
    25dc:	01 80       	ldd	r0, Z+1	; 0x01
    25de:	f2 81       	ldd	r31, Z+2	; 0x02
    25e0:	e0 2d       	mov	r30, r0
    25e2:	86 81       	ldd	r24, Z+6	; 0x06
    25e4:	97 81       	ldd	r25, Z+7	; 0x07
    25e6:	90 93 8e 04 	sts	0x048E, r25
    25ea:	80 93 8d 04 	sts	0x048D, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    25ee:	0f 90       	pop	r0
    25f0:	0f 90       	pop	r0
    25f2:	cf 91       	pop	r28
    25f4:	df 91       	pop	r29
    25f6:	08 95       	ret

000025f8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25f8:	df 93       	push	r29
    25fa:	cf 93       	push	r28
    25fc:	00 d0       	rcall	.+0      	; 0x25fe <vTaskPlaceOnEventList+0x6>
    25fe:	00 d0       	rcall	.+0      	; 0x2600 <vTaskPlaceOnEventList+0x8>
    2600:	00 d0       	rcall	.+0      	; 0x2602 <vTaskPlaceOnEventList+0xa>
    2602:	cd b7       	in	r28, 0x3d	; 61
    2604:	de b7       	in	r29, 0x3e	; 62
    2606:	9c 83       	std	Y+4, r25	; 0x04
    2608:	8b 83       	std	Y+3, r24	; 0x03
    260a:	7e 83       	std	Y+6, r23	; 0x06
    260c:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    260e:	4b 81       	ldd	r20, Y+3	; 0x03
    2610:	5c 81       	ldd	r21, Y+4	; 0x04
    2612:	80 91 8d 04 	lds	r24, 0x048D
    2616:	90 91 8e 04 	lds	r25, 0x048E
    261a:	9c 01       	movw	r18, r24
    261c:	24 5f       	subi	r18, 0xF4	; 244
    261e:	3f 4f       	sbci	r19, 0xFF	; 255
    2620:	ca 01       	movw	r24, r20
    2622:	b9 01       	movw	r22, r18
    2624:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2628:	80 91 8d 04 	lds	r24, 0x048D
    262c:	90 91 8e 04 	lds	r25, 0x048E
    2630:	02 96       	adiw	r24, 0x02	; 2
    2632:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2636:	20 91 91 04 	lds	r18, 0x0491
    263a:	30 91 92 04 	lds	r19, 0x0492
    263e:	8d 81       	ldd	r24, Y+5	; 0x05
    2640:	9e 81       	ldd	r25, Y+6	; 0x06
    2642:	82 0f       	add	r24, r18
    2644:	93 1f       	adc	r25, r19
    2646:	9a 83       	std	Y+2, r25	; 0x02
    2648:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    264a:	89 81       	ldd	r24, Y+1	; 0x01
    264c:	9a 81       	ldd	r25, Y+2	; 0x02
    264e:	0e 94 f6 14 	call	0x29ec	; 0x29ec <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2652:	26 96       	adiw	r28, 0x06	; 6
    2654:	0f b6       	in	r0, 0x3f	; 63
    2656:	f8 94       	cli
    2658:	de bf       	out	0x3e, r29	; 62
    265a:	0f be       	out	0x3f, r0	; 63
    265c:	cd bf       	out	0x3d, r28	; 61
    265e:	cf 91       	pop	r28
    2660:	df 91       	pop	r29
    2662:	08 95       	ret

00002664 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2664:	df 93       	push	r29
    2666:	cf 93       	push	r28
    2668:	00 d0       	rcall	.+0      	; 0x266a <xTaskRemoveFromEventList+0x6>
    266a:	00 d0       	rcall	.+0      	; 0x266c <xTaskRemoveFromEventList+0x8>
    266c:	0f 92       	push	r0
    266e:	cd b7       	in	r28, 0x3d	; 61
    2670:	de b7       	in	r29, 0x3e	; 62
    2672:	9d 83       	std	Y+5, r25	; 0x05
    2674:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2676:	ec 81       	ldd	r30, Y+4	; 0x04
    2678:	fd 81       	ldd	r31, Y+5	; 0x05
    267a:	05 80       	ldd	r0, Z+5	; 0x05
    267c:	f6 81       	ldd	r31, Z+6	; 0x06
    267e:	e0 2d       	mov	r30, r0
    2680:	86 81       	ldd	r24, Z+6	; 0x06
    2682:	97 81       	ldd	r25, Z+7	; 0x07
    2684:	9b 83       	std	Y+3, r25	; 0x03
    2686:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2688:	8a 81       	ldd	r24, Y+2	; 0x02
    268a:	9b 81       	ldd	r25, Y+3	; 0x03
    268c:	0c 96       	adiw	r24, 0x0c	; 12
    268e:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2692:	80 91 96 04 	lds	r24, 0x0496
    2696:	88 23       	and	r24, r24
    2698:	61 f5       	brne	.+88     	; 0x26f2 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    269a:	8a 81       	ldd	r24, Y+2	; 0x02
    269c:	9b 81       	ldd	r25, Y+3	; 0x03
    269e:	02 96       	adiw	r24, 0x02	; 2
    26a0:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    26a4:	ea 81       	ldd	r30, Y+2	; 0x02
    26a6:	fb 81       	ldd	r31, Y+3	; 0x03
    26a8:	96 89       	ldd	r25, Z+22	; 0x16
    26aa:	80 91 94 04 	lds	r24, 0x0494
    26ae:	89 17       	cp	r24, r25
    26b0:	28 f4       	brcc	.+10     	; 0x26bc <xTaskRemoveFromEventList+0x58>
    26b2:	ea 81       	ldd	r30, Y+2	; 0x02
    26b4:	fb 81       	ldd	r31, Y+3	; 0x03
    26b6:	86 89       	ldd	r24, Z+22	; 0x16
    26b8:	80 93 94 04 	sts	0x0494, r24
    26bc:	ea 81       	ldd	r30, Y+2	; 0x02
    26be:	fb 81       	ldd	r31, Y+3	; 0x03
    26c0:	86 89       	ldd	r24, Z+22	; 0x16
    26c2:	28 2f       	mov	r18, r24
    26c4:	30 e0       	ldi	r19, 0x00	; 0
    26c6:	c9 01       	movw	r24, r18
    26c8:	88 0f       	add	r24, r24
    26ca:	99 1f       	adc	r25, r25
    26cc:	88 0f       	add	r24, r24
    26ce:	99 1f       	adc	r25, r25
    26d0:	88 0f       	add	r24, r24
    26d2:	99 1f       	adc	r25, r25
    26d4:	82 0f       	add	r24, r18
    26d6:	93 1f       	adc	r25, r19
    26d8:	ac 01       	movw	r20, r24
    26da:	45 56       	subi	r20, 0x65	; 101
    26dc:	5b 4f       	sbci	r21, 0xFB	; 251
    26de:	8a 81       	ldd	r24, Y+2	; 0x02
    26e0:	9b 81       	ldd	r25, Y+3	; 0x03
    26e2:	9c 01       	movw	r18, r24
    26e4:	2e 5f       	subi	r18, 0xFE	; 254
    26e6:	3f 4f       	sbci	r19, 0xFF	; 255
    26e8:	ca 01       	movw	r24, r20
    26ea:	b9 01       	movw	r22, r18
    26ec:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>
    26f0:	0a c0       	rjmp	.+20     	; 0x2706 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    26f2:	8a 81       	ldd	r24, Y+2	; 0x02
    26f4:	9b 81       	ldd	r25, Y+3	; 0x03
    26f6:	9c 01       	movw	r18, r24
    26f8:	24 5f       	subi	r18, 0xF4	; 244
    26fa:	3f 4f       	sbci	r19, 0xFF	; 255
    26fc:	85 ed       	ldi	r24, 0xD5	; 213
    26fe:	94 e0       	ldi	r25, 0x04	; 4
    2700:	b9 01       	movw	r22, r18
    2702:	0e 94 2c 06 	call	0xc58	; 0xc58 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2706:	ea 81       	ldd	r30, Y+2	; 0x02
    2708:	fb 81       	ldd	r31, Y+3	; 0x03
    270a:	96 89       	ldd	r25, Z+22	; 0x16
    270c:	e0 91 8d 04 	lds	r30, 0x048D
    2710:	f0 91 8e 04 	lds	r31, 0x048E
    2714:	86 89       	ldd	r24, Z+22	; 0x16
    2716:	98 17       	cp	r25, r24
    2718:	18 f0       	brcs	.+6      	; 0x2720 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	89 83       	std	Y+1, r24	; 0x01
    271e:	01 c0       	rjmp	.+2      	; 0x2722 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2720:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2722:	89 81       	ldd	r24, Y+1	; 0x01
}
    2724:	0f 90       	pop	r0
    2726:	0f 90       	pop	r0
    2728:	0f 90       	pop	r0
    272a:	0f 90       	pop	r0
    272c:	0f 90       	pop	r0
    272e:	cf 91       	pop	r28
    2730:	df 91       	pop	r29
    2732:	08 95       	ret

00002734 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2734:	df 93       	push	r29
    2736:	cf 93       	push	r28
    2738:	00 d0       	rcall	.+0      	; 0x273a <vTaskSetTimeOutState+0x6>
    273a:	cd b7       	in	r28, 0x3d	; 61
    273c:	de b7       	in	r29, 0x3e	; 62
    273e:	9a 83       	std	Y+2, r25	; 0x02
    2740:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2742:	80 91 99 04 	lds	r24, 0x0499
    2746:	e9 81       	ldd	r30, Y+1	; 0x01
    2748:	fa 81       	ldd	r31, Y+2	; 0x02
    274a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    274c:	80 91 91 04 	lds	r24, 0x0491
    2750:	90 91 92 04 	lds	r25, 0x0492
    2754:	e9 81       	ldd	r30, Y+1	; 0x01
    2756:	fa 81       	ldd	r31, Y+2	; 0x02
    2758:	92 83       	std	Z+2, r25	; 0x02
    275a:	81 83       	std	Z+1, r24	; 0x01
}
    275c:	0f 90       	pop	r0
    275e:	0f 90       	pop	r0
    2760:	cf 91       	pop	r28
    2762:	df 91       	pop	r29
    2764:	08 95       	ret

00002766 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2766:	df 93       	push	r29
    2768:	cf 93       	push	r28
    276a:	00 d0       	rcall	.+0      	; 0x276c <xTaskCheckForTimeOut+0x6>
    276c:	00 d0       	rcall	.+0      	; 0x276e <xTaskCheckForTimeOut+0x8>
    276e:	0f 92       	push	r0
    2770:	cd b7       	in	r28, 0x3d	; 61
    2772:	de b7       	in	r29, 0x3e	; 62
    2774:	9b 83       	std	Y+3, r25	; 0x03
    2776:	8a 83       	std	Y+2, r24	; 0x02
    2778:	7d 83       	std	Y+5, r23	; 0x05
    277a:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    277c:	0f b6       	in	r0, 0x3f	; 63
    277e:	f8 94       	cli
    2780:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2782:	ea 81       	ldd	r30, Y+2	; 0x02
    2784:	fb 81       	ldd	r31, Y+3	; 0x03
    2786:	90 81       	ld	r25, Z
    2788:	80 91 99 04 	lds	r24, 0x0499
    278c:	98 17       	cp	r25, r24
    278e:	71 f0       	breq	.+28     	; 0x27ac <xTaskCheckForTimeOut+0x46>
    2790:	ea 81       	ldd	r30, Y+2	; 0x02
    2792:	fb 81       	ldd	r31, Y+3	; 0x03
    2794:	21 81       	ldd	r18, Z+1	; 0x01
    2796:	32 81       	ldd	r19, Z+2	; 0x02
    2798:	80 91 91 04 	lds	r24, 0x0491
    279c:	90 91 92 04 	lds	r25, 0x0492
    27a0:	82 17       	cp	r24, r18
    27a2:	93 07       	cpc	r25, r19
    27a4:	18 f0       	brcs	.+6      	; 0x27ac <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    27a6:	81 e0       	ldi	r24, 0x01	; 1
    27a8:	89 83       	std	Y+1, r24	; 0x01
    27aa:	2f c0       	rjmp	.+94     	; 0x280a <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    27ac:	20 91 91 04 	lds	r18, 0x0491
    27b0:	30 91 92 04 	lds	r19, 0x0492
    27b4:	ea 81       	ldd	r30, Y+2	; 0x02
    27b6:	fb 81       	ldd	r31, Y+3	; 0x03
    27b8:	81 81       	ldd	r24, Z+1	; 0x01
    27ba:	92 81       	ldd	r25, Z+2	; 0x02
    27bc:	28 1b       	sub	r18, r24
    27be:	39 0b       	sbc	r19, r25
    27c0:	ec 81       	ldd	r30, Y+4	; 0x04
    27c2:	fd 81       	ldd	r31, Y+5	; 0x05
    27c4:	80 81       	ld	r24, Z
    27c6:	91 81       	ldd	r25, Z+1	; 0x01
    27c8:	28 17       	cp	r18, r24
    27ca:	39 07       	cpc	r19, r25
    27cc:	e0 f4       	brcc	.+56     	; 0x2806 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    27ce:	ec 81       	ldd	r30, Y+4	; 0x04
    27d0:	fd 81       	ldd	r31, Y+5	; 0x05
    27d2:	40 81       	ld	r20, Z
    27d4:	51 81       	ldd	r21, Z+1	; 0x01
    27d6:	ea 81       	ldd	r30, Y+2	; 0x02
    27d8:	fb 81       	ldd	r31, Y+3	; 0x03
    27da:	21 81       	ldd	r18, Z+1	; 0x01
    27dc:	32 81       	ldd	r19, Z+2	; 0x02
    27de:	80 91 91 04 	lds	r24, 0x0491
    27e2:	90 91 92 04 	lds	r25, 0x0492
    27e6:	b9 01       	movw	r22, r18
    27e8:	68 1b       	sub	r22, r24
    27ea:	79 0b       	sbc	r23, r25
    27ec:	cb 01       	movw	r24, r22
    27ee:	84 0f       	add	r24, r20
    27f0:	95 1f       	adc	r25, r21
    27f2:	ec 81       	ldd	r30, Y+4	; 0x04
    27f4:	fd 81       	ldd	r31, Y+5	; 0x05
    27f6:	91 83       	std	Z+1, r25	; 0x01
    27f8:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    27fa:	8a 81       	ldd	r24, Y+2	; 0x02
    27fc:	9b 81       	ldd	r25, Y+3	; 0x03
    27fe:	0e 94 9a 13 	call	0x2734	; 0x2734 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2802:	19 82       	std	Y+1, r1	; 0x01
    2804:	02 c0       	rjmp	.+4      	; 0x280a <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2806:	81 e0       	ldi	r24, 0x01	; 1
    2808:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    280a:	0f 90       	pop	r0
    280c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    280e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2810:	0f 90       	pop	r0
    2812:	0f 90       	pop	r0
    2814:	0f 90       	pop	r0
    2816:	0f 90       	pop	r0
    2818:	0f 90       	pop	r0
    281a:	cf 91       	pop	r28
    281c:	df 91       	pop	r29
    281e:	08 95       	ret

00002820 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2820:	df 93       	push	r29
    2822:	cf 93       	push	r28
    2824:	cd b7       	in	r28, 0x3d	; 61
    2826:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2828:	81 e0       	ldi	r24, 0x01	; 1
    282a:	80 93 98 04 	sts	0x0498, r24
}
    282e:	cf 91       	pop	r28
    2830:	df 91       	pop	r29
    2832:	08 95       	ret

00002834 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2834:	df 93       	push	r29
    2836:	cf 93       	push	r28
    2838:	00 d0       	rcall	.+0      	; 0x283a <prvIdleTask+0x6>
    283a:	cd b7       	in	r28, 0x3d	; 61
    283c:	de b7       	in	r29, 0x3e	; 62
    283e:	9a 83       	std	Y+2, r25	; 0x02
    2840:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2842:	0e 94 b8 14 	call	0x2970	; 0x2970 <prvCheckTasksWaitingTermination>
    2846:	fd cf       	rjmp	.-6      	; 0x2842 <prvIdleTask+0xe>

00002848 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2848:	0f 93       	push	r16
    284a:	1f 93       	push	r17
    284c:	df 93       	push	r29
    284e:	cf 93       	push	r28
    2850:	cd b7       	in	r28, 0x3d	; 61
    2852:	de b7       	in	r29, 0x3e	; 62
    2854:	29 97       	sbiw	r28, 0x09	; 9
    2856:	0f b6       	in	r0, 0x3f	; 63
    2858:	f8 94       	cli
    285a:	de bf       	out	0x3e, r29	; 62
    285c:	0f be       	out	0x3f, r0	; 63
    285e:	cd bf       	out	0x3d, r28	; 61
    2860:	9a 83       	std	Y+2, r25	; 0x02
    2862:	89 83       	std	Y+1, r24	; 0x01
    2864:	7c 83       	std	Y+4, r23	; 0x04
    2866:	6b 83       	std	Y+3, r22	; 0x03
    2868:	4d 83       	std	Y+5, r20	; 0x05
    286a:	3f 83       	std	Y+7, r19	; 0x07
    286c:	2e 83       	std	Y+6, r18	; 0x06
    286e:	19 87       	std	Y+9, r17	; 0x09
    2870:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2872:	89 81       	ldd	r24, Y+1	; 0x01
    2874:	9a 81       	ldd	r25, Y+2	; 0x02
    2876:	49 96       	adiw	r24, 0x19	; 25
    2878:	2b 81       	ldd	r18, Y+3	; 0x03
    287a:	3c 81       	ldd	r19, Y+4	; 0x04
    287c:	b9 01       	movw	r22, r18
    287e:	48 e0       	ldi	r20, 0x08	; 8
    2880:	50 e0       	ldi	r21, 0x00	; 0
    2882:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2886:	e9 81       	ldd	r30, Y+1	; 0x01
    2888:	fa 81       	ldd	r31, Y+2	; 0x02
    288a:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    288c:	8d 81       	ldd	r24, Y+5	; 0x05
    288e:	84 30       	cpi	r24, 0x04	; 4
    2890:	10 f0       	brcs	.+4      	; 0x2896 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2892:	83 e0       	ldi	r24, 0x03	; 3
    2894:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2896:	e9 81       	ldd	r30, Y+1	; 0x01
    2898:	fa 81       	ldd	r31, Y+2	; 0x02
    289a:	8d 81       	ldd	r24, Y+5	; 0x05
    289c:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    289e:	89 81       	ldd	r24, Y+1	; 0x01
    28a0:	9a 81       	ldd	r25, Y+2	; 0x02
    28a2:	02 96       	adiw	r24, 0x02	; 2
    28a4:	0e 94 1c 06 	call	0xc38	; 0xc38 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    28a8:	89 81       	ldd	r24, Y+1	; 0x01
    28aa:	9a 81       	ldd	r25, Y+2	; 0x02
    28ac:	0c 96       	adiw	r24, 0x0c	; 12
    28ae:	0e 94 1c 06 	call	0xc38	; 0xc38 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    28b2:	e9 81       	ldd	r30, Y+1	; 0x01
    28b4:	fa 81       	ldd	r31, Y+2	; 0x02
    28b6:	89 81       	ldd	r24, Y+1	; 0x01
    28b8:	9a 81       	ldd	r25, Y+2	; 0x02
    28ba:	91 87       	std	Z+9, r25	; 0x09
    28bc:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    28be:	8d 81       	ldd	r24, Y+5	; 0x05
    28c0:	28 2f       	mov	r18, r24
    28c2:	30 e0       	ldi	r19, 0x00	; 0
    28c4:	84 e0       	ldi	r24, 0x04	; 4
    28c6:	90 e0       	ldi	r25, 0x00	; 0
    28c8:	82 1b       	sub	r24, r18
    28ca:	93 0b       	sbc	r25, r19
    28cc:	e9 81       	ldd	r30, Y+1	; 0x01
    28ce:	fa 81       	ldd	r31, Y+2	; 0x02
    28d0:	95 87       	std	Z+13, r25	; 0x0d
    28d2:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    28d4:	e9 81       	ldd	r30, Y+1	; 0x01
    28d6:	fa 81       	ldd	r31, Y+2	; 0x02
    28d8:	89 81       	ldd	r24, Y+1	; 0x01
    28da:	9a 81       	ldd	r25, Y+2	; 0x02
    28dc:	93 8b       	std	Z+19, r25	; 0x13
    28de:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    28e0:	29 96       	adiw	r28, 0x09	; 9
    28e2:	0f b6       	in	r0, 0x3f	; 63
    28e4:	f8 94       	cli
    28e6:	de bf       	out	0x3e, r29	; 62
    28e8:	0f be       	out	0x3f, r0	; 63
    28ea:	cd bf       	out	0x3d, r28	; 61
    28ec:	cf 91       	pop	r28
    28ee:	df 91       	pop	r29
    28f0:	1f 91       	pop	r17
    28f2:	0f 91       	pop	r16
    28f4:	08 95       	ret

000028f6 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    28f6:	df 93       	push	r29
    28f8:	cf 93       	push	r28
    28fa:	0f 92       	push	r0
    28fc:	cd b7       	in	r28, 0x3d	; 61
    28fe:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2900:	19 82       	std	Y+1, r1	; 0x01
    2902:	13 c0       	rjmp	.+38     	; 0x292a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2904:	89 81       	ldd	r24, Y+1	; 0x01
    2906:	28 2f       	mov	r18, r24
    2908:	30 e0       	ldi	r19, 0x00	; 0
    290a:	c9 01       	movw	r24, r18
    290c:	88 0f       	add	r24, r24
    290e:	99 1f       	adc	r25, r25
    2910:	88 0f       	add	r24, r24
    2912:	99 1f       	adc	r25, r25
    2914:	88 0f       	add	r24, r24
    2916:	99 1f       	adc	r25, r25
    2918:	82 0f       	add	r24, r18
    291a:	93 1f       	adc	r25, r19
    291c:	85 56       	subi	r24, 0x65	; 101
    291e:	9b 4f       	sbci	r25, 0xFB	; 251
    2920:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2924:	89 81       	ldd	r24, Y+1	; 0x01
    2926:	8f 5f       	subi	r24, 0xFF	; 255
    2928:	89 83       	std	Y+1, r24	; 0x01
    292a:	89 81       	ldd	r24, Y+1	; 0x01
    292c:	84 30       	cpi	r24, 0x04	; 4
    292e:	50 f3       	brcs	.-44     	; 0x2904 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2930:	8f eb       	ldi	r24, 0xBF	; 191
    2932:	94 e0       	ldi	r25, 0x04	; 4
    2934:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2938:	88 ec       	ldi	r24, 0xC8	; 200
    293a:	94 e0       	ldi	r25, 0x04	; 4
    293c:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2940:	85 ed       	ldi	r24, 0xD5	; 213
    2942:	94 e0       	ldi	r25, 0x04	; 4
    2944:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2948:	8e ed       	ldi	r24, 0xDE	; 222
    294a:	94 e0       	ldi	r25, 0x04	; 4
    294c:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2950:	8f eb       	ldi	r24, 0xBF	; 191
    2952:	94 e0       	ldi	r25, 0x04	; 4
    2954:	90 93 d2 04 	sts	0x04D2, r25
    2958:	80 93 d1 04 	sts	0x04D1, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    295c:	88 ec       	ldi	r24, 0xC8	; 200
    295e:	94 e0       	ldi	r25, 0x04	; 4
    2960:	90 93 d4 04 	sts	0x04D4, r25
    2964:	80 93 d3 04 	sts	0x04D3, r24
}
    2968:	0f 90       	pop	r0
    296a:	cf 91       	pop	r28
    296c:	df 91       	pop	r29
    296e:	08 95       	ret

00002970 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2970:	df 93       	push	r29
    2972:	cf 93       	push	r28
    2974:	00 d0       	rcall	.+0      	; 0x2976 <prvCheckTasksWaitingTermination+0x6>
    2976:	0f 92       	push	r0
    2978:	cd b7       	in	r28, 0x3d	; 61
    297a:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    297c:	80 91 8f 04 	lds	r24, 0x048F
    2980:	88 23       	and	r24, r24
    2982:	71 f1       	breq	.+92     	; 0x29e0 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2984:	0e 94 f6 10 	call	0x21ec	; 0x21ec <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2988:	80 91 de 04 	lds	r24, 0x04DE
    298c:	1b 82       	std	Y+3, r1	; 0x03
    298e:	88 23       	and	r24, r24
    2990:	11 f4       	brne	.+4      	; 0x2996 <prvCheckTasksWaitingTermination+0x26>
    2992:	81 e0       	ldi	r24, 0x01	; 1
    2994:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2996:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    299a:	8b 81       	ldd	r24, Y+3	; 0x03
    299c:	88 23       	and	r24, r24
    299e:	01 f5       	brne	.+64     	; 0x29e0 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    29a0:	0f b6       	in	r0, 0x3f	; 63
    29a2:	f8 94       	cli
    29a4:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    29a6:	e0 91 e3 04 	lds	r30, 0x04E3
    29aa:	f0 91 e4 04 	lds	r31, 0x04E4
    29ae:	86 81       	ldd	r24, Z+6	; 0x06
    29b0:	97 81       	ldd	r25, Z+7	; 0x07
    29b2:	9a 83       	std	Y+2, r25	; 0x02
    29b4:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    29b6:	89 81       	ldd	r24, Y+1	; 0x01
    29b8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ba:	02 96       	adiw	r24, 0x02	; 2
    29bc:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <vListRemove>
					--uxCurrentNumberOfTasks;
    29c0:	80 91 90 04 	lds	r24, 0x0490
    29c4:	81 50       	subi	r24, 0x01	; 1
    29c6:	80 93 90 04 	sts	0x0490, r24
					--uxTasksDeleted;
    29ca:	80 91 8f 04 	lds	r24, 0x048F
    29ce:	81 50       	subi	r24, 0x01	; 1
    29d0:	80 93 8f 04 	sts	0x048F, r24
				}
				taskEXIT_CRITICAL();
    29d4:	0f 90       	pop	r0
    29d6:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    29d8:	89 81       	ldd	r24, Y+1	; 0x01
    29da:	9a 81       	ldd	r25, Y+2	; 0x02
    29dc:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <prvDeleteTCB>
			}
		}
	}
	#endif
}
    29e0:	0f 90       	pop	r0
    29e2:	0f 90       	pop	r0
    29e4:	0f 90       	pop	r0
    29e6:	cf 91       	pop	r28
    29e8:	df 91       	pop	r29
    29ea:	08 95       	ret

000029ec <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    29ec:	df 93       	push	r29
    29ee:	cf 93       	push	r28
    29f0:	00 d0       	rcall	.+0      	; 0x29f2 <prvAddCurrentTaskToDelayedList+0x6>
    29f2:	cd b7       	in	r28, 0x3d	; 61
    29f4:	de b7       	in	r29, 0x3e	; 62
    29f6:	9a 83       	std	Y+2, r25	; 0x02
    29f8:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    29fa:	e0 91 8d 04 	lds	r30, 0x048D
    29fe:	f0 91 8e 04 	lds	r31, 0x048E
    2a02:	89 81       	ldd	r24, Y+1	; 0x01
    2a04:	9a 81       	ldd	r25, Y+2	; 0x02
    2a06:	93 83       	std	Z+3, r25	; 0x03
    2a08:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2a0a:	20 91 91 04 	lds	r18, 0x0491
    2a0e:	30 91 92 04 	lds	r19, 0x0492
    2a12:	89 81       	ldd	r24, Y+1	; 0x01
    2a14:	9a 81       	ldd	r25, Y+2	; 0x02
    2a16:	82 17       	cp	r24, r18
    2a18:	93 07       	cpc	r25, r19
    2a1a:	70 f4       	brcc	.+28     	; 0x2a38 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a1c:	80 91 d3 04 	lds	r24, 0x04D3
    2a20:	90 91 d4 04 	lds	r25, 0x04D4
    2a24:	20 91 8d 04 	lds	r18, 0x048D
    2a28:	30 91 8e 04 	lds	r19, 0x048E
    2a2c:	2e 5f       	subi	r18, 0xFE	; 254
    2a2e:	3f 4f       	sbci	r19, 0xFF	; 255
    2a30:	b9 01       	movw	r22, r18
    2a32:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vListInsert>
    2a36:	1e c0       	rjmp	.+60     	; 0x2a74 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a38:	40 91 d1 04 	lds	r20, 0x04D1
    2a3c:	50 91 d2 04 	lds	r21, 0x04D2
    2a40:	80 91 8d 04 	lds	r24, 0x048D
    2a44:	90 91 8e 04 	lds	r25, 0x048E
    2a48:	9c 01       	movw	r18, r24
    2a4a:	2e 5f       	subi	r18, 0xFE	; 254
    2a4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a4e:	ca 01       	movw	r24, r20
    2a50:	b9 01       	movw	r22, r18
    2a52:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2a56:	20 91 65 00 	lds	r18, 0x0065
    2a5a:	30 91 66 00 	lds	r19, 0x0066
    2a5e:	89 81       	ldd	r24, Y+1	; 0x01
    2a60:	9a 81       	ldd	r25, Y+2	; 0x02
    2a62:	82 17       	cp	r24, r18
    2a64:	93 07       	cpc	r25, r19
    2a66:	30 f4       	brcc	.+12     	; 0x2a74 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2a68:	89 81       	ldd	r24, Y+1	; 0x01
    2a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a6c:	90 93 66 00 	sts	0x0066, r25
    2a70:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    2a74:	0f 90       	pop	r0
    2a76:	0f 90       	pop	r0
    2a78:	cf 91       	pop	r28
    2a7a:	df 91       	pop	r29
    2a7c:	08 95       	ret

00002a7e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2a7e:	df 93       	push	r29
    2a80:	cf 93       	push	r28
    2a82:	cd b7       	in	r28, 0x3d	; 61
    2a84:	de b7       	in	r29, 0x3e	; 62
    2a86:	28 97       	sbiw	r28, 0x08	; 8
    2a88:	0f b6       	in	r0, 0x3f	; 63
    2a8a:	f8 94       	cli
    2a8c:	de bf       	out	0x3e, r29	; 62
    2a8e:	0f be       	out	0x3f, r0	; 63
    2a90:	cd bf       	out	0x3d, r28	; 61
    2a92:	9c 83       	std	Y+4, r25	; 0x04
    2a94:	8b 83       	std	Y+3, r24	; 0x03
    2a96:	7e 83       	std	Y+6, r23	; 0x06
    2a98:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2a9a:	81 e2       	ldi	r24, 0x21	; 33
    2a9c:	90 e0       	ldi	r25, 0x00	; 0
    2a9e:	0e 94 86 05 	call	0xb0c	; 0xb0c <pvPortMalloc>
    2aa2:	9a 83       	std	Y+2, r25	; 0x02
    2aa4:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2aa6:	89 81       	ldd	r24, Y+1	; 0x01
    2aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aaa:	00 97       	sbiw	r24, 0x00	; 0
    2aac:	69 f1       	breq	.+90     	; 0x2b08 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2aae:	8d 81       	ldd	r24, Y+5	; 0x05
    2ab0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ab2:	00 97       	sbiw	r24, 0x00	; 0
    2ab4:	39 f4       	brne	.+14     	; 0x2ac4 <prvAllocateTCBAndStack+0x46>
    2ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aba:	0e 94 86 05 	call	0xb0c	; 0xb0c <pvPortMalloc>
    2abe:	98 87       	std	Y+8, r25	; 0x08
    2ac0:	8f 83       	std	Y+7, r24	; 0x07
    2ac2:	04 c0       	rjmp	.+8      	; 0x2acc <prvAllocateTCBAndStack+0x4e>
    2ac4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ac6:	9e 81       	ldd	r25, Y+6	; 0x06
    2ac8:	98 87       	std	Y+8, r25	; 0x08
    2aca:	8f 83       	std	Y+7, r24	; 0x07
    2acc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ace:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad0:	8f 81       	ldd	r24, Y+7	; 0x07
    2ad2:	98 85       	ldd	r25, Y+8	; 0x08
    2ad4:	90 8f       	std	Z+24, r25	; 0x18
    2ad6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2ad8:	e9 81       	ldd	r30, Y+1	; 0x01
    2ada:	fa 81       	ldd	r31, Y+2	; 0x02
    2adc:	87 89       	ldd	r24, Z+23	; 0x17
    2ade:	90 8d       	ldd	r25, Z+24	; 0x18
    2ae0:	00 97       	sbiw	r24, 0x00	; 0
    2ae2:	39 f4       	brne	.+14     	; 0x2af2 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2ae4:	89 81       	ldd	r24, Y+1	; 0x01
    2ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae8:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortFree>
			pxNewTCB = NULL;
    2aec:	1a 82       	std	Y+2, r1	; 0x02
    2aee:	19 82       	std	Y+1, r1	; 0x01
    2af0:	0b c0       	rjmp	.+22     	; 0x2b08 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2af2:	e9 81       	ldd	r30, Y+1	; 0x01
    2af4:	fa 81       	ldd	r31, Y+2	; 0x02
    2af6:	87 89       	ldd	r24, Z+23	; 0x17
    2af8:	90 8d       	ldd	r25, Z+24	; 0x18
    2afa:	2b 81       	ldd	r18, Y+3	; 0x03
    2afc:	3c 81       	ldd	r19, Y+4	; 0x04
    2afe:	65 ea       	ldi	r22, 0xA5	; 165
    2b00:	70 e0       	ldi	r23, 0x00	; 0
    2b02:	a9 01       	movw	r20, r18
    2b04:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <memset>
		}
	}

	return pxNewTCB;
    2b08:	89 81       	ldd	r24, Y+1	; 0x01
    2b0a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2b0c:	28 96       	adiw	r28, 0x08	; 8
    2b0e:	0f b6       	in	r0, 0x3f	; 63
    2b10:	f8 94       	cli
    2b12:	de bf       	out	0x3e, r29	; 62
    2b14:	0f be       	out	0x3f, r0	; 63
    2b16:	cd bf       	out	0x3d, r28	; 61
    2b18:	cf 91       	pop	r28
    2b1a:	df 91       	pop	r29
    2b1c:	08 95       	ret

00002b1e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2b1e:	df 93       	push	r29
    2b20:	cf 93       	push	r28
    2b22:	00 d0       	rcall	.+0      	; 0x2b24 <prvDeleteTCB+0x6>
    2b24:	cd b7       	in	r28, 0x3d	; 61
    2b26:	de b7       	in	r29, 0x3e	; 62
    2b28:	9a 83       	std	Y+2, r25	; 0x02
    2b2a:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2b2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b30:	87 89       	ldd	r24, Z+23	; 0x17
    2b32:	90 8d       	ldd	r25, Z+24	; 0x18
    2b34:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortFree>
		vPortFree( pxTCB );
    2b38:	89 81       	ldd	r24, Y+1	; 0x01
    2b3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b3c:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortFree>
	}
    2b40:	0f 90       	pop	r0
    2b42:	0f 90       	pop	r0
    2b44:	cf 91       	pop	r28
    2b46:	df 91       	pop	r29
    2b48:	08 95       	ret

00002b4a <memcpy>:
    2b4a:	fb 01       	movw	r30, r22
    2b4c:	dc 01       	movw	r26, r24
    2b4e:	02 c0       	rjmp	.+4      	; 0x2b54 <memcpy+0xa>
    2b50:	01 90       	ld	r0, Z+
    2b52:	0d 92       	st	X+, r0
    2b54:	41 50       	subi	r20, 0x01	; 1
    2b56:	50 40       	sbci	r21, 0x00	; 0
    2b58:	d8 f7       	brcc	.-10     	; 0x2b50 <memcpy+0x6>
    2b5a:	08 95       	ret

00002b5c <memset>:
    2b5c:	dc 01       	movw	r26, r24
    2b5e:	01 c0       	rjmp	.+2      	; 0x2b62 <memset+0x6>
    2b60:	6d 93       	st	X+, r22
    2b62:	41 50       	subi	r20, 0x01	; 1
    2b64:	50 40       	sbci	r21, 0x00	; 0
    2b66:	e0 f7       	brcc	.-8      	; 0x2b60 <memset+0x4>
    2b68:	08 95       	ret

00002b6a <strncpy>:
    2b6a:	fb 01       	movw	r30, r22
    2b6c:	dc 01       	movw	r26, r24
    2b6e:	41 50       	subi	r20, 0x01	; 1
    2b70:	50 40       	sbci	r21, 0x00	; 0
    2b72:	48 f0       	brcs	.+18     	; 0x2b86 <strncpy+0x1c>
    2b74:	01 90       	ld	r0, Z+
    2b76:	0d 92       	st	X+, r0
    2b78:	00 20       	and	r0, r0
    2b7a:	c9 f7       	brne	.-14     	; 0x2b6e <strncpy+0x4>
    2b7c:	01 c0       	rjmp	.+2      	; 0x2b80 <strncpy+0x16>
    2b7e:	1d 92       	st	X+, r1
    2b80:	41 50       	subi	r20, 0x01	; 1
    2b82:	50 40       	sbci	r21, 0x00	; 0
    2b84:	e0 f7       	brcc	.-8      	; 0x2b7e <strncpy+0x14>
    2b86:	08 95       	ret

00002b88 <_exit>:
    2b88:	f8 94       	cli

00002b8a <__stop_program>:
    2b8a:	ff cf       	rjmp	.-2      	; 0x2b8a <__stop_program>
