In archive libNEWFILE.a:

DIO_prog.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000528  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000467  00000000  00000000  0000055c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.DIO_u8SetPinValue 00000224  00000000  00000000  000009c3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.DIO_u8SetPortValue 0000009c  00000000  00000000  00000be7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.DIO_u8GetPinValue 00000130  00000000  00000000  00000c83  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.DIO_u8AndWithPort 0000009a  00000000  00000000  00000db3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.DIO_u8SetPinValue:

00000000 <DIO_u8SetPinValue>:
//
//	return Local_u8ErrorState;
//}

u8 DIO_u8SetPinValue(u8 Copy_u8port, u8 Copy_u8Pin, u8 Copy_u8Value)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
  1a:	19 82       	std	Y+1, r1	; 0x01

	if(Copy_u8Pin<=DIO_u8PIN7)
  1c:	8b 81       	ldd	r24, Y+3	; 0x03
  1e:	88 30       	cpi	r24, 0x08	; 8
  20:	00 f0       	brcs	.+0      	; 0x22 <DIO_u8SetPinValue+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <DIO_u8SetPinValue+0x24>
	{
		if(Copy_u8Value == DIO_u8PIN_LOW)
  24:	8c 81       	ldd	r24, Y+4	; 0x04
  26:	88 23       	and	r24, r24
  28:	01 f0       	breq	.+0      	; 0x2a <DIO_u8SetPinValue+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <DIO_u8SetPinValue+0x2c>
		{

			switch(Copy_u8port)
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	28 2f       	mov	r18, r24
  30:	30 e0       	ldi	r19, 0x00	; 0
  32:	38 87       	std	Y+8, r19	; 0x08
  34:	2f 83       	std	Y+7, r18	; 0x07
  36:	8f 81       	ldd	r24, Y+7	; 0x07
  38:	98 85       	ldd	r25, Y+8	; 0x08
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	91 05       	cpc	r25, r1
  3e:	01 f0       	breq	.+0      	; 0x40 <DIO_u8SetPinValue+0x40>
  40:	2f 81       	ldd	r18, Y+7	; 0x07
  42:	38 85       	ldd	r19, Y+8	; 0x08
  44:	22 30       	cpi	r18, 0x02	; 2
  46:	31 05       	cpc	r19, r1
  48:	04 f4       	brge	.+0      	; 0x4a <DIO_u8SetPinValue+0x4a>
  4a:	8f 81       	ldd	r24, Y+7	; 0x07
  4c:	98 85       	ldd	r25, Y+8	; 0x08
  4e:	00 97       	sbiw	r24, 0x00	; 0
  50:	01 f0       	breq	.+0      	; 0x52 <DIO_u8SetPinValue+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <DIO_u8SetPinValue+0x54>
  54:	2f 81       	ldd	r18, Y+7	; 0x07
  56:	38 85       	ldd	r19, Y+8	; 0x08
  58:	22 30       	cpi	r18, 0x02	; 2
  5a:	31 05       	cpc	r19, r1
  5c:	01 f0       	breq	.+0      	; 0x5e <DIO_u8SetPinValue+0x5e>
  5e:	8f 81       	ldd	r24, Y+7	; 0x07
  60:	98 85       	ldd	r25, Y+8	; 0x08
  62:	83 30       	cpi	r24, 0x03	; 3
  64:	91 05       	cpc	r25, r1
  66:	01 f4       	brne	.+0      	; 0x68 <DIO_u8SetPinValue+0x68>
  68:	00 c0       	rjmp	.+0      	; 0x6a <DIO_u8SetPinValue+0x6a>
  6a:	00 c0       	rjmp	.+0      	; 0x6c <DIO_u8SetPinValue+0x6c>
			{
			case DIO_u8PORTA: CLR_BIT(PORTA,Copy_u8Pin); break;
  6c:	ab e3       	ldi	r26, 0x3B	; 59
  6e:	b0 e0       	ldi	r27, 0x00	; 0
  70:	eb e3       	ldi	r30, 0x3B	; 59
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	80 81       	ld	r24, Z
  76:	48 2f       	mov	r20, r24
  78:	8b 81       	ldd	r24, Y+3	; 0x03
  7a:	28 2f       	mov	r18, r24
  7c:	30 e0       	ldi	r19, 0x00	; 0
  7e:	81 e0       	ldi	r24, 0x01	; 1
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	02 2e       	mov	r0, r18
  84:	00 c0       	rjmp	.+0      	; 0x86 <DIO_u8SetPinValue+0x86>
  86:	88 0f       	add	r24, r24
  88:	99 1f       	adc	r25, r25
  8a:	0a 94       	dec	r0
  8c:	02 f4       	brpl	.+0      	; 0x8e <DIO_u8SetPinValue+0x8e>
  8e:	80 95       	com	r24
  90:	84 23       	and	r24, r20
  92:	8c 93       	st	X, r24
  94:	00 c0       	rjmp	.+0      	; 0x96 <DIO_u8SetPinValue+0x96>
			case DIO_u8PORTB: CLR_BIT(PORTB,Copy_u8Pin); break;
  96:	a8 e3       	ldi	r26, 0x38	; 56
  98:	b0 e0       	ldi	r27, 0x00	; 0
  9a:	e8 e3       	ldi	r30, 0x38	; 56
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	80 81       	ld	r24, Z
  a0:	48 2f       	mov	r20, r24
  a2:	8b 81       	ldd	r24, Y+3	; 0x03
  a4:	28 2f       	mov	r18, r24
  a6:	30 e0       	ldi	r19, 0x00	; 0
  a8:	81 e0       	ldi	r24, 0x01	; 1
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	02 2e       	mov	r0, r18
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <DIO_u8SetPinValue+0xb0>
  b0:	88 0f       	add	r24, r24
  b2:	99 1f       	adc	r25, r25
  b4:	0a 94       	dec	r0
  b6:	02 f4       	brpl	.+0      	; 0xb8 <DIO_u8SetPinValue+0xb8>
  b8:	80 95       	com	r24
  ba:	84 23       	and	r24, r20
  bc:	8c 93       	st	X, r24
  be:	00 c0       	rjmp	.+0      	; 0xc0 <DIO_u8SetPinValue+0xc0>
			case DIO_u8PORTC: CLR_BIT(PORTC,Copy_u8Pin); break;
  c0:	a5 e3       	ldi	r26, 0x35	; 53
  c2:	b0 e0       	ldi	r27, 0x00	; 0
  c4:	e5 e3       	ldi	r30, 0x35	; 53
  c6:	f0 e0       	ldi	r31, 0x00	; 0
  c8:	80 81       	ld	r24, Z
  ca:	48 2f       	mov	r20, r24
  cc:	8b 81       	ldd	r24, Y+3	; 0x03
  ce:	28 2f       	mov	r18, r24
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	90 e0       	ldi	r25, 0x00	; 0
  d6:	02 2e       	mov	r0, r18
  d8:	00 c0       	rjmp	.+0      	; 0xda <DIO_u8SetPinValue+0xda>
  da:	88 0f       	add	r24, r24
  dc:	99 1f       	adc	r25, r25
  de:	0a 94       	dec	r0
  e0:	02 f4       	brpl	.+0      	; 0xe2 <DIO_u8SetPinValue+0xe2>
  e2:	80 95       	com	r24
  e4:	84 23       	and	r24, r20
  e6:	8c 93       	st	X, r24
  e8:	00 c0       	rjmp	.+0      	; 0xea <DIO_u8SetPinValue+0xea>
			case DIO_u8PORTD: CLR_BIT(PORTD,Copy_u8Pin); break;
  ea:	a2 e3       	ldi	r26, 0x32	; 50
  ec:	b0 e0       	ldi	r27, 0x00	; 0
  ee:	e2 e3       	ldi	r30, 0x32	; 50
  f0:	f0 e0       	ldi	r31, 0x00	; 0
  f2:	80 81       	ld	r24, Z
  f4:	48 2f       	mov	r20, r24
  f6:	8b 81       	ldd	r24, Y+3	; 0x03
  f8:	28 2f       	mov	r18, r24
  fa:	30 e0       	ldi	r19, 0x00	; 0
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	90 e0       	ldi	r25, 0x00	; 0
 100:	02 2e       	mov	r0, r18
 102:	00 c0       	rjmp	.+0      	; 0x104 <DIO_u8SetPinValue+0x104>
 104:	88 0f       	add	r24, r24
 106:	99 1f       	adc	r25, r25
 108:	0a 94       	dec	r0
 10a:	02 f4       	brpl	.+0      	; 0x10c <DIO_u8SetPinValue+0x10c>
 10c:	80 95       	com	r24
 10e:	84 23       	and	r24, r20
 110:	8c 93       	st	X, r24
 112:	00 c0       	rjmp	.+0      	; 0x114 <DIO_u8SetPinValue+0x114>
			default: Local_u8ErrorState =1; break;
 114:	81 e0       	ldi	r24, 0x01	; 1
 116:	89 83       	std	Y+1, r24	; 0x01
 118:	00 c0       	rjmp	.+0      	; 0x11a <DIO_u8SetPinValue+0x11a>

			}
		}
		else if(Copy_u8Value == DIO_u8PIN_HIGH)
 11a:	8c 81       	ldd	r24, Y+4	; 0x04
 11c:	81 30       	cpi	r24, 0x01	; 1
 11e:	01 f0       	breq	.+0      	; 0x120 <DIO_u8SetPinValue+0x120>
 120:	00 c0       	rjmp	.+0      	; 0x122 <DIO_u8SetPinValue+0x122>
		{

			switch(Copy_u8port)
 122:	8a 81       	ldd	r24, Y+2	; 0x02
 124:	28 2f       	mov	r18, r24
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	3e 83       	std	Y+6, r19	; 0x06
 12a:	2d 83       	std	Y+5, r18	; 0x05
 12c:	8d 81       	ldd	r24, Y+5	; 0x05
 12e:	9e 81       	ldd	r25, Y+6	; 0x06
 130:	81 30       	cpi	r24, 0x01	; 1
 132:	91 05       	cpc	r25, r1
 134:	01 f0       	breq	.+0      	; 0x136 <DIO_u8SetPinValue+0x136>
 136:	2d 81       	ldd	r18, Y+5	; 0x05
 138:	3e 81       	ldd	r19, Y+6	; 0x06
 13a:	22 30       	cpi	r18, 0x02	; 2
 13c:	31 05       	cpc	r19, r1
 13e:	04 f4       	brge	.+0      	; 0x140 <DIO_u8SetPinValue+0x140>
 140:	8d 81       	ldd	r24, Y+5	; 0x05
 142:	9e 81       	ldd	r25, Y+6	; 0x06
 144:	00 97       	sbiw	r24, 0x00	; 0
 146:	01 f0       	breq	.+0      	; 0x148 <DIO_u8SetPinValue+0x148>
 148:	00 c0       	rjmp	.+0      	; 0x14a <DIO_u8SetPinValue+0x14a>
 14a:	2d 81       	ldd	r18, Y+5	; 0x05
 14c:	3e 81       	ldd	r19, Y+6	; 0x06
 14e:	22 30       	cpi	r18, 0x02	; 2
 150:	31 05       	cpc	r19, r1
 152:	01 f0       	breq	.+0      	; 0x154 <DIO_u8SetPinValue+0x154>
 154:	8d 81       	ldd	r24, Y+5	; 0x05
 156:	9e 81       	ldd	r25, Y+6	; 0x06
 158:	83 30       	cpi	r24, 0x03	; 3
 15a:	91 05       	cpc	r25, r1
 15c:	01 f0       	breq	.+0      	; 0x15e <DIO_u8SetPinValue+0x15e>
 15e:	00 c0       	rjmp	.+0      	; 0x160 <DIO_u8SetPinValue+0x160>
			{
			case DIO_u8PORTA: SET_BIT(PORTA,Copy_u8Pin); break;
 160:	ab e3       	ldi	r26, 0x3B	; 59
 162:	b0 e0       	ldi	r27, 0x00	; 0
 164:	eb e3       	ldi	r30, 0x3B	; 59
 166:	f0 e0       	ldi	r31, 0x00	; 0
 168:	80 81       	ld	r24, Z
 16a:	48 2f       	mov	r20, r24
 16c:	8b 81       	ldd	r24, Y+3	; 0x03
 16e:	28 2f       	mov	r18, r24
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	81 e0       	ldi	r24, 0x01	; 1
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	02 2e       	mov	r0, r18
 178:	00 c0       	rjmp	.+0      	; 0x17a <DIO_u8SetPinValue+0x17a>
 17a:	88 0f       	add	r24, r24
 17c:	99 1f       	adc	r25, r25
 17e:	0a 94       	dec	r0
 180:	02 f4       	brpl	.+0      	; 0x182 <DIO_u8SetPinValue+0x182>
 182:	84 2b       	or	r24, r20
 184:	8c 93       	st	X, r24
 186:	00 c0       	rjmp	.+0      	; 0x188 <DIO_u8SetPinValue+0x188>
			case DIO_u8PORTB: SET_BIT(PORTB,Copy_u8Pin); break;
 188:	a8 e3       	ldi	r26, 0x38	; 56
 18a:	b0 e0       	ldi	r27, 0x00	; 0
 18c:	e8 e3       	ldi	r30, 0x38	; 56
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	80 81       	ld	r24, Z
 192:	48 2f       	mov	r20, r24
 194:	8b 81       	ldd	r24, Y+3	; 0x03
 196:	28 2f       	mov	r18, r24
 198:	30 e0       	ldi	r19, 0x00	; 0
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	02 2e       	mov	r0, r18
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <DIO_u8SetPinValue+0x1a2>
 1a2:	88 0f       	add	r24, r24
 1a4:	99 1f       	adc	r25, r25
 1a6:	0a 94       	dec	r0
 1a8:	02 f4       	brpl	.+0      	; 0x1aa <DIO_u8SetPinValue+0x1aa>
 1aa:	84 2b       	or	r24, r20
 1ac:	8c 93       	st	X, r24
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <DIO_u8SetPinValue+0x1b0>
			case DIO_u8PORTC: SET_BIT(PORTC,Copy_u8Pin); break;
 1b0:	a5 e3       	ldi	r26, 0x35	; 53
 1b2:	b0 e0       	ldi	r27, 0x00	; 0
 1b4:	e5 e3       	ldi	r30, 0x35	; 53
 1b6:	f0 e0       	ldi	r31, 0x00	; 0
 1b8:	80 81       	ld	r24, Z
 1ba:	48 2f       	mov	r20, r24
 1bc:	8b 81       	ldd	r24, Y+3	; 0x03
 1be:	28 2f       	mov	r18, r24
 1c0:	30 e0       	ldi	r19, 0x00	; 0
 1c2:	81 e0       	ldi	r24, 0x01	; 1
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	02 2e       	mov	r0, r18
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <DIO_u8SetPinValue+0x1ca>
 1ca:	88 0f       	add	r24, r24
 1cc:	99 1f       	adc	r25, r25
 1ce:	0a 94       	dec	r0
 1d0:	02 f4       	brpl	.+0      	; 0x1d2 <DIO_u8SetPinValue+0x1d2>
 1d2:	84 2b       	or	r24, r20
 1d4:	8c 93       	st	X, r24
 1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <DIO_u8SetPinValue+0x1d8>
			case DIO_u8PORTD: SET_BIT(PORTD,Copy_u8Pin); break;
 1d8:	a2 e3       	ldi	r26, 0x32	; 50
 1da:	b0 e0       	ldi	r27, 0x00	; 0
 1dc:	e2 e3       	ldi	r30, 0x32	; 50
 1de:	f0 e0       	ldi	r31, 0x00	; 0
 1e0:	80 81       	ld	r24, Z
 1e2:	48 2f       	mov	r20, r24
 1e4:	8b 81       	ldd	r24, Y+3	; 0x03
 1e6:	28 2f       	mov	r18, r24
 1e8:	30 e0       	ldi	r19, 0x00	; 0
 1ea:	81 e0       	ldi	r24, 0x01	; 1
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	02 2e       	mov	r0, r18
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <DIO_u8SetPinValue+0x1f2>
 1f2:	88 0f       	add	r24, r24
 1f4:	99 1f       	adc	r25, r25
 1f6:	0a 94       	dec	r0
 1f8:	02 f4       	brpl	.+0      	; 0x1fa <DIO_u8SetPinValue+0x1fa>
 1fa:	84 2b       	or	r24, r20
 1fc:	8c 93       	st	X, r24
 1fe:	00 c0       	rjmp	.+0      	; 0x200 <DIO_u8SetPinValue+0x200>
			default: Local_u8ErrorState =1; break;
 200:	81 e0       	ldi	r24, 0x01	; 1
 202:	89 83       	std	Y+1, r24	; 0x01
 204:	00 c0       	rjmp	.+0      	; 0x206 <DIO_u8SetPinValue+0x206>

			}
		}
		else
		{
			Local_u8ErrorState = 1;
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	89 83       	std	Y+1, r24	; 0x01
 20a:	00 c0       	rjmp	.+0      	; 0x20c <DIO_u8SetPinValue+0x20c>
		}

	}
	else
	{
		Local_u8ErrorState = 1;
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8ErrorState;
 210:	89 81       	ldd	r24, Y+1	; 0x01
}
 212:	28 96       	adiw	r28, 0x08	; 8
 214:	0f b6       	in	r0, 0x3f	; 63
 216:	f8 94       	cli
 218:	de bf       	out	0x3e, r29	; 62
 21a:	0f be       	out	0x3f, r0	; 63
 21c:	cd bf       	out	0x3d, r28	; 61
 21e:	cf 91       	pop	r28
 220:	df 91       	pop	r29
 222:	08 95       	ret

Disassembly of section .text.DIO_u8SetPortValue:

00000000 <DIO_u8SetPortValue>:
//
//	return Local_u8ErrorState;
//}

u8 DIO_u8SetPinValue(u8 Copy_u8port, u8 Copy_u8Pin, u8 Copy_u8Value)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_u8SetPortValue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_u8SetPortValue+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	8a 81       	ldd	r24, Y+2	; 0x02
  16:	84 30       	cpi	r24, 0x04	; 4
  18:	00 f4       	brcc	.+0      	; 0x1a <DIO_u8SetPortValue+0x1a>
	u8 Local_u8ErrorState=0;
  1a:	8a 81       	ldd	r24, Y+2	; 0x02

	if(Copy_u8Pin<=DIO_u8PIN7)
  1c:	28 2f       	mov	r18, r24
  1e:	30 e0       	ldi	r19, 0x00	; 0
  20:	3d 83       	std	Y+5, r19	; 0x05
  22:	2c 83       	std	Y+4, r18	; 0x04
	{
		if(Copy_u8Value == DIO_u8PIN_LOW)
  24:	8c 81       	ldd	r24, Y+4	; 0x04
  26:	9d 81       	ldd	r25, Y+5	; 0x05
  28:	81 30       	cpi	r24, 0x01	; 1
  2a:	91 05       	cpc	r25, r1
		{

			switch(Copy_u8port)
  2c:	01 f0       	breq	.+0      	; 0x2e <DIO_u8SetPortValue+0x2e>
  2e:	2c 81       	ldd	r18, Y+4	; 0x04
  30:	3d 81       	ldd	r19, Y+5	; 0x05
  32:	22 30       	cpi	r18, 0x02	; 2
  34:	31 05       	cpc	r19, r1
  36:	04 f4       	brge	.+0      	; 0x38 <DIO_u8SetPortValue+0x38>
  38:	8c 81       	ldd	r24, Y+4	; 0x04
  3a:	9d 81       	ldd	r25, Y+5	; 0x05
  3c:	00 97       	sbiw	r24, 0x00	; 0
  3e:	01 f0       	breq	.+0      	; 0x40 <DIO_u8SetPortValue+0x40>
  40:	00 c0       	rjmp	.+0      	; 0x42 <DIO_u8SetPortValue+0x42>
  42:	2c 81       	ldd	r18, Y+4	; 0x04
  44:	3d 81       	ldd	r19, Y+5	; 0x05
  46:	22 30       	cpi	r18, 0x02	; 2
  48:	31 05       	cpc	r19, r1
  4a:	01 f0       	breq	.+0      	; 0x4c <DIO_u8SetPortValue+0x4c>
  4c:	8c 81       	ldd	r24, Y+4	; 0x04
  4e:	9d 81       	ldd	r25, Y+5	; 0x05
  50:	83 30       	cpi	r24, 0x03	; 3
  52:	91 05       	cpc	r25, r1
  54:	01 f0       	breq	.+0      	; 0x56 <DIO_u8SetPortValue+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <DIO_u8SetPortValue+0x58>
  58:	eb e3       	ldi	r30, 0x3B	; 59
  5a:	f0 e0       	ldi	r31, 0x00	; 0
  5c:	8b 81       	ldd	r24, Y+3	; 0x03
  5e:	80 83       	st	Z, r24
  60:	00 c0       	rjmp	.+0      	; 0x62 <DIO_u8SetPortValue+0x62>
  62:	e8 e3       	ldi	r30, 0x38	; 56
  64:	f0 e0       	ldi	r31, 0x00	; 0
  66:	8b 81       	ldd	r24, Y+3	; 0x03
  68:	80 83       	st	Z, r24
  6a:	00 c0       	rjmp	.+0      	; 0x6c <DIO_u8SetPortValue+0x6c>
			{
			case DIO_u8PORTA: CLR_BIT(PORTA,Copy_u8Pin); break;
  6c:	e5 e3       	ldi	r30, 0x35	; 53
  6e:	f0 e0       	ldi	r31, 0x00	; 0
  70:	8b 81       	ldd	r24, Y+3	; 0x03
  72:	80 83       	st	Z, r24
  74:	00 c0       	rjmp	.+0      	; 0x76 <DIO_u8SetPortValue+0x76>
  76:	e2 e3       	ldi	r30, 0x32	; 50
  78:	f0 e0       	ldi	r31, 0x00	; 0
  7a:	8b 81       	ldd	r24, Y+3	; 0x03
  7c:	80 83       	st	Z, r24
  7e:	00 c0       	rjmp	.+0      	; 0x80 <DIO_u8SetPortValue+0x80>
  80:	81 e0       	ldi	r24, 0x01	; 1
  82:	89 83       	std	Y+1, r24	; 0x01
  84:	00 c0       	rjmp	.+0      	; 0x86 <DIO_u8SetPortValue+0x86>
  86:	81 e0       	ldi	r24, 0x01	; 1
  88:	89 83       	std	Y+1, r24	; 0x01
  8a:	89 81       	ldd	r24, Y+1	; 0x01
  8c:	0f 90       	pop	r0
  8e:	0f 90       	pop	r0
  90:	0f 90       	pop	r0
  92:	0f 90       	pop	r0
  94:	0f 90       	pop	r0
			case DIO_u8PORTB: CLR_BIT(PORTB,Copy_u8Pin); break;
  96:	cf 91       	pop	r28
  98:	df 91       	pop	r29
  9a:	08 95       	ret

Disassembly of section .text.DIO_u8GetPinValue:

00000000 <DIO_u8GetPinValue>:
//
//	return Local_u8ErrorState;
//}

u8 DIO_u8SetPinValue(u8 Copy_u8port, u8 Copy_u8Pin, u8 Copy_u8Value)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	27 97       	sbiw	r28, 0x07	; 7
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	5d 83       	std	Y+5, r21	; 0x05
	u8 Local_u8ErrorState=0;
  1a:	4c 83       	std	Y+4, r20	; 0x04

	if(Copy_u8Pin<=DIO_u8PIN7)
  1c:	19 82       	std	Y+1, r1	; 0x01
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	00 97       	sbiw	r24, 0x00	; 0
	{
		if(Copy_u8Value == DIO_u8PIN_LOW)
  24:	01 f4       	brne	.+0      	; 0x26 <DIO_u8GetPinValue+0x26>
  26:	00 c0       	rjmp	.+0      	; 0x28 <DIO_u8GetPinValue+0x28>
  28:	8b 81       	ldd	r24, Y+3	; 0x03
  2a:	88 30       	cpi	r24, 0x08	; 8
		{

			switch(Copy_u8port)
  2c:	00 f0       	brcs	.+0      	; 0x2e <DIO_u8GetPinValue+0x2e>
  2e:	00 c0       	rjmp	.+0      	; 0x30 <DIO_u8GetPinValue+0x30>
  30:	8a 81       	ldd	r24, Y+2	; 0x02
  32:	28 2f       	mov	r18, r24
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	3f 83       	std	Y+7, r19	; 0x07
  38:	2e 83       	std	Y+6, r18	; 0x06
  3a:	4e 81       	ldd	r20, Y+6	; 0x06
  3c:	5f 81       	ldd	r21, Y+7	; 0x07
  3e:	41 30       	cpi	r20, 0x01	; 1
  40:	51 05       	cpc	r21, r1
  42:	01 f0       	breq	.+0      	; 0x44 <DIO_u8GetPinValue+0x44>
  44:	8e 81       	ldd	r24, Y+6	; 0x06
  46:	9f 81       	ldd	r25, Y+7	; 0x07
  48:	82 30       	cpi	r24, 0x02	; 2
  4a:	91 05       	cpc	r25, r1
  4c:	04 f4       	brge	.+0      	; 0x4e <DIO_u8GetPinValue+0x4e>
  4e:	2e 81       	ldd	r18, Y+6	; 0x06
  50:	3f 81       	ldd	r19, Y+7	; 0x07
  52:	21 15       	cp	r18, r1
  54:	31 05       	cpc	r19, r1
  56:	01 f0       	breq	.+0      	; 0x58 <DIO_u8GetPinValue+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <DIO_u8GetPinValue+0x5a>
  5a:	4e 81       	ldd	r20, Y+6	; 0x06
  5c:	5f 81       	ldd	r21, Y+7	; 0x07
  5e:	42 30       	cpi	r20, 0x02	; 2
  60:	51 05       	cpc	r21, r1
  62:	01 f0       	breq	.+0      	; 0x64 <DIO_u8GetPinValue+0x64>
  64:	8e 81       	ldd	r24, Y+6	; 0x06
  66:	9f 81       	ldd	r25, Y+7	; 0x07
  68:	83 30       	cpi	r24, 0x03	; 3
  6a:	91 05       	cpc	r25, r1
			{
			case DIO_u8PORTA: CLR_BIT(PORTA,Copy_u8Pin); break;
  6c:	01 f4       	brne	.+0      	; 0x6e <DIO_u8GetPinValue+0x6e>
  6e:	00 c0       	rjmp	.+0      	; 0x70 <DIO_u8GetPinValue+0x70>
  70:	00 c0       	rjmp	.+0      	; 0x72 <DIO_u8GetPinValue+0x72>
  72:	e9 e3       	ldi	r30, 0x39	; 57
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	80 81       	ld	r24, Z
  78:	28 2f       	mov	r18, r24
  7a:	30 e0       	ldi	r19, 0x00	; 0
  7c:	8b 81       	ldd	r24, Y+3	; 0x03
  7e:	88 2f       	mov	r24, r24
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	a9 01       	movw	r20, r18
  84:	00 c0       	rjmp	.+0      	; 0x86 <DIO_u8GetPinValue+0x86>
  86:	55 95       	asr	r21
  88:	47 95       	ror	r20
  8a:	8a 95       	dec	r24
  8c:	02 f4       	brpl	.+0      	; 0x8e <DIO_u8GetPinValue+0x8e>
  8e:	ca 01       	movw	r24, r20
  90:	81 70       	andi	r24, 0x01	; 1
  92:	ec 81       	ldd	r30, Y+4	; 0x04
  94:	fd 81       	ldd	r31, Y+5	; 0x05
			case DIO_u8PORTB: CLR_BIT(PORTB,Copy_u8Pin); break;
  96:	80 83       	st	Z, r24
  98:	00 c0       	rjmp	.+0      	; 0x9a <DIO_u8GetPinValue+0x9a>
  9a:	e6 e3       	ldi	r30, 0x36	; 54
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	80 81       	ld	r24, Z
  a0:	28 2f       	mov	r18, r24
  a2:	30 e0       	ldi	r19, 0x00	; 0
  a4:	8b 81       	ldd	r24, Y+3	; 0x03
  a6:	88 2f       	mov	r24, r24
  a8:	90 e0       	ldi	r25, 0x00	; 0
  aa:	a9 01       	movw	r20, r18
  ac:	00 c0       	rjmp	.+0      	; 0xae <DIO_u8GetPinValue+0xae>
  ae:	55 95       	asr	r21
  b0:	47 95       	ror	r20
  b2:	8a 95       	dec	r24
  b4:	02 f4       	brpl	.+0      	; 0xb6 <DIO_u8GetPinValue+0xb6>
  b6:	ca 01       	movw	r24, r20
  b8:	81 70       	andi	r24, 0x01	; 1
  ba:	ec 81       	ldd	r30, Y+4	; 0x04
  bc:	fd 81       	ldd	r31, Y+5	; 0x05
  be:	80 83       	st	Z, r24
			case DIO_u8PORTC: CLR_BIT(PORTC,Copy_u8Pin); break;
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <DIO_u8GetPinValue+0xc2>
  c2:	e3 e3       	ldi	r30, 0x33	; 51
  c4:	f0 e0       	ldi	r31, 0x00	; 0
  c6:	80 81       	ld	r24, Z
  c8:	28 2f       	mov	r18, r24
  ca:	30 e0       	ldi	r19, 0x00	; 0
  cc:	8b 81       	ldd	r24, Y+3	; 0x03
  ce:	88 2f       	mov	r24, r24
  d0:	90 e0       	ldi	r25, 0x00	; 0
  d2:	a9 01       	movw	r20, r18
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <DIO_u8GetPinValue+0xd6>
  d6:	55 95       	asr	r21
  d8:	47 95       	ror	r20
  da:	8a 95       	dec	r24
  dc:	02 f4       	brpl	.+0      	; 0xde <DIO_u8GetPinValue+0xde>
  de:	ca 01       	movw	r24, r20
  e0:	81 70       	andi	r24, 0x01	; 1
  e2:	ec 81       	ldd	r30, Y+4	; 0x04
  e4:	fd 81       	ldd	r31, Y+5	; 0x05
  e6:	80 83       	st	Z, r24
  e8:	00 c0       	rjmp	.+0      	; 0xea <DIO_u8GetPinValue+0xea>
			case DIO_u8PORTD: CLR_BIT(PORTD,Copy_u8Pin); break;
  ea:	e0 e3       	ldi	r30, 0x30	; 48
  ec:	f0 e0       	ldi	r31, 0x00	; 0
  ee:	80 81       	ld	r24, Z
  f0:	28 2f       	mov	r18, r24
  f2:	30 e0       	ldi	r19, 0x00	; 0
  f4:	8b 81       	ldd	r24, Y+3	; 0x03
  f6:	88 2f       	mov	r24, r24
  f8:	90 e0       	ldi	r25, 0x00	; 0
  fa:	a9 01       	movw	r20, r18
  fc:	00 c0       	rjmp	.+0      	; 0xfe <DIO_u8GetPinValue+0xfe>
  fe:	55 95       	asr	r21
 100:	47 95       	ror	r20
 102:	8a 95       	dec	r24
 104:	02 f4       	brpl	.+0      	; 0x106 <DIO_u8GetPinValue+0x106>
 106:	ca 01       	movw	r24, r20
 108:	81 70       	andi	r24, 0x01	; 1
 10a:	ec 81       	ldd	r30, Y+4	; 0x04
 10c:	fd 81       	ldd	r31, Y+5	; 0x05
 10e:	80 83       	st	Z, r24
 110:	00 c0       	rjmp	.+0      	; 0x112 <DIO_u8GetPinValue+0x112>
 112:	81 e0       	ldi	r24, 0x01	; 1
			default: Local_u8ErrorState =1; break;
 114:	89 83       	std	Y+1, r24	; 0x01
 116:	00 c0       	rjmp	.+0      	; 0x118 <DIO_u8GetPinValue+0x118>
 118:	81 e0       	ldi	r24, 0x01	; 1

			}
		}
		else if(Copy_u8Value == DIO_u8PIN_HIGH)
 11a:	89 83       	std	Y+1, r24	; 0x01
 11c:	89 81       	ldd	r24, Y+1	; 0x01
 11e:	27 96       	adiw	r28, 0x07	; 7
 120:	0f b6       	in	r0, 0x3f	; 63
		{

			switch(Copy_u8port)
 122:	f8 94       	cli
 124:	de bf       	out	0x3e, r29	; 62
 126:	0f be       	out	0x3f, r0	; 63
 128:	cd bf       	out	0x3d, r28	; 61
 12a:	cf 91       	pop	r28
 12c:	df 91       	pop	r29
 12e:	08 95       	ret

Disassembly of section .text.DIO_u8AndWithPort:

00000000 <DIO_u8AndWithPort>:
//
//	return Local_u8ErrorState;
//}

u8 DIO_u8SetPinValue(u8 Copy_u8port, u8 Copy_u8Pin, u8 Copy_u8Value)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_u8AndWithPort+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_u8AndWithPort+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	8a 81       	ldd	r24, Y+2	; 0x02
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
	u8 Local_u8ErrorState=0;
  1a:	3d 83       	std	Y+5, r19	; 0x05

	if(Copy_u8Pin<=DIO_u8PIN7)
  1c:	2c 83       	std	Y+4, r18	; 0x04
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	81 30       	cpi	r24, 0x01	; 1
	{
		if(Copy_u8Value == DIO_u8PIN_LOW)
  24:	91 05       	cpc	r25, r1
  26:	01 f0       	breq	.+0      	; 0x28 <DIO_u8AndWithPort+0x28>
  28:	2c 81       	ldd	r18, Y+4	; 0x04
  2a:	3d 81       	ldd	r19, Y+5	; 0x05
		{

			switch(Copy_u8port)
  2c:	22 30       	cpi	r18, 0x02	; 2
  2e:	31 05       	cpc	r19, r1
  30:	04 f4       	brge	.+0      	; 0x32 <DIO_u8AndWithPort+0x32>
  32:	8c 81       	ldd	r24, Y+4	; 0x04
  34:	9d 81       	ldd	r25, Y+5	; 0x05
  36:	00 97       	sbiw	r24, 0x00	; 0
  38:	01 f0       	breq	.+0      	; 0x3a <DIO_u8AndWithPort+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <DIO_u8AndWithPort+0x3c>
  3c:	2c 81       	ldd	r18, Y+4	; 0x04
  3e:	3d 81       	ldd	r19, Y+5	; 0x05
  40:	22 30       	cpi	r18, 0x02	; 2
  42:	31 05       	cpc	r19, r1
  44:	01 f0       	breq	.+0      	; 0x46 <DIO_u8AndWithPort+0x46>
  46:	8c 81       	ldd	r24, Y+4	; 0x04
  48:	9d 81       	ldd	r25, Y+5	; 0x05
  4a:	83 30       	cpi	r24, 0x03	; 3
  4c:	91 05       	cpc	r25, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <DIO_u8AndWithPort+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <DIO_u8AndWithPort+0x52>
  52:	eb e3       	ldi	r30, 0x3B	; 59
  54:	f0 e0       	ldi	r31, 0x00	; 0
  56:	90 81       	ld	r25, Z
  58:	8b 81       	ldd	r24, Y+3	; 0x03
  5a:	89 23       	and	r24, r25
  5c:	89 83       	std	Y+1, r24	; 0x01
  5e:	00 c0       	rjmp	.+0      	; 0x60 <DIO_u8AndWithPort+0x60>
  60:	e8 e3       	ldi	r30, 0x38	; 56
  62:	f0 e0       	ldi	r31, 0x00	; 0
  64:	90 81       	ld	r25, Z
  66:	8b 81       	ldd	r24, Y+3	; 0x03
  68:	89 23       	and	r24, r25
  6a:	89 83       	std	Y+1, r24	; 0x01
			{
			case DIO_u8PORTA: CLR_BIT(PORTA,Copy_u8Pin); break;
  6c:	00 c0       	rjmp	.+0      	; 0x6e <DIO_u8AndWithPort+0x6e>
  6e:	e5 e3       	ldi	r30, 0x35	; 53
  70:	f0 e0       	ldi	r31, 0x00	; 0
  72:	90 81       	ld	r25, Z
  74:	8b 81       	ldd	r24, Y+3	; 0x03
  76:	89 23       	and	r24, r25
  78:	89 83       	std	Y+1, r24	; 0x01
  7a:	00 c0       	rjmp	.+0      	; 0x7c <DIO_u8AndWithPort+0x7c>
  7c:	e2 e3       	ldi	r30, 0x32	; 50
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	90 81       	ld	r25, Z
  82:	8b 81       	ldd	r24, Y+3	; 0x03
  84:	89 23       	and	r24, r25
  86:	89 83       	std	Y+1, r24	; 0x01
  88:	89 81       	ldd	r24, Y+1	; 0x01
  8a:	0f 90       	pop	r0
  8c:	0f 90       	pop	r0
  8e:	0f 90       	pop	r0
  90:	0f 90       	pop	r0
  92:	0f 90       	pop	r0
  94:	cf 91       	pop	r28
			case DIO_u8PORTB: CLR_BIT(PORTB,Copy_u8Pin); break;
  96:	df 91       	pop	r29
  98:	08 95       	ret

PORT_prog.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000001ec  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000002f1  00000000  00000000  00000220  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.PORT_VoidInit 00000042  00000000  00000000  00000511  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text.PORT_VoidInit:

00000000 <PORT_VoidInit>:
#include "PORT_interface.h"
#include "PORT_register.h"


void PORT_VoidInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	DDRA = PORTA_DIR;
   8:	ea e3       	ldi	r30, 0x3A	; 58
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	10 82       	st	Z, r1
	DDRB = PORTB_DIR;
   e:	e7 e3       	ldi	r30, 0x37	; 55
  10:	f0 e0       	ldi	r31, 0x00	; 0
  12:	88 e0       	ldi	r24, 0x08	; 8
  14:	80 83       	st	Z, r24
	DDRC = PORTC_DIR;
  16:	e4 e3       	ldi	r30, 0x34	; 52
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	8f ef       	ldi	r24, 0xFF	; 255
  1c:	80 83       	st	Z, r24
	DDRD = PORTD_DIR;
  1e:	e1 e3       	ldi	r30, 0x31	; 49
  20:	f0 e0       	ldi	r31, 0x00	; 0
  22:	10 82       	st	Z, r1
	
	PORTA = PORTA_INITIAL_VALUE;
  24:	eb e3       	ldi	r30, 0x3B	; 59
  26:	f0 e0       	ldi	r31, 0x00	; 0
  28:	10 82       	st	Z, r1
	PORTB = PORTB_INITIAL_VALUE;
  2a:	e8 e3       	ldi	r30, 0x38	; 56
  2c:	f0 e0       	ldi	r31, 0x00	; 0
  2e:	10 82       	st	Z, r1
	PORTC = PORTC_INITIAL_VALUE;
  30:	e5 e3       	ldi	r30, 0x35	; 53
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	10 82       	st	Z, r1
	PORTD = PORTD_INITIAL_VALUE;
  36:	e2 e3       	ldi	r30, 0x32	; 50
  38:	f0 e0       	ldi	r31, 0x00	; 0
  3a:	10 82       	st	Z, r1


}
  3c:	cf 91       	pop	r28
  3e:	df 91       	pop	r29
  40:	08 95       	ret

croutine.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000b40  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000010d2  00000000  00000000  00000b74  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.pxCurrentCoRoutine 00000002  00000000  00000000  00001c46  2**0
                  ALLOC
  6 .bss.uxTopCoRoutineReadyPriority 00000001  00000000  00000000  00001c46  2**0
                  ALLOC
  7 .bss.xCoRoutineTickCount 00000002  00000000  00000000  00001c46  2**0
                  ALLOC
  8 .bss.xLastTickCount 00000002  00000000  00000000  00001c46  2**0
                  ALLOC
  9 .bss.xPassedTicks 00000002  00000000  00000000  00001c46  2**0
                  ALLOC
 10 .text.xCoRoutineCreate 00000128  00000000  00000000  00001c46  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.vCoRoutineAddToDelayedList 000000c2  00000000  00000000  00001d6e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.prvCheckPendingReadyList 00000094  00000000  00000000  00001e30  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.prvCheckDelayedList 0000015c  00000000  00000000  00001ec4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.vCoRoutineSchedule 000000f4  00000000  00000000  00002020  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.prvInitialiseCoRoutineLists 00000072  00000000  00000000  00002114  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.xCoRoutineRemoveFromEventList 00000070  00000000  00000000  00002186  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .bss.pxReadyCoRoutineLists 00000012  00000000  00000000  000021f6  2**0
                  ALLOC
 18 .bss.xDelayedCoRoutineList1 00000009  00000000  00000000  000021f6  2**0
                  ALLOC
 19 .bss.xDelayedCoRoutineList2 00000009  00000000  00000000  000021f6  2**0
                  ALLOC
 20 .bss.pxDelayedCoRoutineList 00000002  00000000  00000000  000021f6  2**0
                  ALLOC
 21 .bss.pxOverflowDelayedCoRoutineList 00000002  00000000  00000000  000021f6  2**0
                  ALLOC
 22 .bss.xPendingReadyCoRoutineList 00000009  00000000  00000000  000021f6  2**0
                  ALLOC

Disassembly of section .text.xCoRoutineCreate:

00000000 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	27 97       	sbiw	r28, 0x07	; 7
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9d 83       	std	Y+5, r25	; 0x05
  16:	8c 83       	std	Y+4, r24	; 0x04
  18:	6e 83       	std	Y+6, r22	; 0x06
  1a:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
  1c:	8a e1       	ldi	r24, 0x1A	; 26
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	0e 94 00 00 	call	0	; 0x0 <xCoRoutineCreate>
  24:	9a 83       	std	Y+2, r25	; 0x02
  26:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
  28:	89 81       	ldd	r24, Y+1	; 0x01
  2a:	9a 81       	ldd	r25, Y+2	; 0x02
  2c:	00 97       	sbiw	r24, 0x00	; 0
  2e:	01 f4       	brne	.+0      	; 0x30 <xCoRoutineCreate+0x30>
  30:	00 c0       	rjmp	.+0      	; 0x32 <xCoRoutineCreate+0x32>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
  32:	80 91 00 00 	lds	r24, 0x0000
  36:	90 91 00 00 	lds	r25, 0x0000
  3a:	00 97       	sbiw	r24, 0x00	; 0
  3c:	01 f4       	brne	.+0      	; 0x3e <xCoRoutineCreate+0x3e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
  3e:	89 81       	ldd	r24, Y+1	; 0x01
  40:	9a 81       	ldd	r25, Y+2	; 0x02
  42:	90 93 00 00 	sts	0x0000, r25
  46:	80 93 00 00 	sts	0x0000, r24
			prvInitialiseCoRoutineLists();
  4a:	0e 94 00 00 	call	0	; 0x0 <xCoRoutineCreate>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
  4e:	8e 81       	ldd	r24, Y+6	; 0x06
  50:	82 30       	cpi	r24, 0x02	; 2
  52:	00 f0       	brcs	.+0      	; 0x54 <xCoRoutineCreate+0x54>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
  54:	81 e0       	ldi	r24, 0x01	; 1
  56:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
  58:	e9 81       	ldd	r30, Y+1	; 0x01
  5a:	fa 81       	ldd	r31, Y+2	; 0x02
  5c:	11 8e       	std	Z+25, r1	; 0x19
  5e:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
  60:	e9 81       	ldd	r30, Y+1	; 0x01
  62:	fa 81       	ldd	r31, Y+2	; 0x02
  64:	8e 81       	ldd	r24, Y+6	; 0x06
  66:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
  68:	e9 81       	ldd	r30, Y+1	; 0x01
  6a:	fa 81       	ldd	r31, Y+2	; 0x02
  6c:	8f 81       	ldd	r24, Y+7	; 0x07
  6e:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
  70:	e9 81       	ldd	r30, Y+1	; 0x01
  72:	fa 81       	ldd	r31, Y+2	; 0x02
  74:	8c 81       	ldd	r24, Y+4	; 0x04
  76:	9d 81       	ldd	r25, Y+5	; 0x05
  78:	91 83       	std	Z+1, r25	; 0x01
  7a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
  7c:	89 81       	ldd	r24, Y+1	; 0x01
  7e:	9a 81       	ldd	r25, Y+2	; 0x02
  80:	02 96       	adiw	r24, 0x02	; 2
  82:	0e 94 00 00 	call	0	; 0x0 <xCoRoutineCreate>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
  86:	89 81       	ldd	r24, Y+1	; 0x01
  88:	9a 81       	ldd	r25, Y+2	; 0x02
  8a:	0c 96       	adiw	r24, 0x0c	; 12
  8c:	0e 94 00 00 	call	0	; 0x0 <xCoRoutineCreate>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
  90:	e9 81       	ldd	r30, Y+1	; 0x01
  92:	fa 81       	ldd	r31, Y+2	; 0x02
  94:	89 81       	ldd	r24, Y+1	; 0x01
  96:	9a 81       	ldd	r25, Y+2	; 0x02
  98:	91 87       	std	Z+9, r25	; 0x09
  9a:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
  9c:	e9 81       	ldd	r30, Y+1	; 0x01
  9e:	fa 81       	ldd	r31, Y+2	; 0x02
  a0:	89 81       	ldd	r24, Y+1	; 0x01
  a2:	9a 81       	ldd	r25, Y+2	; 0x02
  a4:	93 8b       	std	Z+19, r25	; 0x13
  a6:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  a8:	8e 81       	ldd	r24, Y+6	; 0x06
  aa:	28 2f       	mov	r18, r24
  ac:	30 e0       	ldi	r19, 0x00	; 0
  ae:	85 e0       	ldi	r24, 0x05	; 5
  b0:	90 e0       	ldi	r25, 0x00	; 0
  b2:	82 1b       	sub	r24, r18
  b4:	93 0b       	sbc	r25, r19
  b6:	e9 81       	ldd	r30, Y+1	; 0x01
  b8:	fa 81       	ldd	r31, Y+2	; 0x02
  ba:	95 87       	std	Z+13, r25	; 0x0d
  bc:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
  be:	e9 81       	ldd	r30, Y+1	; 0x01
  c0:	fa 81       	ldd	r31, Y+2	; 0x02
  c2:	96 89       	ldd	r25, Z+22	; 0x16
  c4:	80 91 00 00 	lds	r24, 0x0000
  c8:	89 17       	cp	r24, r25
  ca:	00 f4       	brcc	.+0      	; 0xcc <xCoRoutineCreate+0xcc>
  cc:	e9 81       	ldd	r30, Y+1	; 0x01
  ce:	fa 81       	ldd	r31, Y+2	; 0x02
  d0:	86 89       	ldd	r24, Z+22	; 0x16
  d2:	80 93 00 00 	sts	0x0000, r24
  d6:	e9 81       	ldd	r30, Y+1	; 0x01
  d8:	fa 81       	ldd	r31, Y+2	; 0x02
  da:	86 89       	ldd	r24, Z+22	; 0x16
  dc:	28 2f       	mov	r18, r24
  de:	30 e0       	ldi	r19, 0x00	; 0
  e0:	c9 01       	movw	r24, r18
  e2:	88 0f       	add	r24, r24
  e4:	99 1f       	adc	r25, r25
  e6:	88 0f       	add	r24, r24
  e8:	99 1f       	adc	r25, r25
  ea:	88 0f       	add	r24, r24
  ec:	99 1f       	adc	r25, r25
  ee:	82 0f       	add	r24, r18
  f0:	93 1f       	adc	r25, r19
  f2:	ac 01       	movw	r20, r24
  f4:	40 50       	subi	r20, 0x00	; 0
  f6:	50 40       	sbci	r21, 0x00	; 0
  f8:	89 81       	ldd	r24, Y+1	; 0x01
  fa:	9a 81       	ldd	r25, Y+2	; 0x02
  fc:	9c 01       	movw	r18, r24
  fe:	2e 5f       	subi	r18, 0xFE	; 254
 100:	3f 4f       	sbci	r19, 0xFF	; 255
 102:	ca 01       	movw	r24, r20
 104:	b9 01       	movw	r22, r18
 106:	0e 94 00 00 	call	0	; 0x0 <xCoRoutineCreate>

		xReturn = pdPASS;
 10a:	81 e0       	ldi	r24, 0x01	; 1
 10c:	8b 83       	std	Y+3, r24	; 0x03
 10e:	00 c0       	rjmp	.+0      	; 0x110 <xCoRoutineCreate+0x110>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 110:	8f ef       	ldi	r24, 0xFF	; 255
 112:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
 114:	8b 81       	ldd	r24, Y+3	; 0x03
}
 116:	27 96       	adiw	r28, 0x07	; 7
 118:	0f b6       	in	r0, 0x3f	; 63
 11a:	f8 94       	cli
 11c:	de bf       	out	0x3e, r29	; 62
 11e:	0f be       	out	0x3f, r0	; 63
 120:	cd bf       	out	0x3d, r28	; 61
 122:	cf 91       	pop	r28
 124:	df 91       	pop	r29
 126:	08 95       	ret

Disassembly of section .text.vCoRoutineAddToDelayedList:

00000000 <vCoRoutineAddToDelayedList>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vCoRoutineAddToDelayedList+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <vCoRoutineAddToDelayedList+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <vCoRoutineAddToDelayedList+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	9c 83       	std	Y+4, r25	; 0x04
  10:	8b 83       	std	Y+3, r24	; 0x03
  12:	7e 83       	std	Y+6, r23	; 0x06
  14:	6d 83       	std	Y+5, r22	; 0x05
  16:	20 91 00 00 	lds	r18, 0x0000
  1a:	30 91 00 00 	lds	r19, 0x0000
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
  1e:	8b 81       	ldd	r24, Y+3	; 0x03
  20:	9c 81       	ldd	r25, Y+4	; 0x04
  22:	82 0f       	add	r24, r18
  24:	93 1f       	adc	r25, r19
  26:	9a 83       	std	Y+2, r25	; 0x02
	if( pxCoRoutine )
  28:	89 83       	std	Y+1, r24	; 0x01
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
  32:	02 96       	adiw	r24, 0x02	; 2
  34:	0e 94 00 00 	call	0	; 0x0 <vCoRoutineAddToDelayedList>
  38:	e0 91 00 00 	lds	r30, 0x0000
  3c:	f0 91 00 00 	lds	r31, 0x0000
		{
			pxCurrentCoRoutine = pxCoRoutine;
  40:	89 81       	ldd	r24, Y+1	; 0x01
  42:	9a 81       	ldd	r25, Y+2	; 0x02
  44:	93 83       	std	Z+3, r25	; 0x03
  46:	82 83       	std	Z+2, r24	; 0x02
  48:	20 91 00 00 	lds	r18, 0x0000
			prvInitialiseCoRoutineLists();
  4c:	30 91 00 00 	lds	r19, 0x0000
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
  50:	89 81       	ldd	r24, Y+1	; 0x01
  52:	9a 81       	ldd	r25, Y+2	; 0x02
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
  54:	82 17       	cp	r24, r18
  56:	93 07       	cpc	r25, r19
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
  58:	00 f4       	brcc	.+0      	; 0x5a <vCoRoutineAddToDelayedList+0x5a>
  5a:	80 91 00 00 	lds	r24, 0x0000
  5e:	90 91 00 00 	lds	r25, 0x0000
		pxCoRoutine->uxPriority = uxPriority;
  62:	20 91 00 00 	lds	r18, 0x0000
  66:	30 91 00 00 	lds	r19, 0x0000
		pxCoRoutine->uxIndex = uxIndex;
  6a:	2e 5f       	subi	r18, 0xFE	; 254
  6c:	3f 4f       	sbci	r19, 0xFF	; 255
  6e:	b9 01       	movw	r22, r18
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
  70:	0e 94 00 00 	call	0	; 0x0 <vCoRoutineAddToDelayedList>
  74:	00 c0       	rjmp	.+0      	; 0x76 <vCoRoutineAddToDelayedList+0x76>
  76:	80 91 00 00 	lds	r24, 0x0000
  7a:	90 91 00 00 	lds	r25, 0x0000

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
  7e:	20 91 00 00 	lds	r18, 0x0000
  82:	30 91 00 00 	lds	r19, 0x0000
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
  86:	2e 5f       	subi	r18, 0xFE	; 254
  88:	3f 4f       	sbci	r19, 0xFF	; 255
  8a:	b9 01       	movw	r22, r18
  8c:	0e 94 00 00 	call	0	; 0x0 <vCoRoutineAddToDelayedList>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
  90:	8d 81       	ldd	r24, Y+5	; 0x05
  92:	9e 81       	ldd	r25, Y+6	; 0x06
  94:	00 97       	sbiw	r24, 0x00	; 0
  96:	01 f0       	breq	.+0      	; 0x98 <vCoRoutineAddToDelayedList+0x98>
  98:	80 91 00 00 	lds	r24, 0x0000
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
  9c:	90 91 00 00 	lds	r25, 0x0000
  a0:	9c 01       	movw	r18, r24
  a2:	24 5f       	subi	r18, 0xF4	; 244
  a4:	3f 4f       	sbci	r19, 0xFF	; 255
  a6:	8d 81       	ldd	r24, Y+5	; 0x05
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  a8:	9e 81       	ldd	r25, Y+6	; 0x06
  aa:	b9 01       	movw	r22, r18
  ac:	0e 94 00 00 	call	0	; 0x0 <vCoRoutineAddToDelayedList>
  b0:	26 96       	adiw	r28, 0x06	; 6
  b2:	0f b6       	in	r0, 0x3f	; 63
  b4:	f8 94       	cli
  b6:	de bf       	out	0x3e, r29	; 62
  b8:	0f be       	out	0x3f, r0	; 63
  ba:	cd bf       	out	0x3d, r28	; 61
  bc:	cf 91       	pop	r28
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
  be:	df 91       	pop	r29
  c0:	08 95       	ret

Disassembly of section .text.prvCheckPendingReadyList:

00000000 <prvCheckPendingReadyList>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvCheckPendingReadyList+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	00 c0       	rjmp	.+0      	; 0xc <prvCheckPendingReadyList+0xc>
   c:	f8 94       	cli
   e:	e0 91 00 00 	lds	r30, 0x0000
  12:	f0 91 00 00 	lds	r31, 0x0000
  16:	86 81       	ldd	r24, Z+6	; 0x06
  18:	97 81       	ldd	r25, Z+7	; 0x07
  1a:	9a 83       	std	Y+2, r25	; 0x02
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	89 81       	ldd	r24, Y+1	; 0x01
  20:	9a 81       	ldd	r25, Y+2	; 0x02
  22:	0c 96       	adiw	r24, 0x0c	; 12
  24:	0e 94 00 00 	call	0	; 0x0 <prvCheckPendingReadyList>
	if( pxCoRoutine )
  28:	78 94       	sei
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	9a 81       	ldd	r25, Y+2	; 0x02
  2e:	02 96       	adiw	r24, 0x02	; 2
  30:	0e 94 00 00 	call	0	; 0x0 <prvCheckPendingReadyList>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
  34:	e9 81       	ldd	r30, Y+1	; 0x01
  36:	fa 81       	ldd	r31, Y+2	; 0x02
  38:	96 89       	ldd	r25, Z+22	; 0x16
  3a:	80 91 00 00 	lds	r24, 0x0000
		{
			pxCurrentCoRoutine = pxCoRoutine;
  3e:	89 17       	cp	r24, r25
  40:	00 f4       	brcc	.+0      	; 0x42 <prvCheckPendingReadyList+0x42>
  42:	e9 81       	ldd	r30, Y+1	; 0x01
  44:	fa 81       	ldd	r31, Y+2	; 0x02
  46:	86 89       	ldd	r24, Z+22	; 0x16
  48:	80 93 00 00 	sts	0x0000, r24
			prvInitialiseCoRoutineLists();
  4c:	e9 81       	ldd	r30, Y+1	; 0x01
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
  4e:	fa 81       	ldd	r31, Y+2	; 0x02
  50:	86 89       	ldd	r24, Z+22	; 0x16
  52:	28 2f       	mov	r18, r24
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
  54:	30 e0       	ldi	r19, 0x00	; 0
  56:	c9 01       	movw	r24, r18
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
  58:	88 0f       	add	r24, r24
  5a:	99 1f       	adc	r25, r25
  5c:	88 0f       	add	r24, r24
  5e:	99 1f       	adc	r25, r25
		pxCoRoutine->uxPriority = uxPriority;
  60:	88 0f       	add	r24, r24
  62:	99 1f       	adc	r25, r25
  64:	82 0f       	add	r24, r18
  66:	93 1f       	adc	r25, r19
		pxCoRoutine->uxIndex = uxIndex;
  68:	ac 01       	movw	r20, r24
  6a:	40 50       	subi	r20, 0x00	; 0
  6c:	50 40       	sbci	r21, 0x00	; 0
  6e:	89 81       	ldd	r24, Y+1	; 0x01
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
  70:	9a 81       	ldd	r25, Y+2	; 0x02
  72:	9c 01       	movw	r18, r24
  74:	2e 5f       	subi	r18, 0xFE	; 254
  76:	3f 4f       	sbci	r19, 0xFF	; 255
  78:	ca 01       	movw	r24, r20
  7a:	b9 01       	movw	r22, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
  7c:	0e 94 00 00 	call	0	; 0x0 <prvCheckPendingReadyList>
  80:	80 91 00 00 	lds	r24, 0x0000
  84:	88 23       	and	r24, r24
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
  86:	01 f0       	breq	.+0      	; 0x88 <prvCheckPendingReadyList+0x88>
  88:	00 c0       	rjmp	.+0      	; 0x8a <prvCheckPendingReadyList+0x8a>
  8a:	0f 90       	pop	r0
  8c:	0f 90       	pop	r0
  8e:	cf 91       	pop	r28

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
  90:	df 91       	pop	r29
  92:	08 95       	ret

Disassembly of section .text.prvCheckDelayedList:

00000000 <prvCheckDelayedList>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvCheckDelayedList+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <prvCheckDelayedList+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	0e 94 00 00 	call	0	; 0x0 <prvCheckDelayedList>
  10:	20 91 00 00 	lds	r18, 0x0000
  14:	30 91 00 00 	lds	r19, 0x0000
  18:	82 1b       	sub	r24, r18
  1a:	93 0b       	sbc	r25, r19
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
  1c:	90 93 00 00 	sts	0x0000, r25
  20:	80 93 00 00 	sts	0x0000, r24
  24:	00 c0       	rjmp	.+0      	; 0x26 <prvCheckDelayedList+0x26>
  26:	80 91 00 00 	lds	r24, 0x0000
	if( pxCoRoutine )
  2a:	90 91 00 00 	lds	r25, 0x0000
  2e:	01 96       	adiw	r24, 0x01	; 1
  30:	90 93 00 00 	sts	0x0000, r25
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
  34:	80 93 00 00 	sts	0x0000, r24
  38:	80 91 00 00 	lds	r24, 0x0000
  3c:	90 91 00 00 	lds	r25, 0x0000
		{
			pxCurrentCoRoutine = pxCoRoutine;
  40:	01 97       	sbiw	r24, 0x01	; 1
  42:	90 93 00 00 	sts	0x0000, r25
  46:	80 93 00 00 	sts	0x0000, r24
			prvInitialiseCoRoutineLists();
  4a:	80 91 00 00 	lds	r24, 0x0000
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
  4e:	90 91 00 00 	lds	r25, 0x0000
  52:	00 97       	sbiw	r24, 0x00	; 0
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
  54:	01 f0       	breq	.+0      	; 0x56 <prvCheckDelayedList+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <prvCheckDelayedList+0x58>
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
  58:	80 91 00 00 	lds	r24, 0x0000
  5c:	90 91 00 00 	lds	r25, 0x0000
		pxCoRoutine->uxPriority = uxPriority;
  60:	9a 83       	std	Y+2, r25	; 0x02
  62:	89 83       	std	Y+1, r24	; 0x01
  64:	80 91 00 00 	lds	r24, 0x0000
		pxCoRoutine->uxIndex = uxIndex;
  68:	90 91 00 00 	lds	r25, 0x0000
  6c:	90 93 00 00 	sts	0x0000, r25
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
  70:	80 93 00 00 	sts	0x0000, r24
  74:	89 81       	ldd	r24, Y+1	; 0x01
  76:	9a 81       	ldd	r25, Y+2	; 0x02
  78:	90 93 00 00 	sts	0x0000, r25

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
  7c:	80 93 00 00 	sts	0x0000, r24
  80:	00 c0       	rjmp	.+0      	; 0x82 <prvCheckDelayedList+0x82>
  82:	e0 91 00 00 	lds	r30, 0x0000
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
  86:	f0 91 00 00 	lds	r31, 0x0000
  8a:	05 80       	ldd	r0, Z+5	; 0x05
  8c:	f6 81       	ldd	r31, Z+6	; 0x06
  8e:	e0 2d       	mov	r30, r0

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
  90:	86 81       	ldd	r24, Z+6	; 0x06
  92:	97 81       	ldd	r25, Z+7	; 0x07
  94:	9c 83       	std	Y+4, r25	; 0x04
  96:	8b 83       	std	Y+3, r24	; 0x03
  98:	eb 81       	ldd	r30, Y+3	; 0x03
  9a:	fc 81       	ldd	r31, Y+4	; 0x04
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
  9c:	22 81       	ldd	r18, Z+2	; 0x02
  9e:	33 81       	ldd	r19, Z+3	; 0x03
  a0:	80 91 00 00 	lds	r24, 0x0000
  a4:	90 91 00 00 	lds	r25, 0x0000
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  a8:	82 17       	cp	r24, r18
  aa:	93 07       	cpc	r25, r19
  ac:	00 f4       	brcc	.+0      	; 0xae <prvCheckDelayedList+0xae>
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <prvCheckDelayedList+0xb0>
  b0:	f8 94       	cli
  b2:	8b 81       	ldd	r24, Y+3	; 0x03
  b4:	9c 81       	ldd	r25, Y+4	; 0x04
  b6:	02 96       	adiw	r24, 0x02	; 2
  b8:	0e 94 00 00 	call	0	; 0x0 <prvCheckDelayedList>
  bc:	eb 81       	ldd	r30, Y+3	; 0x03
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
  be:	fc 81       	ldd	r31, Y+4	; 0x04
  c0:	84 89       	ldd	r24, Z+20	; 0x14
  c2:	95 89       	ldd	r25, Z+21	; 0x15
  c4:	00 97       	sbiw	r24, 0x00	; 0
  c6:	01 f0       	breq	.+0      	; 0xc8 <prvCheckDelayedList+0xc8>
  c8:	8b 81       	ldd	r24, Y+3	; 0x03
  ca:	9c 81       	ldd	r25, Y+4	; 0x04
  cc:	0c 96       	adiw	r24, 0x0c	; 12
  ce:	0e 94 00 00 	call	0	; 0x0 <prvCheckDelayedList>
  d2:	78 94       	sei
  d4:	eb 81       	ldd	r30, Y+3	; 0x03
  d6:	fc 81       	ldd	r31, Y+4	; 0x04
  d8:	96 89       	ldd	r25, Z+22	; 0x16
  da:	80 91 00 00 	lds	r24, 0x0000
  de:	89 17       	cp	r24, r25
  e0:	00 f4       	brcc	.+0      	; 0xe2 <prvCheckDelayedList+0xe2>
  e2:	eb 81       	ldd	r30, Y+3	; 0x03
  e4:	fc 81       	ldd	r31, Y+4	; 0x04
  e6:	86 89       	ldd	r24, Z+22	; 0x16
  e8:	80 93 00 00 	sts	0x0000, r24
  ec:	eb 81       	ldd	r30, Y+3	; 0x03
  ee:	fc 81       	ldd	r31, Y+4	; 0x04
  f0:	86 89       	ldd	r24, Z+22	; 0x16
  f2:	28 2f       	mov	r18, r24
  f4:	30 e0       	ldi	r19, 0x00	; 0
  f6:	c9 01       	movw	r24, r18
  f8:	88 0f       	add	r24, r24
  fa:	99 1f       	adc	r25, r25
  fc:	88 0f       	add	r24, r24
  fe:	99 1f       	adc	r25, r25
 100:	88 0f       	add	r24, r24
 102:	99 1f       	adc	r25, r25
 104:	82 0f       	add	r24, r18
 106:	93 1f       	adc	r25, r19
 108:	ac 01       	movw	r20, r24

		xReturn = pdPASS;
 10a:	40 50       	subi	r20, 0x00	; 0
 10c:	50 40       	sbci	r21, 0x00	; 0
 10e:	8b 81       	ldd	r24, Y+3	; 0x03
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 110:	9c 81       	ldd	r25, Y+4	; 0x04
 112:	9c 01       	movw	r18, r24
	}
	
	return xReturn;	
 114:	2e 5f       	subi	r18, 0xFE	; 254
}
 116:	3f 4f       	sbci	r19, 0xFF	; 255
 118:	ca 01       	movw	r24, r20
 11a:	b9 01       	movw	r22, r18
 11c:	0e 94 00 00 	call	0	; 0x0 <prvCheckDelayedList>
 120:	e0 91 00 00 	lds	r30, 0x0000
 124:	f0 91 00 00 	lds	r31, 0x0000
 128:	80 81       	ld	r24, Z
 12a:	88 23       	and	r24, r24
 12c:	01 f0       	breq	.+0      	; 0x12e <prvCheckDelayedList+0x12e>
 12e:	00 c0       	rjmp	.+0      	; 0x130 <prvCheckDelayedList+0x130>
 130:	80 91 00 00 	lds	r24, 0x0000
 134:	90 91 00 00 	lds	r25, 0x0000
 138:	00 97       	sbiw	r24, 0x00	; 0
 13a:	01 f0       	breq	.+0      	; 0x13c <prvCheckDelayedList+0x13c>
 13c:	00 c0       	rjmp	.+0      	; 0x13e <prvCheckDelayedList+0x13e>
 13e:	80 91 00 00 	lds	r24, 0x0000
 142:	90 91 00 00 	lds	r25, 0x0000
 146:	90 93 00 00 	sts	0x0000, r25
 14a:	80 93 00 00 	sts	0x0000, r24
 14e:	0f 90       	pop	r0
 150:	0f 90       	pop	r0
 152:	0f 90       	pop	r0
 154:	0f 90       	pop	r0
 156:	cf 91       	pop	r28
 158:	df 91       	pop	r29
 15a:	08 95       	ret

Disassembly of section .text.vCoRoutineSchedule:

00000000 <vCoRoutineSchedule>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vCoRoutineSchedule+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	0e 94 00 00 	call	0	; 0x0 <vCoRoutineSchedule>
   e:	0e 94 00 00 	call	0	; 0x0 <vCoRoutineSchedule>
  12:	00 c0       	rjmp	.+0      	; 0x14 <vCoRoutineSchedule+0x14>
  14:	80 91 00 00 	lds	r24, 0x0000
  18:	88 23       	and	r24, r24
  1a:	01 f4       	brne	.+0      	; 0x1c <vCoRoutineSchedule+0x1c>
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
  1c:	00 c0       	rjmp	.+0      	; 0x1e <vCoRoutineSchedule+0x1e>
  1e:	80 91 00 00 	lds	r24, 0x0000
  22:	81 50       	subi	r24, 0x01	; 1
  24:	80 93 00 00 	sts	0x0000, r24
	if( pxCoRoutine )
  28:	80 91 00 00 	lds	r24, 0x0000
  2c:	28 2f       	mov	r18, r24
  2e:	30 e0       	ldi	r19, 0x00	; 0
  30:	c9 01       	movw	r24, r18
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
  32:	88 0f       	add	r24, r24
  34:	99 1f       	adc	r25, r25
  36:	88 0f       	add	r24, r24
  38:	99 1f       	adc	r25, r25
  3a:	88 0f       	add	r24, r24
  3c:	99 1f       	adc	r25, r25
		{
			pxCurrentCoRoutine = pxCoRoutine;
  3e:	82 0f       	add	r24, r18
  40:	93 1f       	adc	r25, r19
  42:	fc 01       	movw	r30, r24
  44:	e0 50       	subi	r30, 0x00	; 0
  46:	f0 40       	sbci	r31, 0x00	; 0
  48:	80 81       	ld	r24, Z
			prvInitialiseCoRoutineLists();
  4a:	88 23       	and	r24, r24
  4c:	01 f0       	breq	.+0      	; 0x4e <vCoRoutineSchedule+0x4e>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
  4e:	80 91 00 00 	lds	r24, 0x0000
  52:	28 2f       	mov	r18, r24
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
  54:	30 e0       	ldi	r19, 0x00	; 0
  56:	c9 01       	movw	r24, r18
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
  58:	88 0f       	add	r24, r24
  5a:	99 1f       	adc	r25, r25
  5c:	88 0f       	add	r24, r24
  5e:	99 1f       	adc	r25, r25
		pxCoRoutine->uxPriority = uxPriority;
  60:	88 0f       	add	r24, r24
  62:	99 1f       	adc	r25, r25
  64:	82 0f       	add	r24, r18
  66:	93 1f       	adc	r25, r19
		pxCoRoutine->uxIndex = uxIndex;
  68:	80 50       	subi	r24, 0x00	; 0
  6a:	90 40       	sbci	r25, 0x00	; 0
  6c:	9a 83       	std	Y+2, r25	; 0x02
  6e:	89 83       	std	Y+1, r24	; 0x01
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
  70:	e9 81       	ldd	r30, Y+1	; 0x01
  72:	fa 81       	ldd	r31, Y+2	; 0x02
  74:	01 80       	ldd	r0, Z+1	; 0x01
  76:	f2 81       	ldd	r31, Z+2	; 0x02
  78:	e0 2d       	mov	r30, r0
  7a:	82 81       	ldd	r24, Z+2	; 0x02

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
  7c:	93 81       	ldd	r25, Z+3	; 0x03
  7e:	e9 81       	ldd	r30, Y+1	; 0x01
  80:	fa 81       	ldd	r31, Y+2	; 0x02
  82:	92 83       	std	Z+2, r25	; 0x02
  84:	81 83       	std	Z+1, r24	; 0x01
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
  86:	e9 81       	ldd	r30, Y+1	; 0x01
  88:	fa 81       	ldd	r31, Y+2	; 0x02
  8a:	21 81       	ldd	r18, Z+1	; 0x01
  8c:	32 81       	ldd	r19, Z+2	; 0x02
  8e:	89 81       	ldd	r24, Y+1	; 0x01

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
  90:	9a 81       	ldd	r25, Y+2	; 0x02
  92:	03 96       	adiw	r24, 0x03	; 3
  94:	28 17       	cp	r18, r24
  96:	39 07       	cpc	r19, r25
  98:	01 f4       	brne	.+0      	; 0x9a <vCoRoutineSchedule+0x9a>
  9a:	e9 81       	ldd	r30, Y+1	; 0x01
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
  9c:	fa 81       	ldd	r31, Y+2	; 0x02
  9e:	01 80       	ldd	r0, Z+1	; 0x01
  a0:	f2 81       	ldd	r31, Z+2	; 0x02
  a2:	e0 2d       	mov	r30, r0
  a4:	82 81       	ldd	r24, Z+2	; 0x02
  a6:	93 81       	ldd	r25, Z+3	; 0x03
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  a8:	e9 81       	ldd	r30, Y+1	; 0x01
  aa:	fa 81       	ldd	r31, Y+2	; 0x02
  ac:	92 83       	std	Z+2, r25	; 0x02
  ae:	81 83       	std	Z+1, r24	; 0x01
  b0:	e9 81       	ldd	r30, Y+1	; 0x01
  b2:	fa 81       	ldd	r31, Y+2	; 0x02
  b4:	01 80       	ldd	r0, Z+1	; 0x01
  b6:	f2 81       	ldd	r31, Z+2	; 0x02
  b8:	e0 2d       	mov	r30, r0
  ba:	86 81       	ldd	r24, Z+6	; 0x06
  bc:	97 81       	ldd	r25, Z+7	; 0x07
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
  be:	90 93 00 00 	sts	0x0000, r25
  c2:	80 93 00 00 	sts	0x0000, r24
  c6:	e0 91 00 00 	lds	r30, 0x0000
  ca:	f0 91 00 00 	lds	r31, 0x0000
  ce:	40 81       	ld	r20, Z
  d0:	51 81       	ldd	r21, Z+1	; 0x01
  d2:	80 91 00 00 	lds	r24, 0x0000
  d6:	90 91 00 00 	lds	r25, 0x0000
  da:	e0 91 00 00 	lds	r30, 0x0000
  de:	f0 91 00 00 	lds	r31, 0x0000
  e2:	27 89       	ldd	r18, Z+23	; 0x17
  e4:	62 2f       	mov	r22, r18
  e6:	fa 01       	movw	r30, r20
  e8:	09 95       	icall
  ea:	0f 90       	pop	r0
  ec:	0f 90       	pop	r0
  ee:	cf 91       	pop	r28
  f0:	df 91       	pop	r29
  f2:	08 95       	ret

Disassembly of section .text.prvInitialiseCoRoutineLists:

00000000 <prvInitialiseCoRoutineLists>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	19 82       	std	Y+1, r1	; 0x01
   c:	00 c0       	rjmp	.+0      	; 0xe <prvInitialiseCoRoutineLists+0xe>
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	c9 01       	movw	r24, r18
  16:	88 0f       	add	r24, r24
  18:	99 1f       	adc	r25, r25
  1a:	88 0f       	add	r24, r24
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
  1c:	99 1f       	adc	r25, r25
  1e:	88 0f       	add	r24, r24
  20:	99 1f       	adc	r25, r25
  22:	82 0f       	add	r24, r18
  24:	93 1f       	adc	r25, r19
  26:	80 50       	subi	r24, 0x00	; 0
	if( pxCoRoutine )
  28:	90 40       	sbci	r25, 0x00	; 0
  2a:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseCoRoutineLists>
  2e:	89 81       	ldd	r24, Y+1	; 0x01
  30:	8f 5f       	subi	r24, 0xFF	; 255
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
  32:	89 83       	std	Y+1, r24	; 0x01
  34:	89 81       	ldd	r24, Y+1	; 0x01
  36:	82 30       	cpi	r24, 0x02	; 2
  38:	00 f0       	brcs	.+0      	; 0x3a <prvInitialiseCoRoutineLists+0x3a>
  3a:	80 e0       	ldi	r24, 0x00	; 0
  3c:	90 e0       	ldi	r25, 0x00	; 0
		{
			pxCurrentCoRoutine = pxCoRoutine;
  3e:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseCoRoutineLists>
  42:	80 e0       	ldi	r24, 0x00	; 0
  44:	90 e0       	ldi	r25, 0x00	; 0
  46:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseCoRoutineLists>
			prvInitialiseCoRoutineLists();
  4a:	80 e0       	ldi	r24, 0x00	; 0
  4c:	90 e0       	ldi	r25, 0x00	; 0
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
  4e:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseCoRoutineLists>
  52:	80 e0       	ldi	r24, 0x00	; 0
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
  54:	90 e0       	ldi	r25, 0x00	; 0
  56:	90 93 00 00 	sts	0x0000, r25
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
  5a:	80 93 00 00 	sts	0x0000, r24
  5e:	80 e0       	ldi	r24, 0x00	; 0
		pxCoRoutine->uxPriority = uxPriority;
  60:	90 e0       	ldi	r25, 0x00	; 0
  62:	90 93 00 00 	sts	0x0000, r25
  66:	80 93 00 00 	sts	0x0000, r24
		pxCoRoutine->uxIndex = uxIndex;
  6a:	0f 90       	pop	r0
  6c:	cf 91       	pop	r28
  6e:	df 91       	pop	r29
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
  70:	08 95       	ret

Disassembly of section .text.xCoRoutineRemoveFromEventList:

00000000 <xCoRoutineRemoveFromEventList>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <xCoRoutineRemoveFromEventList+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <xCoRoutineRemoveFromEventList+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	9d 83       	std	Y+5, r25	; 0x05
  10:	8c 83       	std	Y+4, r24	; 0x04
  12:	ec 81       	ldd	r30, Y+4	; 0x04
  14:	fd 81       	ldd	r31, Y+5	; 0x05
  16:	05 80       	ldd	r0, Z+5	; 0x05
  18:	f6 81       	ldd	r31, Z+6	; 0x06
  1a:	e0 2d       	mov	r30, r0
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
  1c:	86 81       	ldd	r24, Z+6	; 0x06
  1e:	97 81       	ldd	r25, Z+7	; 0x07
  20:	9b 83       	std	Y+3, r25	; 0x03
  22:	8a 83       	std	Y+2, r24	; 0x02
  24:	8a 81       	ldd	r24, Y+2	; 0x02
  26:	9b 81       	ldd	r25, Y+3	; 0x03
	if( pxCoRoutine )
  28:	0c 96       	adiw	r24, 0x0c	; 12
  2a:	0e 94 00 00 	call	0	; 0x0 <xCoRoutineRemoveFromEventList>
  2e:	8a 81       	ldd	r24, Y+2	; 0x02
  30:	9b 81       	ldd	r25, Y+3	; 0x03
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
  32:	9c 01       	movw	r18, r24
  34:	24 5f       	subi	r18, 0xF4	; 244
  36:	3f 4f       	sbci	r19, 0xFF	; 255
  38:	80 e0       	ldi	r24, 0x00	; 0
  3a:	90 e0       	ldi	r25, 0x00	; 0
  3c:	b9 01       	movw	r22, r18
		{
			pxCurrentCoRoutine = pxCoRoutine;
  3e:	0e 94 00 00 	call	0	; 0x0 <xCoRoutineRemoveFromEventList>
  42:	ea 81       	ldd	r30, Y+2	; 0x02
  44:	fb 81       	ldd	r31, Y+3	; 0x03
  46:	96 89       	ldd	r25, Z+22	; 0x16
  48:	e0 91 00 00 	lds	r30, 0x0000
			prvInitialiseCoRoutineLists();
  4c:	f0 91 00 00 	lds	r31, 0x0000
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
  50:	86 89       	ldd	r24, Z+22	; 0x16
  52:	98 17       	cp	r25, r24
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
  54:	00 f0       	brcs	.+0      	; 0x56 <xCoRoutineRemoveFromEventList+0x56>
  56:	81 e0       	ldi	r24, 0x01	; 1
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
  58:	89 83       	std	Y+1, r24	; 0x01
  5a:	00 c0       	rjmp	.+0      	; 0x5c <xCoRoutineRemoveFromEventList+0x5c>
  5c:	19 82       	std	Y+1, r1	; 0x01
  5e:	89 81       	ldd	r24, Y+1	; 0x01
		pxCoRoutine->uxPriority = uxPriority;
  60:	0f 90       	pop	r0
  62:	0f 90       	pop	r0
  64:	0f 90       	pop	r0
  66:	0f 90       	pop	r0
		pxCoRoutine->uxIndex = uxIndex;
  68:	0f 90       	pop	r0
  6a:	cf 91       	pop	r28
  6c:	df 91       	pop	r29
  6e:	08 95       	ret

heap_1.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000624  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000e8e  00000000  00000000  00000658  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.xNextFreeByte 00000002  00000000  00000000  000014e6  2**0
                  ALLOC
  6 .text.pvPortMalloc 0000008c  00000000  00000000  000014e6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.vPortFree 00000018  00000000  00000000  00001572  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.vPortInitialiseBlocks 00000016  00000000  00000000  0000158a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.xPortGetFreeHeapSize 0000001e  00000000  00000000  000015a0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .bss.xHeap    000003e8  00000000  00000000  000015be  2**0
                  ALLOC

Disassembly of section .text.pvPortMalloc:

00000000 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <pvPortMalloc+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <pvPortMalloc+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9c 83       	std	Y+4, r25	; 0x04
   e:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
  10:	1a 82       	std	Y+2, r1	; 0x02
  12:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  14:	0e 94 00 00 	call	0	; 0x0 <pvPortMalloc>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
  18:	80 91 00 00 	lds	r24, 0x0000
  1c:	90 91 00 00 	lds	r25, 0x0000
  20:	2b 81       	ldd	r18, Y+3	; 0x03
  22:	3c 81       	ldd	r19, Y+4	; 0x04
  24:	82 0f       	add	r24, r18
  26:	93 1f       	adc	r25, r19
  28:	23 e0       	ldi	r18, 0x03	; 3
  2a:	88 3e       	cpi	r24, 0xE8	; 232
  2c:	92 07       	cpc	r25, r18
  2e:	00 f4       	brcc	.+0      	; 0x30 <pvPortMalloc+0x30>
  30:	20 91 00 00 	lds	r18, 0x0000
  34:	30 91 00 00 	lds	r19, 0x0000
  38:	8b 81       	ldd	r24, Y+3	; 0x03
  3a:	9c 81       	ldd	r25, Y+4	; 0x04
  3c:	28 0f       	add	r18, r24
  3e:	39 1f       	adc	r19, r25
  40:	80 91 00 00 	lds	r24, 0x0000
  44:	90 91 00 00 	lds	r25, 0x0000
  48:	82 17       	cp	r24, r18
  4a:	93 07       	cpc	r25, r19
  4c:	00 f4       	brcc	.+0      	; 0x4e <pvPortMalloc+0x4e>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
  4e:	80 91 00 00 	lds	r24, 0x0000
  52:	90 91 00 00 	lds	r25, 0x0000
  56:	80 50       	subi	r24, 0x00	; 0
  58:	90 40       	sbci	r25, 0x00	; 0
  5a:	9a 83       	std	Y+2, r25	; 0x02
  5c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
  5e:	20 91 00 00 	lds	r18, 0x0000
  62:	30 91 00 00 	lds	r19, 0x0000
  66:	8b 81       	ldd	r24, Y+3	; 0x03
  68:	9c 81       	ldd	r25, Y+4	; 0x04
  6a:	82 0f       	add	r24, r18
  6c:	93 1f       	adc	r25, r19
  6e:	90 93 00 00 	sts	0x0000, r25
  72:	80 93 00 00 	sts	0x0000, r24
		}	
	}
	xTaskResumeAll();
  76:	0e 94 00 00 	call	0	; 0x0 <pvPortMalloc>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
  7a:	89 81       	ldd	r24, Y+1	; 0x01
  7c:	9a 81       	ldd	r25, Y+2	; 0x02
}
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	cf 91       	pop	r28
  88:	df 91       	pop	r29
  8a:	08 95       	ret

Disassembly of section .text.vPortFree:

00000000 <vPortFree>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vPortFree+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	0f 90       	pop	r0
void *pvReturn = NULL; 
  10:	0f 90       	pop	r0
  12:	cf 91       	pop	r28
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.vPortInitialiseBlocks:

00000000 <vPortInitialiseBlocks>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	10 92 00 00 	sts	0x0000, r1
   c:	10 92 00 00 	sts	0x0000, r1
void *pvReturn = NULL; 
  10:	cf 91       	pop	r28
  12:	df 91       	pop	r29
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  14:	08 95       	ret

Disassembly of section .text.xPortGetFreeHeapSize:

00000000 <xPortGetFreeHeapSize>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	20 91 00 00 	lds	r18, 0x0000
   c:	30 91 00 00 	lds	r19, 0x0000
void *pvReturn = NULL; 
  10:	88 ee       	ldi	r24, 0xE8	; 232
  12:	93 e0       	ldi	r25, 0x03	; 3
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  14:	82 1b       	sub	r24, r18
  16:	93 0b       	sbc	r25, r19
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
  18:	cf 91       	pop	r28
  1a:	df 91       	pop	r29
  1c:	08 95       	ret

list.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000c9e  00000000  00000000  00000784  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.vListInitialise 00000054  00000000  00000000  00001422  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.vListInitialiseItem 00000020  00000000  00000000  00001476  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.vListInsertEnd 00000098  00000000  00000000  00001496  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.vListInsert 000000d8  00000000  00000000  0000152e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.vListRemove 00000092  00000000  00000000  00001606  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.vListInitialise:

00000000 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vListInitialise+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	9a 81       	ldd	r25, Y+2	; 0x02
  12:	03 96       	adiw	r24, 0x03	; 3
  14:	e9 81       	ldd	r30, Y+1	; 0x01
  16:	fa 81       	ldd	r31, Y+2	; 0x02
  18:	92 83       	std	Z+2, r25	; 0x02
  1a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  1c:	e9 81       	ldd	r30, Y+1	; 0x01
  1e:	fa 81       	ldd	r31, Y+2	; 0x02
  20:	8f ef       	ldi	r24, 0xFF	; 255
  22:	9f ef       	ldi	r25, 0xFF	; 255
  24:	94 83       	std	Z+4, r25	; 0x04
  26:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  28:	89 81       	ldd	r24, Y+1	; 0x01
  2a:	9a 81       	ldd	r25, Y+2	; 0x02
  2c:	03 96       	adiw	r24, 0x03	; 3
  2e:	e9 81       	ldd	r30, Y+1	; 0x01
  30:	fa 81       	ldd	r31, Y+2	; 0x02
  32:	96 83       	std	Z+6, r25	; 0x06
  34:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  36:	89 81       	ldd	r24, Y+1	; 0x01
  38:	9a 81       	ldd	r25, Y+2	; 0x02
  3a:	03 96       	adiw	r24, 0x03	; 3
  3c:	e9 81       	ldd	r30, Y+1	; 0x01
  3e:	fa 81       	ldd	r31, Y+2	; 0x02
  40:	90 87       	std	Z+8, r25	; 0x08
  42:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  44:	e9 81       	ldd	r30, Y+1	; 0x01
  46:	fa 81       	ldd	r31, Y+2	; 0x02
  48:	10 82       	st	Z, r1
}
  4a:	0f 90       	pop	r0
  4c:	0f 90       	pop	r0
  4e:	cf 91       	pop	r28
  50:	df 91       	pop	r29
  52:	08 95       	ret

Disassembly of section .text.vListInitialiseItem:

00000000 <vListInitialiseItem>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vListInitialiseItem+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   e:	e9 81       	ldd	r30, Y+1	; 0x01
  10:	fa 81       	ldd	r31, Y+2	; 0x02
  12:	11 86       	std	Z+9, r1	; 0x09
  14:	10 86       	std	Z+8, r1	; 0x08
  16:	0f 90       	pop	r0
  18:	0f 90       	pop	r0
  1a:	cf 91       	pop	r28

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  1c:	df 91       	pop	r29
  1e:	08 95       	ret

Disassembly of section .text.vListInsertEnd:

00000000 <vListInsertEnd>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vListInsertEnd+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <vListInsertEnd+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <vListInsertEnd+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   e:	9c 83       	std	Y+4, r25	; 0x04
  10:	8b 83       	std	Y+3, r24	; 0x03
  12:	7e 83       	std	Y+6, r23	; 0x06
  14:	6d 83       	std	Y+5, r22	; 0x05
  16:	eb 81       	ldd	r30, Y+3	; 0x03
  18:	fc 81       	ldd	r31, Y+4	; 0x04
  1a:	81 81       	ldd	r24, Z+1	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  1c:	92 81       	ldd	r25, Z+2	; 0x02
  1e:	9a 83       	std	Y+2, r25	; 0x02
  20:	89 83       	std	Y+1, r24	; 0x01
  22:	e9 81       	ldd	r30, Y+1	; 0x01
  24:	fa 81       	ldd	r31, Y+2	; 0x02
  26:	82 81       	ldd	r24, Z+2	; 0x02

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  28:	93 81       	ldd	r25, Z+3	; 0x03
  2a:	ed 81       	ldd	r30, Y+5	; 0x05
  2c:	fe 81       	ldd	r31, Y+6	; 0x06
  2e:	93 83       	std	Z+3, r25	; 0x03
  30:	82 83       	std	Z+2, r24	; 0x02
  32:	eb 81       	ldd	r30, Y+3	; 0x03
  34:	fc 81       	ldd	r31, Y+4	; 0x04
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  36:	81 81       	ldd	r24, Z+1	; 0x01
  38:	92 81       	ldd	r25, Z+2	; 0x02
  3a:	ed 81       	ldd	r30, Y+5	; 0x05
  3c:	fe 81       	ldd	r31, Y+6	; 0x06
  3e:	95 83       	std	Z+5, r25	; 0x05
  40:	84 83       	std	Z+4, r24	; 0x04
  42:	e9 81       	ldd	r30, Y+1	; 0x01

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  44:	fa 81       	ldd	r31, Y+2	; 0x02
  46:	02 80       	ldd	r0, Z+2	; 0x02
  48:	f3 81       	ldd	r31, Z+3	; 0x03
}
  4a:	e0 2d       	mov	r30, r0
  4c:	8d 81       	ldd	r24, Y+5	; 0x05
  4e:	9e 81       	ldd	r25, Y+6	; 0x06
  50:	95 83       	std	Z+5, r25	; 0x05
  52:	84 83       	std	Z+4, r24	; 0x04
  54:	8d 81       	ldd	r24, Y+5	; 0x05
  56:	9e 81       	ldd	r25, Y+6	; 0x06
  58:	e9 81       	ldd	r30, Y+1	; 0x01
  5a:	fa 81       	ldd	r31, Y+2	; 0x02
  5c:	93 83       	std	Z+3, r25	; 0x03
  5e:	82 83       	std	Z+2, r24	; 0x02
  60:	8d 81       	ldd	r24, Y+5	; 0x05
  62:	9e 81       	ldd	r25, Y+6	; 0x06
  64:	eb 81       	ldd	r30, Y+3	; 0x03
  66:	fc 81       	ldd	r31, Y+4	; 0x04
  68:	92 83       	std	Z+2, r25	; 0x02
  6a:	81 83       	std	Z+1, r24	; 0x01
  6c:	ed 81       	ldd	r30, Y+5	; 0x05
  6e:	fe 81       	ldd	r31, Y+6	; 0x06
  70:	8b 81       	ldd	r24, Y+3	; 0x03
  72:	9c 81       	ldd	r25, Y+4	; 0x04
  74:	91 87       	std	Z+9, r25	; 0x09
  76:	80 87       	std	Z+8, r24	; 0x08
  78:	eb 81       	ldd	r30, Y+3	; 0x03
  7a:	fc 81       	ldd	r31, Y+4	; 0x04
  7c:	80 81       	ld	r24, Z
  7e:	8f 5f       	subi	r24, 0xFF	; 255
  80:	eb 81       	ldd	r30, Y+3	; 0x03
  82:	fc 81       	ldd	r31, Y+4	; 0x04
  84:	80 83       	st	Z, r24
  86:	26 96       	adiw	r28, 0x06	; 6
  88:	0f b6       	in	r0, 0x3f	; 63
  8a:	f8 94       	cli
  8c:	de bf       	out	0x3e, r29	; 62
  8e:	0f be       	out	0x3f, r0	; 63
  90:	cd bf       	out	0x3d, r28	; 61
  92:	cf 91       	pop	r28
  94:	df 91       	pop	r29
  96:	08 95       	ret

Disassembly of section .text.vListInsert:

00000000 <vListInsert>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9e 83       	std	Y+6, r25	; 0x06
  16:	8d 83       	std	Y+5, r24	; 0x05
  18:	78 87       	std	Y+8, r23	; 0x08
  1a:	6f 83       	std	Y+7, r22	; 0x07

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  1c:	ef 81       	ldd	r30, Y+7	; 0x07
  1e:	f8 85       	ldd	r31, Y+8	; 0x08
  20:	80 81       	ld	r24, Z
  22:	91 81       	ldd	r25, Z+1	; 0x01
  24:	9a 83       	std	Y+2, r25	; 0x02
  26:	89 83       	std	Y+1, r24	; 0x01

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  28:	89 81       	ldd	r24, Y+1	; 0x01
  2a:	9a 81       	ldd	r25, Y+2	; 0x02
  2c:	2f ef       	ldi	r18, 0xFF	; 255
  2e:	8f 3f       	cpi	r24, 0xFF	; 255
  30:	92 07       	cpc	r25, r18
  32:	01 f4       	brne	.+0      	; 0x34 <vListInsert+0x34>
  34:	ed 81       	ldd	r30, Y+5	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  36:	fe 81       	ldd	r31, Y+6	; 0x06
  38:	87 81       	ldd	r24, Z+7	; 0x07
  3a:	90 85       	ldd	r25, Z+8	; 0x08
  3c:	9c 83       	std	Y+4, r25	; 0x04
  3e:	8b 83       	std	Y+3, r24	; 0x03
  40:	00 c0       	rjmp	.+0      	; 0x42 <vListInsert+0x42>
  42:	8d 81       	ldd	r24, Y+5	; 0x05

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  44:	9e 81       	ldd	r25, Y+6	; 0x06
  46:	03 96       	adiw	r24, 0x03	; 3
  48:	9c 83       	std	Y+4, r25	; 0x04
}
  4a:	8b 83       	std	Y+3, r24	; 0x03
  4c:	00 c0       	rjmp	.+0      	; 0x4e <vListInsert+0x4e>
  4e:	eb 81       	ldd	r30, Y+3	; 0x03
  50:	fc 81       	ldd	r31, Y+4	; 0x04
  52:	82 81       	ldd	r24, Z+2	; 0x02
  54:	93 81       	ldd	r25, Z+3	; 0x03
  56:	9c 83       	std	Y+4, r25	; 0x04
  58:	8b 83       	std	Y+3, r24	; 0x03
  5a:	eb 81       	ldd	r30, Y+3	; 0x03
  5c:	fc 81       	ldd	r31, Y+4	; 0x04
  5e:	02 80       	ldd	r0, Z+2	; 0x02
  60:	f3 81       	ldd	r31, Z+3	; 0x03
  62:	e0 2d       	mov	r30, r0
  64:	20 81       	ld	r18, Z
  66:	31 81       	ldd	r19, Z+1	; 0x01
  68:	89 81       	ldd	r24, Y+1	; 0x01
  6a:	9a 81       	ldd	r25, Y+2	; 0x02
  6c:	82 17       	cp	r24, r18
  6e:	93 07       	cpc	r25, r19
  70:	00 f4       	brcc	.+0      	; 0x72 <vListInsert+0x72>
  72:	eb 81       	ldd	r30, Y+3	; 0x03
  74:	fc 81       	ldd	r31, Y+4	; 0x04
  76:	82 81       	ldd	r24, Z+2	; 0x02
  78:	93 81       	ldd	r25, Z+3	; 0x03
  7a:	ef 81       	ldd	r30, Y+7	; 0x07
  7c:	f8 85       	ldd	r31, Y+8	; 0x08
  7e:	93 83       	std	Z+3, r25	; 0x03
  80:	82 83       	std	Z+2, r24	; 0x02
  82:	ef 81       	ldd	r30, Y+7	; 0x07
  84:	f8 85       	ldd	r31, Y+8	; 0x08
  86:	02 80       	ldd	r0, Z+2	; 0x02
  88:	f3 81       	ldd	r31, Z+3	; 0x03
  8a:	e0 2d       	mov	r30, r0
  8c:	8f 81       	ldd	r24, Y+7	; 0x07
  8e:	98 85       	ldd	r25, Y+8	; 0x08
  90:	95 83       	std	Z+5, r25	; 0x05
  92:	84 83       	std	Z+4, r24	; 0x04
  94:	ef 81       	ldd	r30, Y+7	; 0x07
  96:	f8 85       	ldd	r31, Y+8	; 0x08
  98:	8b 81       	ldd	r24, Y+3	; 0x03
  9a:	9c 81       	ldd	r25, Y+4	; 0x04
  9c:	95 83       	std	Z+5, r25	; 0x05
  9e:	84 83       	std	Z+4, r24	; 0x04
  a0:	8f 81       	ldd	r24, Y+7	; 0x07
  a2:	98 85       	ldd	r25, Y+8	; 0x08
  a4:	eb 81       	ldd	r30, Y+3	; 0x03
  a6:	fc 81       	ldd	r31, Y+4	; 0x04
  a8:	93 83       	std	Z+3, r25	; 0x03
  aa:	82 83       	std	Z+2, r24	; 0x02
  ac:	ef 81       	ldd	r30, Y+7	; 0x07
  ae:	f8 85       	ldd	r31, Y+8	; 0x08
  b0:	8d 81       	ldd	r24, Y+5	; 0x05
  b2:	9e 81       	ldd	r25, Y+6	; 0x06
  b4:	91 87       	std	Z+9, r25	; 0x09
  b6:	80 87       	std	Z+8, r24	; 0x08
  b8:	ed 81       	ldd	r30, Y+5	; 0x05
  ba:	fe 81       	ldd	r31, Y+6	; 0x06
  bc:	80 81       	ld	r24, Z
  be:	8f 5f       	subi	r24, 0xFF	; 255
  c0:	ed 81       	ldd	r30, Y+5	; 0x05
  c2:	fe 81       	ldd	r31, Y+6	; 0x06
  c4:	80 83       	st	Z, r24
  c6:	28 96       	adiw	r28, 0x08	; 8
  c8:	0f b6       	in	r0, 0x3f	; 63
  ca:	f8 94       	cli
  cc:	de bf       	out	0x3e, r29	; 62
  ce:	0f be       	out	0x3f, r0	; 63
  d0:	cd bf       	out	0x3d, r28	; 61
  d2:	cf 91       	pop	r28
  d4:	df 91       	pop	r29
  d6:	08 95       	ret

Disassembly of section .text.vListRemove:

00000000 <vListRemove>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vListRemove+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <vListRemove+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9c 83       	std	Y+4, r25	; 0x04
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   e:	8b 83       	std	Y+3, r24	; 0x03
  10:	eb 81       	ldd	r30, Y+3	; 0x03
  12:	fc 81       	ldd	r31, Y+4	; 0x04
  14:	a2 81       	ldd	r26, Z+2	; 0x02
  16:	b3 81       	ldd	r27, Z+3	; 0x03
  18:	eb 81       	ldd	r30, Y+3	; 0x03
  1a:	fc 81       	ldd	r31, Y+4	; 0x04

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  1c:	84 81       	ldd	r24, Z+4	; 0x04
  1e:	95 81       	ldd	r25, Z+5	; 0x05
  20:	15 96       	adiw	r26, 0x05	; 5
  22:	9c 93       	st	X, r25
  24:	8e 93       	st	-X, r24
  26:	14 97       	sbiw	r26, 0x04	; 4

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  28:	eb 81       	ldd	r30, Y+3	; 0x03
  2a:	fc 81       	ldd	r31, Y+4	; 0x04
  2c:	a4 81       	ldd	r26, Z+4	; 0x04
  2e:	b5 81       	ldd	r27, Z+5	; 0x05
  30:	eb 81       	ldd	r30, Y+3	; 0x03
  32:	fc 81       	ldd	r31, Y+4	; 0x04
  34:	82 81       	ldd	r24, Z+2	; 0x02
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  36:	93 81       	ldd	r25, Z+3	; 0x03
  38:	13 96       	adiw	r26, 0x03	; 3
  3a:	9c 93       	st	X, r25
  3c:	8e 93       	st	-X, r24
  3e:	12 97       	sbiw	r26, 0x02	; 2
  40:	eb 81       	ldd	r30, Y+3	; 0x03
  42:	fc 81       	ldd	r31, Y+4	; 0x04

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  44:	80 85       	ldd	r24, Z+8	; 0x08
  46:	91 85       	ldd	r25, Z+9	; 0x09
  48:	9a 83       	std	Y+2, r25	; 0x02
}
  4a:	89 83       	std	Y+1, r24	; 0x01
  4c:	e9 81       	ldd	r30, Y+1	; 0x01
  4e:	fa 81       	ldd	r31, Y+2	; 0x02
  50:	21 81       	ldd	r18, Z+1	; 0x01
  52:	32 81       	ldd	r19, Z+2	; 0x02
  54:	8b 81       	ldd	r24, Y+3	; 0x03
  56:	9c 81       	ldd	r25, Y+4	; 0x04
  58:	28 17       	cp	r18, r24
  5a:	39 07       	cpc	r19, r25
  5c:	01 f4       	brne	.+0      	; 0x5e <vListRemove+0x5e>
  5e:	eb 81       	ldd	r30, Y+3	; 0x03
  60:	fc 81       	ldd	r31, Y+4	; 0x04
  62:	84 81       	ldd	r24, Z+4	; 0x04
  64:	95 81       	ldd	r25, Z+5	; 0x05
  66:	e9 81       	ldd	r30, Y+1	; 0x01
  68:	fa 81       	ldd	r31, Y+2	; 0x02
  6a:	92 83       	std	Z+2, r25	; 0x02
  6c:	81 83       	std	Z+1, r24	; 0x01
  6e:	eb 81       	ldd	r30, Y+3	; 0x03
  70:	fc 81       	ldd	r31, Y+4	; 0x04
  72:	11 86       	std	Z+9, r1	; 0x09
  74:	10 86       	std	Z+8, r1	; 0x08
  76:	e9 81       	ldd	r30, Y+1	; 0x01
  78:	fa 81       	ldd	r31, Y+2	; 0x02
  7a:	80 81       	ld	r24, Z
  7c:	81 50       	subi	r24, 0x01	; 1
  7e:	e9 81       	ldd	r30, Y+1	; 0x01
  80:	fa 81       	ldd	r31, Y+2	; 0x02
  82:	80 83       	st	Z, r24
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	0f 90       	pop	r0
  8c:	cf 91       	pop	r28
  8e:	df 91       	pop	r29
  90:	08 95       	ret

main.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         0000051c  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000ccb  00000000  00000000  00000550  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.main    0000000e  00000000  00000000  0000121b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.main:

00000000 <main>:




void main(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	PORT_VoidInit();
   8:	0e 94 00 00 	call	0	; 0x0 <main>
   c:	00 c0       	rjmp	.+0      	; 0xe <__zero_reg__+0xd>

port.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000b70  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000edb  00000000  00000000  00000ba4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.pxPortInitialiseStack 00000306  00000000  00000000  00001a7f  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.xPortStartScheduler 0000006a  00000000  00000000  00001d85  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.vPortEndScheduler 0000000e  00000000  00000000  00001def  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.vPortYield 000000b2  00000000  00000000  00001dfd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.vPortYieldFromTick 000000b6  00000000  00000000  00001eaf  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.prvSetupTimerInterrupt 000000b8  00000000  00000000  00001f65  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.__vector_7 00000006  00000000  00000000  0000201d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.pxPortInitialiseStack:

00000000 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9c 83       	std	Y+4, r25	; 0x04
  16:	8b 83       	std	Y+3, r24	; 0x03
  18:	7e 83       	std	Y+6, r23	; 0x06
  1a:	6d 83       	std	Y+5, r22	; 0x05
  1c:	58 87       	std	Y+8, r21	; 0x08
  1e:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
  20:	eb 81       	ldd	r30, Y+3	; 0x03
  22:	fc 81       	ldd	r31, Y+4	; 0x04
  24:	81 e1       	ldi	r24, 0x11	; 17
  26:	80 83       	st	Z, r24
	pxTopOfStack--;
  28:	8b 81       	ldd	r24, Y+3	; 0x03
  2a:	9c 81       	ldd	r25, Y+4	; 0x04
  2c:	01 97       	sbiw	r24, 0x01	; 1
  2e:	9c 83       	std	Y+4, r25	; 0x04
  30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
  32:	eb 81       	ldd	r30, Y+3	; 0x03
  34:	fc 81       	ldd	r31, Y+4	; 0x04
  36:	82 e2       	ldi	r24, 0x22	; 34
  38:	80 83       	st	Z, r24
	pxTopOfStack--;
  3a:	8b 81       	ldd	r24, Y+3	; 0x03
  3c:	9c 81       	ldd	r25, Y+4	; 0x04
  3e:	01 97       	sbiw	r24, 0x01	; 1
  40:	9c 83       	std	Y+4, r25	; 0x04
  42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
  44:	eb 81       	ldd	r30, Y+3	; 0x03
  46:	fc 81       	ldd	r31, Y+4	; 0x04
  48:	83 e3       	ldi	r24, 0x33	; 51
  4a:	80 83       	st	Z, r24
	pxTopOfStack--;
  4c:	8b 81       	ldd	r24, Y+3	; 0x03
  4e:	9c 81       	ldd	r25, Y+4	; 0x04
  50:	01 97       	sbiw	r24, 0x01	; 1
  52:	9c 83       	std	Y+4, r25	; 0x04
  54:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
  56:	8d 81       	ldd	r24, Y+5	; 0x05
  58:	9e 81       	ldd	r25, Y+6	; 0x06
  5a:	9a 83       	std	Y+2, r25	; 0x02
  5c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  5e:	89 81       	ldd	r24, Y+1	; 0x01
  60:	eb 81       	ldd	r30, Y+3	; 0x03
  62:	fc 81       	ldd	r31, Y+4	; 0x04
  64:	80 83       	st	Z, r24
	pxTopOfStack--;
  66:	8b 81       	ldd	r24, Y+3	; 0x03
  68:	9c 81       	ldd	r25, Y+4	; 0x04
  6a:	01 97       	sbiw	r24, 0x01	; 1
  6c:	9c 83       	std	Y+4, r25	; 0x04
  6e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
  70:	89 81       	ldd	r24, Y+1	; 0x01
  72:	9a 81       	ldd	r25, Y+2	; 0x02
  74:	89 2f       	mov	r24, r25
  76:	99 27       	eor	r25, r25
  78:	9a 83       	std	Y+2, r25	; 0x02
  7a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  7c:	89 81       	ldd	r24, Y+1	; 0x01
  7e:	eb 81       	ldd	r30, Y+3	; 0x03
  80:	fc 81       	ldd	r31, Y+4	; 0x04
  82:	80 83       	st	Z, r24
	pxTopOfStack--;
  84:	8b 81       	ldd	r24, Y+3	; 0x03
  86:	9c 81       	ldd	r25, Y+4	; 0x04
  88:	01 97       	sbiw	r24, 0x01	; 1
  8a:	9c 83       	std	Y+4, r25	; 0x04
  8c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
  8e:	eb 81       	ldd	r30, Y+3	; 0x03
  90:	fc 81       	ldd	r31, Y+4	; 0x04
  92:	10 82       	st	Z, r1
	pxTopOfStack--;
  94:	8b 81       	ldd	r24, Y+3	; 0x03
  96:	9c 81       	ldd	r25, Y+4	; 0x04
  98:	01 97       	sbiw	r24, 0x01	; 1
  9a:	9c 83       	std	Y+4, r25	; 0x04
  9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
  9e:	eb 81       	ldd	r30, Y+3	; 0x03
  a0:	fc 81       	ldd	r31, Y+4	; 0x04
  a2:	80 e8       	ldi	r24, 0x80	; 128
  a4:	80 83       	st	Z, r24
	pxTopOfStack--;
  a6:	8b 81       	ldd	r24, Y+3	; 0x03
  a8:	9c 81       	ldd	r25, Y+4	; 0x04
  aa:	01 97       	sbiw	r24, 0x01	; 1
  ac:	9c 83       	std	Y+4, r25	; 0x04
  ae:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
  b0:	eb 81       	ldd	r30, Y+3	; 0x03
  b2:	fc 81       	ldd	r31, Y+4	; 0x04
  b4:	10 82       	st	Z, r1
	pxTopOfStack--;
  b6:	8b 81       	ldd	r24, Y+3	; 0x03
  b8:	9c 81       	ldd	r25, Y+4	; 0x04
  ba:	01 97       	sbiw	r24, 0x01	; 1
  bc:	9c 83       	std	Y+4, r25	; 0x04
  be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
  c0:	eb 81       	ldd	r30, Y+3	; 0x03
  c2:	fc 81       	ldd	r31, Y+4	; 0x04
  c4:	82 e0       	ldi	r24, 0x02	; 2
  c6:	80 83       	st	Z, r24
	pxTopOfStack--;
  c8:	8b 81       	ldd	r24, Y+3	; 0x03
  ca:	9c 81       	ldd	r25, Y+4	; 0x04
  cc:	01 97       	sbiw	r24, 0x01	; 1
  ce:	9c 83       	std	Y+4, r25	; 0x04
  d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
  d2:	eb 81       	ldd	r30, Y+3	; 0x03
  d4:	fc 81       	ldd	r31, Y+4	; 0x04
  d6:	83 e0       	ldi	r24, 0x03	; 3
  d8:	80 83       	st	Z, r24
	pxTopOfStack--;
  da:	8b 81       	ldd	r24, Y+3	; 0x03
  dc:	9c 81       	ldd	r25, Y+4	; 0x04
  de:	01 97       	sbiw	r24, 0x01	; 1
  e0:	9c 83       	std	Y+4, r25	; 0x04
  e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
  e4:	eb 81       	ldd	r30, Y+3	; 0x03
  e6:	fc 81       	ldd	r31, Y+4	; 0x04
  e8:	84 e0       	ldi	r24, 0x04	; 4
  ea:	80 83       	st	Z, r24
	pxTopOfStack--;
  ec:	8b 81       	ldd	r24, Y+3	; 0x03
  ee:	9c 81       	ldd	r25, Y+4	; 0x04
  f0:	01 97       	sbiw	r24, 0x01	; 1
  f2:	9c 83       	std	Y+4, r25	; 0x04
  f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
  f6:	eb 81       	ldd	r30, Y+3	; 0x03
  f8:	fc 81       	ldd	r31, Y+4	; 0x04
  fa:	85 e0       	ldi	r24, 0x05	; 5
  fc:	80 83       	st	Z, r24
	pxTopOfStack--;
  fe:	8b 81       	ldd	r24, Y+3	; 0x03
 100:	9c 81       	ldd	r25, Y+4	; 0x04
 102:	01 97       	sbiw	r24, 0x01	; 1
 104:	9c 83       	std	Y+4, r25	; 0x04
 106:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
 108:	eb 81       	ldd	r30, Y+3	; 0x03
 10a:	fc 81       	ldd	r31, Y+4	; 0x04
 10c:	86 e0       	ldi	r24, 0x06	; 6
 10e:	80 83       	st	Z, r24
	pxTopOfStack--;
 110:	8b 81       	ldd	r24, Y+3	; 0x03
 112:	9c 81       	ldd	r25, Y+4	; 0x04
 114:	01 97       	sbiw	r24, 0x01	; 1
 116:	9c 83       	std	Y+4, r25	; 0x04
 118:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
 11a:	eb 81       	ldd	r30, Y+3	; 0x03
 11c:	fc 81       	ldd	r31, Y+4	; 0x04
 11e:	87 e0       	ldi	r24, 0x07	; 7
 120:	80 83       	st	Z, r24
	pxTopOfStack--;
 122:	8b 81       	ldd	r24, Y+3	; 0x03
 124:	9c 81       	ldd	r25, Y+4	; 0x04
 126:	01 97       	sbiw	r24, 0x01	; 1
 128:	9c 83       	std	Y+4, r25	; 0x04
 12a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
 12c:	eb 81       	ldd	r30, Y+3	; 0x03
 12e:	fc 81       	ldd	r31, Y+4	; 0x04
 130:	88 e0       	ldi	r24, 0x08	; 8
 132:	80 83       	st	Z, r24
	pxTopOfStack--;
 134:	8b 81       	ldd	r24, Y+3	; 0x03
 136:	9c 81       	ldd	r25, Y+4	; 0x04
 138:	01 97       	sbiw	r24, 0x01	; 1
 13a:	9c 83       	std	Y+4, r25	; 0x04
 13c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
 13e:	eb 81       	ldd	r30, Y+3	; 0x03
 140:	fc 81       	ldd	r31, Y+4	; 0x04
 142:	89 e0       	ldi	r24, 0x09	; 9
 144:	80 83       	st	Z, r24
	pxTopOfStack--;
 146:	8b 81       	ldd	r24, Y+3	; 0x03
 148:	9c 81       	ldd	r25, Y+4	; 0x04
 14a:	01 97       	sbiw	r24, 0x01	; 1
 14c:	9c 83       	std	Y+4, r25	; 0x04
 14e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
 150:	eb 81       	ldd	r30, Y+3	; 0x03
 152:	fc 81       	ldd	r31, Y+4	; 0x04
 154:	80 e1       	ldi	r24, 0x10	; 16
 156:	80 83       	st	Z, r24
	pxTopOfStack--;
 158:	8b 81       	ldd	r24, Y+3	; 0x03
 15a:	9c 81       	ldd	r25, Y+4	; 0x04
 15c:	01 97       	sbiw	r24, 0x01	; 1
 15e:	9c 83       	std	Y+4, r25	; 0x04
 160:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
 162:	eb 81       	ldd	r30, Y+3	; 0x03
 164:	fc 81       	ldd	r31, Y+4	; 0x04
 166:	81 e1       	ldi	r24, 0x11	; 17
 168:	80 83       	st	Z, r24
	pxTopOfStack--;
 16a:	8b 81       	ldd	r24, Y+3	; 0x03
 16c:	9c 81       	ldd	r25, Y+4	; 0x04
 16e:	01 97       	sbiw	r24, 0x01	; 1
 170:	9c 83       	std	Y+4, r25	; 0x04
 172:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
 174:	eb 81       	ldd	r30, Y+3	; 0x03
 176:	fc 81       	ldd	r31, Y+4	; 0x04
 178:	82 e1       	ldi	r24, 0x12	; 18
 17a:	80 83       	st	Z, r24
	pxTopOfStack--;
 17c:	8b 81       	ldd	r24, Y+3	; 0x03
 17e:	9c 81       	ldd	r25, Y+4	; 0x04
 180:	01 97       	sbiw	r24, 0x01	; 1
 182:	9c 83       	std	Y+4, r25	; 0x04
 184:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
 186:	eb 81       	ldd	r30, Y+3	; 0x03
 188:	fc 81       	ldd	r31, Y+4	; 0x04
 18a:	83 e1       	ldi	r24, 0x13	; 19
 18c:	80 83       	st	Z, r24
	pxTopOfStack--;
 18e:	8b 81       	ldd	r24, Y+3	; 0x03
 190:	9c 81       	ldd	r25, Y+4	; 0x04
 192:	01 97       	sbiw	r24, 0x01	; 1
 194:	9c 83       	std	Y+4, r25	; 0x04
 196:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
 198:	eb 81       	ldd	r30, Y+3	; 0x03
 19a:	fc 81       	ldd	r31, Y+4	; 0x04
 19c:	84 e1       	ldi	r24, 0x14	; 20
 19e:	80 83       	st	Z, r24
	pxTopOfStack--;
 1a0:	8b 81       	ldd	r24, Y+3	; 0x03
 1a2:	9c 81       	ldd	r25, Y+4	; 0x04
 1a4:	01 97       	sbiw	r24, 0x01	; 1
 1a6:	9c 83       	std	Y+4, r25	; 0x04
 1a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
 1aa:	eb 81       	ldd	r30, Y+3	; 0x03
 1ac:	fc 81       	ldd	r31, Y+4	; 0x04
 1ae:	85 e1       	ldi	r24, 0x15	; 21
 1b0:	80 83       	st	Z, r24
	pxTopOfStack--;
 1b2:	8b 81       	ldd	r24, Y+3	; 0x03
 1b4:	9c 81       	ldd	r25, Y+4	; 0x04
 1b6:	01 97       	sbiw	r24, 0x01	; 1
 1b8:	9c 83       	std	Y+4, r25	; 0x04
 1ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
 1bc:	eb 81       	ldd	r30, Y+3	; 0x03
 1be:	fc 81       	ldd	r31, Y+4	; 0x04
 1c0:	86 e1       	ldi	r24, 0x16	; 22
 1c2:	80 83       	st	Z, r24
	pxTopOfStack--;
 1c4:	8b 81       	ldd	r24, Y+3	; 0x03
 1c6:	9c 81       	ldd	r25, Y+4	; 0x04
 1c8:	01 97       	sbiw	r24, 0x01	; 1
 1ca:	9c 83       	std	Y+4, r25	; 0x04
 1cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
 1ce:	eb 81       	ldd	r30, Y+3	; 0x03
 1d0:	fc 81       	ldd	r31, Y+4	; 0x04
 1d2:	87 e1       	ldi	r24, 0x17	; 23
 1d4:	80 83       	st	Z, r24
	pxTopOfStack--;
 1d6:	8b 81       	ldd	r24, Y+3	; 0x03
 1d8:	9c 81       	ldd	r25, Y+4	; 0x04
 1da:	01 97       	sbiw	r24, 0x01	; 1
 1dc:	9c 83       	std	Y+4, r25	; 0x04
 1de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
 1e0:	eb 81       	ldd	r30, Y+3	; 0x03
 1e2:	fc 81       	ldd	r31, Y+4	; 0x04
 1e4:	88 e1       	ldi	r24, 0x18	; 24
 1e6:	80 83       	st	Z, r24
	pxTopOfStack--;
 1e8:	8b 81       	ldd	r24, Y+3	; 0x03
 1ea:	9c 81       	ldd	r25, Y+4	; 0x04
 1ec:	01 97       	sbiw	r24, 0x01	; 1
 1ee:	9c 83       	std	Y+4, r25	; 0x04
 1f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
 1f2:	eb 81       	ldd	r30, Y+3	; 0x03
 1f4:	fc 81       	ldd	r31, Y+4	; 0x04
 1f6:	89 e1       	ldi	r24, 0x19	; 25
 1f8:	80 83       	st	Z, r24
	pxTopOfStack--;
 1fa:	8b 81       	ldd	r24, Y+3	; 0x03
 1fc:	9c 81       	ldd	r25, Y+4	; 0x04
 1fe:	01 97       	sbiw	r24, 0x01	; 1
 200:	9c 83       	std	Y+4, r25	; 0x04
 202:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
 204:	eb 81       	ldd	r30, Y+3	; 0x03
 206:	fc 81       	ldd	r31, Y+4	; 0x04
 208:	80 e2       	ldi	r24, 0x20	; 32
 20a:	80 83       	st	Z, r24
	pxTopOfStack--;
 20c:	8b 81       	ldd	r24, Y+3	; 0x03
 20e:	9c 81       	ldd	r25, Y+4	; 0x04
 210:	01 97       	sbiw	r24, 0x01	; 1
 212:	9c 83       	std	Y+4, r25	; 0x04
 214:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
 216:	eb 81       	ldd	r30, Y+3	; 0x03
 218:	fc 81       	ldd	r31, Y+4	; 0x04
 21a:	81 e2       	ldi	r24, 0x21	; 33
 21c:	80 83       	st	Z, r24
	pxTopOfStack--;
 21e:	8b 81       	ldd	r24, Y+3	; 0x03
 220:	9c 81       	ldd	r25, Y+4	; 0x04
 222:	01 97       	sbiw	r24, 0x01	; 1
 224:	9c 83       	std	Y+4, r25	; 0x04
 226:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
 228:	eb 81       	ldd	r30, Y+3	; 0x03
 22a:	fc 81       	ldd	r31, Y+4	; 0x04
 22c:	82 e2       	ldi	r24, 0x22	; 34
 22e:	80 83       	st	Z, r24
	pxTopOfStack--;
 230:	8b 81       	ldd	r24, Y+3	; 0x03
 232:	9c 81       	ldd	r25, Y+4	; 0x04
 234:	01 97       	sbiw	r24, 0x01	; 1
 236:	9c 83       	std	Y+4, r25	; 0x04
 238:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
 23a:	eb 81       	ldd	r30, Y+3	; 0x03
 23c:	fc 81       	ldd	r31, Y+4	; 0x04
 23e:	83 e2       	ldi	r24, 0x23	; 35
 240:	80 83       	st	Z, r24
	pxTopOfStack--;
 242:	8b 81       	ldd	r24, Y+3	; 0x03
 244:	9c 81       	ldd	r25, Y+4	; 0x04
 246:	01 97       	sbiw	r24, 0x01	; 1
 248:	9c 83       	std	Y+4, r25	; 0x04
 24a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
 24c:	8f 81       	ldd	r24, Y+7	; 0x07
 24e:	98 85       	ldd	r25, Y+8	; 0x08
 250:	9a 83       	std	Y+2, r25	; 0x02
 252:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
 254:	89 81       	ldd	r24, Y+1	; 0x01
 256:	eb 81       	ldd	r30, Y+3	; 0x03
 258:	fc 81       	ldd	r31, Y+4	; 0x04
 25a:	80 83       	st	Z, r24
	pxTopOfStack--;
 25c:	8b 81       	ldd	r24, Y+3	; 0x03
 25e:	9c 81       	ldd	r25, Y+4	; 0x04
 260:	01 97       	sbiw	r24, 0x01	; 1
 262:	9c 83       	std	Y+4, r25	; 0x04
 264:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
 266:	89 81       	ldd	r24, Y+1	; 0x01
 268:	9a 81       	ldd	r25, Y+2	; 0x02
 26a:	89 2f       	mov	r24, r25
 26c:	99 27       	eor	r25, r25
 26e:	9a 83       	std	Y+2, r25	; 0x02
 270:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
 272:	89 81       	ldd	r24, Y+1	; 0x01
 274:	eb 81       	ldd	r30, Y+3	; 0x03
 276:	fc 81       	ldd	r31, Y+4	; 0x04
 278:	80 83       	st	Z, r24
	pxTopOfStack--;
 27a:	8b 81       	ldd	r24, Y+3	; 0x03
 27c:	9c 81       	ldd	r25, Y+4	; 0x04
 27e:	01 97       	sbiw	r24, 0x01	; 1
 280:	9c 83       	std	Y+4, r25	; 0x04
 282:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
 284:	eb 81       	ldd	r30, Y+3	; 0x03
 286:	fc 81       	ldd	r31, Y+4	; 0x04
 288:	86 e2       	ldi	r24, 0x26	; 38
 28a:	80 83       	st	Z, r24
	pxTopOfStack--;
 28c:	8b 81       	ldd	r24, Y+3	; 0x03
 28e:	9c 81       	ldd	r25, Y+4	; 0x04
 290:	01 97       	sbiw	r24, 0x01	; 1
 292:	9c 83       	std	Y+4, r25	; 0x04
 294:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
 296:	eb 81       	ldd	r30, Y+3	; 0x03
 298:	fc 81       	ldd	r31, Y+4	; 0x04
 29a:	87 e2       	ldi	r24, 0x27	; 39
 29c:	80 83       	st	Z, r24
	pxTopOfStack--;
 29e:	8b 81       	ldd	r24, Y+3	; 0x03
 2a0:	9c 81       	ldd	r25, Y+4	; 0x04
 2a2:	01 97       	sbiw	r24, 0x01	; 1
 2a4:	9c 83       	std	Y+4, r25	; 0x04
 2a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
 2a8:	eb 81       	ldd	r30, Y+3	; 0x03
 2aa:	fc 81       	ldd	r31, Y+4	; 0x04
 2ac:	88 e2       	ldi	r24, 0x28	; 40
 2ae:	80 83       	st	Z, r24
	pxTopOfStack--;
 2b0:	8b 81       	ldd	r24, Y+3	; 0x03
 2b2:	9c 81       	ldd	r25, Y+4	; 0x04
 2b4:	01 97       	sbiw	r24, 0x01	; 1
 2b6:	9c 83       	std	Y+4, r25	; 0x04
 2b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
 2ba:	eb 81       	ldd	r30, Y+3	; 0x03
 2bc:	fc 81       	ldd	r31, Y+4	; 0x04
 2be:	89 e2       	ldi	r24, 0x29	; 41
 2c0:	80 83       	st	Z, r24
	pxTopOfStack--;
 2c2:	8b 81       	ldd	r24, Y+3	; 0x03
 2c4:	9c 81       	ldd	r25, Y+4	; 0x04
 2c6:	01 97       	sbiw	r24, 0x01	; 1
 2c8:	9c 83       	std	Y+4, r25	; 0x04
 2ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
 2cc:	eb 81       	ldd	r30, Y+3	; 0x03
 2ce:	fc 81       	ldd	r31, Y+4	; 0x04
 2d0:	80 e3       	ldi	r24, 0x30	; 48
 2d2:	80 83       	st	Z, r24
	pxTopOfStack--;
 2d4:	8b 81       	ldd	r24, Y+3	; 0x03
 2d6:	9c 81       	ldd	r25, Y+4	; 0x04
 2d8:	01 97       	sbiw	r24, 0x01	; 1
 2da:	9c 83       	std	Y+4, r25	; 0x04
 2dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
 2de:	eb 81       	ldd	r30, Y+3	; 0x03
 2e0:	fc 81       	ldd	r31, Y+4	; 0x04
 2e2:	81 e3       	ldi	r24, 0x31	; 49
 2e4:	80 83       	st	Z, r24
	pxTopOfStack--;
 2e6:	8b 81       	ldd	r24, Y+3	; 0x03
 2e8:	9c 81       	ldd	r25, Y+4	; 0x04
 2ea:	01 97       	sbiw	r24, 0x01	; 1
 2ec:	9c 83       	std	Y+4, r25	; 0x04
 2ee:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
 2f0:	8b 81       	ldd	r24, Y+3	; 0x03
 2f2:	9c 81       	ldd	r25, Y+4	; 0x04
}
 2f4:	28 96       	adiw	r28, 0x08	; 8
 2f6:	0f b6       	in	r0, 0x3f	; 63
 2f8:	f8 94       	cli
 2fa:	de bf       	out	0x3e, r29	; 62
 2fc:	0f be       	out	0x3f, r0	; 63
 2fe:	cd bf       	out	0x3d, r28	; 61
 300:	cf 91       	pop	r28
 302:	df 91       	pop	r29
 304:	08 95       	ret

Disassembly of section .text.xPortStartScheduler:

00000000 <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	0e 94 00 00 	call	0	; 0x0 <xPortStartScheduler>
   c:	a0 91 00 00 	lds	r26, 0x0000
  10:	b0 91 00 00 	lds	r27, 0x0000
  14:	cd 91       	ld	r28, X+
  16:	cd bf       	out	0x3d, r28	; 61
  18:	dd 91       	ld	r29, X+
  1a:	de bf       	out	0x3e, r29	; 62
  1c:	ff 91       	pop	r31
  1e:	ef 91       	pop	r30
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
  24:	bf 91       	pop	r27
  26:	af 91       	pop	r26
	pxTopOfStack--;
  28:	9f 91       	pop	r25
  2a:	8f 91       	pop	r24
  2c:	7f 91       	pop	r23
  2e:	6f 91       	pop	r22
  30:	5f 91       	pop	r21
	*pxTopOfStack = 0x22;
  32:	4f 91       	pop	r20
  34:	3f 91       	pop	r19
  36:	2f 91       	pop	r18
  38:	1f 91       	pop	r17
	pxTopOfStack--;
  3a:	0f 91       	pop	r16
  3c:	ff 90       	pop	r15
  3e:	ef 90       	pop	r14
  40:	df 90       	pop	r13
  42:	cf 90       	pop	r12
	*pxTopOfStack = 0x33;
  44:	bf 90       	pop	r11
  46:	af 90       	pop	r10
  48:	9f 90       	pop	r9
  4a:	8f 90       	pop	r8
	pxTopOfStack--;
  4c:	7f 90       	pop	r7
  4e:	6f 90       	pop	r6
  50:	5f 90       	pop	r5
  52:	4f 90       	pop	r4
  54:	3f 90       	pop	r3

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
  56:	2f 90       	pop	r2
  58:	1f 90       	pop	r1
  5a:	0f 90       	pop	r0
  5c:	0f be       	out	0x3f, r0	; 63
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  5e:	0f 90       	pop	r0
  60:	08 95       	ret
  62:	81 e0       	ldi	r24, 0x01	; 1
  64:	cf 91       	pop	r28
	pxTopOfStack--;
  66:	df 91       	pop	r29
  68:	08 95       	ret

Disassembly of section .text.vPortEndScheduler:

00000000 <vPortEndScheduler>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	cf 91       	pop	r28
   a:	df 91       	pop	r29
   c:	08 95       	ret

Disassembly of section .text.vPortYield:

00000000 <vPortYield>:
   0:	0f 92       	push	r0
   2:	0f b6       	in	r0, 0x3f	; 63
   4:	f8 94       	cli
   6:	0f 92       	push	r0
   8:	1f 92       	push	r1
   a:	11 24       	eor	r1, r1
   c:	2f 92       	push	r2
   e:	3f 92       	push	r3
  10:	4f 92       	push	r4
  12:	5f 92       	push	r5
  14:	6f 92       	push	r6
  16:	7f 92       	push	r7
  18:	8f 92       	push	r8
  1a:	9f 92       	push	r9
  1c:	af 92       	push	r10
  1e:	bf 92       	push	r11
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
  20:	cf 92       	push	r12
  22:	df 92       	push	r13
  24:	ef 92       	push	r14
  26:	ff 92       	push	r15
	pxTopOfStack--;
  28:	0f 93       	push	r16
  2a:	1f 93       	push	r17
  2c:	2f 93       	push	r18
  2e:	3f 93       	push	r19
  30:	4f 93       	push	r20
	*pxTopOfStack = 0x22;
  32:	5f 93       	push	r21
  34:	6f 93       	push	r22
  36:	7f 93       	push	r23
  38:	8f 93       	push	r24
	pxTopOfStack--;
  3a:	9f 93       	push	r25
  3c:	af 93       	push	r26
  3e:	bf 93       	push	r27
  40:	cf 93       	push	r28
  42:	df 93       	push	r29
	*pxTopOfStack = 0x33;
  44:	ef 93       	push	r30
  46:	ff 93       	push	r31
  48:	a0 91 00 00 	lds	r26, 0x0000
	pxTopOfStack--;
  4c:	b0 91 00 00 	lds	r27, 0x0000
  50:	0d b6       	in	r0, 0x3d	; 61
  52:	0d 92       	st	X+, r0
  54:	0e b6       	in	r0, 0x3e	; 62

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
  56:	0d 92       	st	X+, r0
  58:	0e 94 00 00 	call	0	; 0x0 <vPortYield>
  5c:	a0 91 00 00 	lds	r26, 0x0000
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  60:	b0 91 00 00 	lds	r27, 0x0000
  64:	cd 91       	ld	r28, X+
	pxTopOfStack--;
  66:	cd bf       	out	0x3d, r28	; 61
  68:	dd 91       	ld	r29, X+
  6a:	de bf       	out	0x3e, r29	; 62
  6c:	ff 91       	pop	r31
  6e:	ef 91       	pop	r30

	usAddress >>= 8;
  70:	df 91       	pop	r29
  72:	cf 91       	pop	r28
  74:	bf 91       	pop	r27
  76:	af 91       	pop	r26
  78:	9f 91       	pop	r25
  7a:	8f 91       	pop	r24
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  7c:	7f 91       	pop	r23
  7e:	6f 91       	pop	r22
  80:	5f 91       	pop	r21
  82:	4f 91       	pop	r20
	pxTopOfStack--;
  84:	3f 91       	pop	r19
  86:	2f 91       	pop	r18
  88:	1f 91       	pop	r17
  8a:	0f 91       	pop	r16
  8c:	ff 90       	pop	r15

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
  8e:	ef 90       	pop	r14
  90:	df 90       	pop	r13
  92:	cf 90       	pop	r12
	pxTopOfStack--;
  94:	bf 90       	pop	r11
  96:	af 90       	pop	r10
  98:	9f 90       	pop	r9
  9a:	8f 90       	pop	r8
  9c:	7f 90       	pop	r7
	*pxTopOfStack = portFLAGS_INT_ENABLED;
  9e:	6f 90       	pop	r6
  a0:	5f 90       	pop	r5
  a2:	4f 90       	pop	r4
  a4:	3f 90       	pop	r3
	pxTopOfStack--;
  a6:	2f 90       	pop	r2
  a8:	1f 90       	pop	r1
  aa:	0f 90       	pop	r0
  ac:	0f be       	out	0x3f, r0	; 63
  ae:	0f 90       	pop	r0


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
  b0:	08 95       	ret

Disassembly of section .text.vPortYieldFromTick:

00000000 <vPortYieldFromTick>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
   0:	0f 92       	push	r0
   2:	0f b6       	in	r0, 0x3f	; 63
   4:	f8 94       	cli
   6:	0f 92       	push	r0
   8:	1f 92       	push	r1
   a:	11 24       	eor	r1, r1
   c:	2f 92       	push	r2
   e:	3f 92       	push	r3
  10:	4f 92       	push	r4
  12:	5f 92       	push	r5
  14:	6f 92       	push	r6
  16:	7f 92       	push	r7
  18:	8f 92       	push	r8
  1a:	9f 92       	push	r9
  1c:	af 92       	push	r10
  1e:	bf 92       	push	r11
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
  20:	cf 92       	push	r12
  22:	df 92       	push	r13
  24:	ef 92       	push	r14
  26:	ff 92       	push	r15
	pxTopOfStack--;
  28:	0f 93       	push	r16
  2a:	1f 93       	push	r17
  2c:	2f 93       	push	r18
  2e:	3f 93       	push	r19
  30:	4f 93       	push	r20
	*pxTopOfStack = 0x22;
  32:	5f 93       	push	r21
  34:	6f 93       	push	r22
  36:	7f 93       	push	r23
  38:	8f 93       	push	r24
	pxTopOfStack--;
  3a:	9f 93       	push	r25
  3c:	af 93       	push	r26
  3e:	bf 93       	push	r27
  40:	cf 93       	push	r28
  42:	df 93       	push	r29
	*pxTopOfStack = 0x33;
  44:	ef 93       	push	r30
  46:	ff 93       	push	r31
  48:	a0 91 00 00 	lds	r26, 0x0000
	pxTopOfStack--;
  4c:	b0 91 00 00 	lds	r27, 0x0000
  50:	0d b6       	in	r0, 0x3d	; 61
  52:	0d 92       	st	X+, r0
  54:	0e b6       	in	r0, 0x3e	; 62

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
  56:	0d 92       	st	X+, r0
  58:	0e 94 00 00 	call	0	; 0x0 <vPortYieldFromTick>
  5c:	0e 94 00 00 	call	0	; 0x0 <vPortYieldFromTick>
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  60:	a0 91 00 00 	lds	r26, 0x0000
  64:	b0 91 00 00 	lds	r27, 0x0000
	pxTopOfStack--;
  68:	cd 91       	ld	r28, X+
  6a:	cd bf       	out	0x3d, r28	; 61
  6c:	dd 91       	ld	r29, X+
  6e:	de bf       	out	0x3e, r29	; 62

	usAddress >>= 8;
  70:	ff 91       	pop	r31
  72:	ef 91       	pop	r30
  74:	df 91       	pop	r29
  76:	cf 91       	pop	r28
  78:	bf 91       	pop	r27
  7a:	af 91       	pop	r26
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  7c:	9f 91       	pop	r25
  7e:	8f 91       	pop	r24
  80:	7f 91       	pop	r23
  82:	6f 91       	pop	r22
	pxTopOfStack--;
  84:	5f 91       	pop	r21
  86:	4f 91       	pop	r20
  88:	3f 91       	pop	r19
  8a:	2f 91       	pop	r18
  8c:	1f 91       	pop	r17

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
  8e:	0f 91       	pop	r16
  90:	ff 90       	pop	r15
  92:	ef 90       	pop	r14
	pxTopOfStack--;
  94:	df 90       	pop	r13
  96:	cf 90       	pop	r12
  98:	bf 90       	pop	r11
  9a:	af 90       	pop	r10
  9c:	9f 90       	pop	r9
	*pxTopOfStack = portFLAGS_INT_ENABLED;
  9e:	8f 90       	pop	r8
  a0:	7f 90       	pop	r7
  a2:	6f 90       	pop	r6
  a4:	5f 90       	pop	r5
	pxTopOfStack--;
  a6:	4f 90       	pop	r4
  a8:	3f 90       	pop	r3
  aa:	2f 90       	pop	r2
  ac:	1f 90       	pop	r1
  ae:	0f 90       	pop	r0


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
  b0:	0f be       	out	0x3f, r0	; 63
  b2:	0f 90       	pop	r0
  b4:	08 95       	ret

Disassembly of section .text.prvSetupTimerInterrupt:

00000000 <prvSetupTimerInterrupt>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvSetupTimerInterrupt+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <prvSetupTimerInterrupt+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <prvSetupTimerInterrupt+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	80 e8       	ldi	r24, 0x80	; 128
  10:	9e e3       	ldi	r25, 0x3E	; 62
  12:	a0 e0       	ldi	r26, 0x00	; 0
  14:	b0 e0       	ldi	r27, 0x00	; 0
  16:	8b 83       	std	Y+3, r24	; 0x03
  18:	9c 83       	std	Y+4, r25	; 0x04
  1a:	ad 83       	std	Y+5, r26	; 0x05
  1c:	be 83       	std	Y+6, r27	; 0x06
  1e:	8b 81       	ldd	r24, Y+3	; 0x03
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
  20:	9c 81       	ldd	r25, Y+4	; 0x04
  22:	ad 81       	ldd	r26, Y+5	; 0x05
  24:	be 81       	ldd	r27, Y+6	; 0x06
  26:	68 94       	set
	pxTopOfStack--;
  28:	15 f8       	bld	r1, 5
  2a:	b6 95       	lsr	r27
  2c:	a7 95       	ror	r26
  2e:	97 95       	ror	r25
  30:	87 95       	ror	r24
	*pxTopOfStack = 0x22;
  32:	16 94       	lsr	r1
  34:	01 f4       	brne	.+0      	; 0x36 <prvSetupTimerInterrupt+0x36>
  36:	8b 83       	std	Y+3, r24	; 0x03
  38:	9c 83       	std	Y+4, r25	; 0x04
	pxTopOfStack--;
  3a:	ad 83       	std	Y+5, r26	; 0x05
  3c:	be 83       	std	Y+6, r27	; 0x06
  3e:	8b 81       	ldd	r24, Y+3	; 0x03
  40:	9c 81       	ldd	r25, Y+4	; 0x04
  42:	ad 81       	ldd	r26, Y+5	; 0x05
	*pxTopOfStack = 0x33;
  44:	be 81       	ldd	r27, Y+6	; 0x06
  46:	01 97       	sbiw	r24, 0x01	; 1
  48:	a1 09       	sbc	r26, r1
  4a:	b1 09       	sbc	r27, r1
	pxTopOfStack--;
  4c:	8b 83       	std	Y+3, r24	; 0x03
  4e:	9c 83       	std	Y+4, r25	; 0x04
  50:	ad 83       	std	Y+5, r26	; 0x05
  52:	be 83       	std	Y+6, r27	; 0x06
  54:	8b 81       	ldd	r24, Y+3	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
  56:	89 83       	std	Y+1, r24	; 0x01
  58:	8b 81       	ldd	r24, Y+3	; 0x03
  5a:	9c 81       	ldd	r25, Y+4	; 0x04
  5c:	ad 81       	ldd	r26, Y+5	; 0x05
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  5e:	be 81       	ldd	r27, Y+6	; 0x06
  60:	89 2f       	mov	r24, r25
  62:	9a 2f       	mov	r25, r26
  64:	ab 2f       	mov	r26, r27
	pxTopOfStack--;
  66:	bb 27       	eor	r27, r27
  68:	8b 83       	std	Y+3, r24	; 0x03
  6a:	9c 83       	std	Y+4, r25	; 0x04
  6c:	ad 83       	std	Y+5, r26	; 0x05
  6e:	be 83       	std	Y+6, r27	; 0x06

	usAddress >>= 8;
  70:	8b 81       	ldd	r24, Y+3	; 0x03
  72:	8a 83       	std	Y+2, r24	; 0x02
  74:	eb e4       	ldi	r30, 0x4B	; 75
  76:	f0 e0       	ldi	r31, 0x00	; 0
  78:	8a 81       	ldd	r24, Y+2	; 0x02
  7a:	80 83       	st	Z, r24
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
  7c:	ea e4       	ldi	r30, 0x4A	; 74
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	89 81       	ldd	r24, Y+1	; 0x01
  82:	80 83       	st	Z, r24
	pxTopOfStack--;
  84:	8b e0       	ldi	r24, 0x0B	; 11
  86:	89 83       	std	Y+1, r24	; 0x01
  88:	ee e4       	ldi	r30, 0x4E	; 78
  8a:	f0 e0       	ldi	r31, 0x00	; 0
  8c:	89 81       	ldd	r24, Y+1	; 0x01

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
  8e:	80 83       	st	Z, r24
  90:	e9 e5       	ldi	r30, 0x59	; 89
  92:	f0 e0       	ldi	r31, 0x00	; 0
	pxTopOfStack--;
  94:	80 81       	ld	r24, Z
  96:	89 83       	std	Y+1, r24	; 0x01
  98:	89 81       	ldd	r24, Y+1	; 0x01
  9a:	80 61       	ori	r24, 0x10	; 16
  9c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = portFLAGS_INT_ENABLED;
  9e:	e9 e5       	ldi	r30, 0x59	; 89
  a0:	f0 e0       	ldi	r31, 0x00	; 0
  a2:	89 81       	ldd	r24, Y+1	; 0x01
  a4:	80 83       	st	Z, r24
	pxTopOfStack--;
  a6:	26 96       	adiw	r28, 0x06	; 6
  a8:	0f b6       	in	r0, 0x3f	; 63
  aa:	f8 94       	cli
  ac:	de bf       	out	0x3e, r29	; 62
  ae:	0f be       	out	0x3f, r0	; 63


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
  b0:	cd bf       	out	0x3d, r28	; 61
  b2:	cf 91       	pop	r28
  b4:	df 91       	pop	r29
	pxTopOfStack--;
  b6:	08 95       	ret

Disassembly of section .text.__vector_7:

00000000 <__vector_7>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
   0:	0e 94 00 00 	call	0	; 0x0 <__vector_7>
   4:	18 95       	reti

queue.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000011d0  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001424  00000000  00000000  00001204  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.xQueueCreate 00000152  00000000  00000000  00002628  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.xQueueGenericSend 0000013c  00000000  00000000  0000277a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.xQueueGenericSendFromISR 0000009a  00000000  00000000  000028b6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.xQueueGenericReceive 00000180  00000000  00000000  00002950  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.xQueueReceiveFromISR 0000009e  00000000  00000000  00002ad0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.uxQueueMessagesWaiting 00000030  00000000  00000000  00002b6e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.uxQueueMessagesWaitingFromISR 00000026  00000000  00000000  00002b9e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.vQueueDelete 0000002c  00000000  00000000  00002bc4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.prvCopyDataToQueue 0000012a  00000000  00000000  00002bf0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.prvCopyDataFromQueue 00000090  00000000  00000000  00002d1a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.prvUnlockQueue 000000a8  00000000  00000000  00002daa  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.prvIsQueueEmpty 00000038  00000000  00000000  00002e52  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.xQueueIsQueueEmptyFromISR 0000002e  00000000  00000000  00002e8a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text.prvIsQueueFull 0000003e  00000000  00000000  00002eb8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text.xQueueIsQueueFullFromISR 00000034  00000000  00000000  00002ef6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.xQueueCreate:

00000000 <xQueueCreate>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8f 83       	std	Y+7, r24	; 0x07
  16:	68 87       	std	Y+8, r22	; 0x08
  18:	1a 82       	std	Y+2, r1	; 0x02
  1a:	19 82       	std	Y+1, r1	; 0x01
  1c:	8f 81       	ldd	r24, Y+7	; 0x07
  1e:	88 23       	and	r24, r24
  20:	01 f4       	brne	.+0      	; 0x22 <xQueueCreate+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <xQueueCreate+0x24>
  24:	8f e1       	ldi	r24, 0x1F	; 31

	return xReturn;
  26:	90 e0       	ldi	r25, 0x00	; 0
}
  28:	0e 94 00 00 	call	0	; 0x0 <xQueueCreate>
  2c:	9e 83       	std	Y+6, r25	; 0x06
  2e:	8d 83       	std	Y+5, r24	; 0x05
  30:	8d 81       	ldd	r24, Y+5	; 0x05
  32:	9e 81       	ldd	r25, Y+6	; 0x06
  34:	00 97       	sbiw	r24, 0x00	; 0
  36:	01 f4       	brne	.+0      	; 0x38 <xQueueCreate+0x38>
  38:	00 c0       	rjmp	.+0      	; 0x3a <xQueueCreate+0x3a>
  3a:	8f 81       	ldd	r24, Y+7	; 0x07
  3c:	28 2f       	mov	r18, r24
  3e:	30 e0       	ldi	r19, 0x00	; 0
  40:	88 85       	ldd	r24, Y+8	; 0x08
  42:	88 2f       	mov	r24, r24
  44:	90 e0       	ldi	r25, 0x00	; 0
  46:	ac 01       	movw	r20, r24
  48:	24 9f       	mul	r18, r20
  4a:	c0 01       	movw	r24, r0
  4c:	25 9f       	mul	r18, r21
  4e:	90 0d       	add	r25, r0
  50:	34 9f       	mul	r19, r20
  52:	90 0d       	add	r25, r0
  54:	11 24       	eor	r1, r1
  56:	01 96       	adiw	r24, 0x01	; 1
  58:	9c 83       	std	Y+4, r25	; 0x04
  5a:	8b 83       	std	Y+3, r24	; 0x03
  5c:	8b 81       	ldd	r24, Y+3	; 0x03
  5e:	9c 81       	ldd	r25, Y+4	; 0x04
  60:	0e 94 00 00 	call	0	; 0x0 <xQueueCreate>
  64:	ed 81       	ldd	r30, Y+5	; 0x05
  66:	fe 81       	ldd	r31, Y+6	; 0x06
  68:	91 83       	std	Z+1, r25	; 0x01
  6a:	80 83       	st	Z, r24
  6c:	ed 81       	ldd	r30, Y+5	; 0x05
  6e:	fe 81       	ldd	r31, Y+6	; 0x06
  70:	80 81       	ld	r24, Z
  72:	91 81       	ldd	r25, Z+1	; 0x01
  74:	00 97       	sbiw	r24, 0x00	; 0
  76:	01 f4       	brne	.+0      	; 0x78 <xQueueCreate+0x78>
  78:	00 c0       	rjmp	.+0      	; 0x7a <xQueueCreate+0x7a>
  7a:	ed 81       	ldd	r30, Y+5	; 0x05
  7c:	fe 81       	ldd	r31, Y+6	; 0x06
  7e:	40 81       	ld	r20, Z
  80:	51 81       	ldd	r21, Z+1	; 0x01
  82:	8f 81       	ldd	r24, Y+7	; 0x07
  84:	28 2f       	mov	r18, r24
  86:	30 e0       	ldi	r19, 0x00	; 0
  88:	88 85       	ldd	r24, Y+8	; 0x08
  8a:	88 2f       	mov	r24, r24
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	bc 01       	movw	r22, r24
  90:	26 9f       	mul	r18, r22
  92:	c0 01       	movw	r24, r0
  94:	27 9f       	mul	r18, r23
  96:	90 0d       	add	r25, r0
  98:	36 9f       	mul	r19, r22
  9a:	90 0d       	add	r25, r0
  9c:	11 24       	eor	r1, r1
  9e:	84 0f       	add	r24, r20
  a0:	95 1f       	adc	r25, r21
  a2:	ed 81       	ldd	r30, Y+5	; 0x05
  a4:	fe 81       	ldd	r31, Y+6	; 0x06
  a6:	93 83       	std	Z+3, r25	; 0x03
  a8:	82 83       	std	Z+2, r24	; 0x02
  aa:	ed 81       	ldd	r30, Y+5	; 0x05
  ac:	fe 81       	ldd	r31, Y+6	; 0x06
  ae:	12 8e       	std	Z+26, r1	; 0x1a
  b0:	ed 81       	ldd	r30, Y+5	; 0x05
  b2:	fe 81       	ldd	r31, Y+6	; 0x06
  b4:	80 81       	ld	r24, Z
  b6:	91 81       	ldd	r25, Z+1	; 0x01
  b8:	ed 81       	ldd	r30, Y+5	; 0x05
  ba:	fe 81       	ldd	r31, Y+6	; 0x06
  bc:	95 83       	std	Z+5, r25	; 0x05
  be:	84 83       	std	Z+4, r24	; 0x04
  c0:	ed 81       	ldd	r30, Y+5	; 0x05
  c2:	fe 81       	ldd	r31, Y+6	; 0x06
  c4:	40 81       	ld	r20, Z
  c6:	51 81       	ldd	r21, Z+1	; 0x01
  c8:	8f 81       	ldd	r24, Y+7	; 0x07
  ca:	88 2f       	mov	r24, r24
  cc:	90 e0       	ldi	r25, 0x00	; 0
  ce:	9c 01       	movw	r18, r24
  d0:	21 50       	subi	r18, 0x01	; 1
  d2:	30 40       	sbci	r19, 0x00	; 0
  d4:	88 85       	ldd	r24, Y+8	; 0x08
  d6:	88 2f       	mov	r24, r24
  d8:	90 e0       	ldi	r25, 0x00	; 0
  da:	bc 01       	movw	r22, r24
  dc:	26 9f       	mul	r18, r22
  de:	c0 01       	movw	r24, r0
  e0:	27 9f       	mul	r18, r23
  e2:	90 0d       	add	r25, r0
  e4:	36 9f       	mul	r19, r22
  e6:	90 0d       	add	r25, r0
  e8:	11 24       	eor	r1, r1
  ea:	84 0f       	add	r24, r20
  ec:	95 1f       	adc	r25, r21
  ee:	ed 81       	ldd	r30, Y+5	; 0x05
  f0:	fe 81       	ldd	r31, Y+6	; 0x06
  f2:	97 83       	std	Z+7, r25	; 0x07
  f4:	86 83       	std	Z+6, r24	; 0x06
  f6:	ed 81       	ldd	r30, Y+5	; 0x05
  f8:	fe 81       	ldd	r31, Y+6	; 0x06
  fa:	8f 81       	ldd	r24, Y+7	; 0x07
  fc:	83 8f       	std	Z+27, r24	; 0x1b
  fe:	ed 81       	ldd	r30, Y+5	; 0x05
 100:	fe 81       	ldd	r31, Y+6	; 0x06
 102:	88 85       	ldd	r24, Y+8	; 0x08
 104:	84 8f       	std	Z+28, r24	; 0x1c
 106:	ed 81       	ldd	r30, Y+5	; 0x05
 108:	fe 81       	ldd	r31, Y+6	; 0x06
 10a:	8f ef       	ldi	r24, 0xFF	; 255
 10c:	85 8f       	std	Z+29, r24	; 0x1d
 10e:	ed 81       	ldd	r30, Y+5	; 0x05
 110:	fe 81       	ldd	r31, Y+6	; 0x06
 112:	8f ef       	ldi	r24, 0xFF	; 255
 114:	86 8f       	std	Z+30, r24	; 0x1e
 116:	8d 81       	ldd	r24, Y+5	; 0x05
 118:	9e 81       	ldd	r25, Y+6	; 0x06
 11a:	08 96       	adiw	r24, 0x08	; 8
 11c:	0e 94 00 00 	call	0	; 0x0 <xQueueCreate>
 120:	8d 81       	ldd	r24, Y+5	; 0x05
 122:	9e 81       	ldd	r25, Y+6	; 0x06
 124:	41 96       	adiw	r24, 0x11	; 17
 126:	0e 94 00 00 	call	0	; 0x0 <xQueueCreate>
 12a:	8d 81       	ldd	r24, Y+5	; 0x05
 12c:	9e 81       	ldd	r25, Y+6	; 0x06
 12e:	9a 83       	std	Y+2, r25	; 0x02
 130:	89 83       	std	Y+1, r24	; 0x01
 132:	00 c0       	rjmp	.+0      	; 0x134 <xQueueCreate+0x134>
 134:	8d 81       	ldd	r24, Y+5	; 0x05
 136:	9e 81       	ldd	r25, Y+6	; 0x06
 138:	0e 94 00 00 	call	0	; 0x0 <xQueueCreate>
 13c:	89 81       	ldd	r24, Y+1	; 0x01
 13e:	9a 81       	ldd	r25, Y+2	; 0x02
 140:	28 96       	adiw	r28, 0x08	; 8
 142:	0f b6       	in	r0, 0x3f	; 63
 144:	f8 94       	cli
 146:	de bf       	out	0x3e, r29	; 62
 148:	0f be       	out	0x3f, r0	; 63
 14a:	cd bf       	out	0x3d, r28	; 61
 14c:	cf 91       	pop	r28
 14e:	df 91       	pop	r29
 150:	08 95       	ret

Disassembly of section .text.xQueueGenericSend:

00000000 <xQueueGenericSend>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2c 97       	sbiw	r28, 0x0c	; 12
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9e 83       	std	Y+6, r25	; 0x06
  16:	8d 83       	std	Y+5, r24	; 0x05
  18:	78 87       	std	Y+8, r23	; 0x08
  1a:	6f 83       	std	Y+7, r22	; 0x07
  1c:	5a 87       	std	Y+10, r21	; 0x0a
  1e:	49 87       	std	Y+9, r20	; 0x09
  20:	2b 87       	std	Y+11, r18	; 0x0b
  22:	19 82       	std	Y+1, r1	; 0x01
  24:	0f b6       	in	r0, 0x3f	; 63

	return xReturn;
  26:	f8 94       	cli
}
  28:	0f 92       	push	r0
  2a:	ed 81       	ldd	r30, Y+5	; 0x05
  2c:	fe 81       	ldd	r31, Y+6	; 0x06
  2e:	92 8d       	ldd	r25, Z+26	; 0x1a
  30:	ed 81       	ldd	r30, Y+5	; 0x05
  32:	fe 81       	ldd	r31, Y+6	; 0x06
  34:	83 8d       	ldd	r24, Z+27	; 0x1b
  36:	98 17       	cp	r25, r24
  38:	00 f4       	brcc	.+0      	; 0x3a <xQueueGenericSend+0x3a>
  3a:	8d 81       	ldd	r24, Y+5	; 0x05
  3c:	9e 81       	ldd	r25, Y+6	; 0x06
  3e:	2f 81       	ldd	r18, Y+7	; 0x07
  40:	38 85       	ldd	r19, Y+8	; 0x08
  42:	b9 01       	movw	r22, r18
  44:	4b 85       	ldd	r20, Y+11	; 0x0b
  46:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  4a:	ed 81       	ldd	r30, Y+5	; 0x05
  4c:	fe 81       	ldd	r31, Y+6	; 0x06
  4e:	81 89       	ldd	r24, Z+17	; 0x11
  50:	88 23       	and	r24, r24
  52:	01 f0       	breq	.+0      	; 0x54 <xQueueGenericSend+0x54>
  54:	8d 81       	ldd	r24, Y+5	; 0x05
  56:	9e 81       	ldd	r25, Y+6	; 0x06
  58:	41 96       	adiw	r24, 0x11	; 17
  5a:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  5e:	81 30       	cpi	r24, 0x01	; 1
  60:	01 f4       	brne	.+0      	; 0x62 <xQueueGenericSend+0x62>
  62:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  66:	0f 90       	pop	r0
  68:	0f be       	out	0x3f, r0	; 63
  6a:	81 e0       	ldi	r24, 0x01	; 1
  6c:	8c 87       	std	Y+12, r24	; 0x0c
  6e:	00 c0       	rjmp	.+0      	; 0x70 <xQueueGenericSend+0x70>
  70:	89 85       	ldd	r24, Y+9	; 0x09
  72:	9a 85       	ldd	r25, Y+10	; 0x0a
  74:	00 97       	sbiw	r24, 0x00	; 0
  76:	01 f4       	brne	.+0      	; 0x78 <xQueueGenericSend+0x78>
  78:	0f 90       	pop	r0
  7a:	0f be       	out	0x3f, r0	; 63
  7c:	1c 86       	std	Y+12, r1	; 0x0c
  7e:	00 c0       	rjmp	.+0      	; 0x80 <xQueueGenericSend+0x80>
  80:	89 81       	ldd	r24, Y+1	; 0x01
  82:	88 23       	and	r24, r24
  84:	01 f4       	brne	.+0      	; 0x86 <xQueueGenericSend+0x86>
  86:	ce 01       	movw	r24, r28
  88:	02 96       	adiw	r24, 0x02	; 2
  8a:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  8e:	81 e0       	ldi	r24, 0x01	; 1
  90:	89 83       	std	Y+1, r24	; 0x01
  92:	0f 90       	pop	r0
  94:	0f be       	out	0x3f, r0	; 63
  96:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  9a:	0f b6       	in	r0, 0x3f	; 63
  9c:	f8 94       	cli
  9e:	0f 92       	push	r0
  a0:	ed 81       	ldd	r30, Y+5	; 0x05
  a2:	fe 81       	ldd	r31, Y+6	; 0x06
  a4:	85 8d       	ldd	r24, Z+29	; 0x1d
  a6:	8f 3f       	cpi	r24, 0xFF	; 255
  a8:	01 f4       	brne	.+0      	; 0xaa <xQueueGenericSend+0xaa>
  aa:	ed 81       	ldd	r30, Y+5	; 0x05
  ac:	fe 81       	ldd	r31, Y+6	; 0x06
  ae:	15 8e       	std	Z+29, r1	; 0x1d
  b0:	ed 81       	ldd	r30, Y+5	; 0x05
  b2:	fe 81       	ldd	r31, Y+6	; 0x06
  b4:	86 8d       	ldd	r24, Z+30	; 0x1e
  b6:	8f 3f       	cpi	r24, 0xFF	; 255
  b8:	01 f4       	brne	.+0      	; 0xba <xQueueGenericSend+0xba>
  ba:	ed 81       	ldd	r30, Y+5	; 0x05
  bc:	fe 81       	ldd	r31, Y+6	; 0x06
  be:	16 8e       	std	Z+30, r1	; 0x1e
  c0:	0f 90       	pop	r0
  c2:	0f be       	out	0x3f, r0	; 63
  c4:	ce 01       	movw	r24, r28
  c6:	02 96       	adiw	r24, 0x02	; 2
  c8:	9e 01       	movw	r18, r28
  ca:	27 5f       	subi	r18, 0xF7	; 247
  cc:	3f 4f       	sbci	r19, 0xFF	; 255
  ce:	b9 01       	movw	r22, r18
  d0:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  d4:	88 23       	and	r24, r24
  d6:	01 f4       	brne	.+0      	; 0xd8 <xQueueGenericSend+0xd8>
  d8:	8d 81       	ldd	r24, Y+5	; 0x05
  da:	9e 81       	ldd	r25, Y+6	; 0x06
  dc:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  e0:	88 23       	and	r24, r24
  e2:	01 f0       	breq	.+0      	; 0xe4 <xQueueGenericSend+0xe4>
  e4:	8d 81       	ldd	r24, Y+5	; 0x05
  e6:	9e 81       	ldd	r25, Y+6	; 0x06
  e8:	08 96       	adiw	r24, 0x08	; 8
  ea:	29 85       	ldd	r18, Y+9	; 0x09
  ec:	3a 85       	ldd	r19, Y+10	; 0x0a
  ee:	b9 01       	movw	r22, r18
  f0:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  f4:	8d 81       	ldd	r24, Y+5	; 0x05
  f6:	9e 81       	ldd	r25, Y+6	; 0x06
  f8:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  fc:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 100:	88 23       	and	r24, r24
 102:	01 f0       	breq	.+0      	; 0x104 <xQueueGenericSend+0x104>
 104:	00 c0       	rjmp	.+0      	; 0x106 <xQueueGenericSend+0x106>
 106:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <xQueueGenericSend+0x10c>
 10c:	8d 81       	ldd	r24, Y+5	; 0x05
 10e:	9e 81       	ldd	r25, Y+6	; 0x06
 110:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 114:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 118:	00 c0       	rjmp	.+0      	; 0x11a <xQueueGenericSend+0x11a>
 11a:	8d 81       	ldd	r24, Y+5	; 0x05
 11c:	9e 81       	ldd	r25, Y+6	; 0x06
 11e:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 122:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 126:	1c 86       	std	Y+12, r1	; 0x0c
 128:	8c 85       	ldd	r24, Y+12	; 0x0c
 12a:	2c 96       	adiw	r28, 0x0c	; 12
 12c:	0f b6       	in	r0, 0x3f	; 63
 12e:	f8 94       	cli
 130:	de bf       	out	0x3e, r29	; 62
 132:	0f be       	out	0x3f, r0	; 63
 134:	cd bf       	out	0x3d, r28	; 61
 136:	cf 91       	pop	r28
 138:	df 91       	pop	r29
 13a:	08 95       	ret

Disassembly of section .text.xQueueGenericSendFromISR:

00000000 <xQueueGenericSendFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	29 97       	sbiw	r28, 0x09	; 9
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9c 83       	std	Y+4, r25	; 0x04
  16:	8b 83       	std	Y+3, r24	; 0x03
  18:	7e 83       	std	Y+6, r23	; 0x06
  1a:	6d 83       	std	Y+5, r22	; 0x05
  1c:	58 87       	std	Y+8, r21	; 0x08
  1e:	4f 83       	std	Y+7, r20	; 0x07
  20:	29 87       	std	Y+9, r18	; 0x09
  22:	19 82       	std	Y+1, r1	; 0x01
  24:	eb 81       	ldd	r30, Y+3	; 0x03

	return xReturn;
  26:	fc 81       	ldd	r31, Y+4	; 0x04
}
  28:	92 8d       	ldd	r25, Z+26	; 0x1a
  2a:	eb 81       	ldd	r30, Y+3	; 0x03
  2c:	fc 81       	ldd	r31, Y+4	; 0x04
  2e:	83 8d       	ldd	r24, Z+27	; 0x1b
  30:	98 17       	cp	r25, r24
  32:	00 f4       	brcc	.+0      	; 0x34 <xQueueGenericSendFromISR+0x34>
  34:	8b 81       	ldd	r24, Y+3	; 0x03
  36:	9c 81       	ldd	r25, Y+4	; 0x04
  38:	2d 81       	ldd	r18, Y+5	; 0x05
  3a:	3e 81       	ldd	r19, Y+6	; 0x06
  3c:	b9 01       	movw	r22, r18
  3e:	49 85       	ldd	r20, Y+9	; 0x09
  40:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSendFromISR>
  44:	eb 81       	ldd	r30, Y+3	; 0x03
  46:	fc 81       	ldd	r31, Y+4	; 0x04
  48:	86 8d       	ldd	r24, Z+30	; 0x1e
  4a:	8f 3f       	cpi	r24, 0xFF	; 255
  4c:	01 f4       	brne	.+0      	; 0x4e <xQueueGenericSendFromISR+0x4e>
  4e:	eb 81       	ldd	r30, Y+3	; 0x03
  50:	fc 81       	ldd	r31, Y+4	; 0x04
  52:	81 89       	ldd	r24, Z+17	; 0x11
  54:	88 23       	and	r24, r24
  56:	01 f0       	breq	.+0      	; 0x58 <xQueueGenericSendFromISR+0x58>
  58:	8b 81       	ldd	r24, Y+3	; 0x03
  5a:	9c 81       	ldd	r25, Y+4	; 0x04
  5c:	41 96       	adiw	r24, 0x11	; 17
  5e:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSendFromISR>
  62:	88 23       	and	r24, r24
  64:	01 f0       	breq	.+0      	; 0x66 <xQueueGenericSendFromISR+0x66>
  66:	ef 81       	ldd	r30, Y+7	; 0x07
  68:	f8 85       	ldd	r31, Y+8	; 0x08
  6a:	81 e0       	ldi	r24, 0x01	; 1
  6c:	80 83       	st	Z, r24
  6e:	00 c0       	rjmp	.+0      	; 0x70 <xQueueGenericSendFromISR+0x70>
  70:	eb 81       	ldd	r30, Y+3	; 0x03
  72:	fc 81       	ldd	r31, Y+4	; 0x04
  74:	86 8d       	ldd	r24, Z+30	; 0x1e
  76:	8f 5f       	subi	r24, 0xFF	; 255
  78:	eb 81       	ldd	r30, Y+3	; 0x03
  7a:	fc 81       	ldd	r31, Y+4	; 0x04
  7c:	86 8f       	std	Z+30, r24	; 0x1e
  7e:	81 e0       	ldi	r24, 0x01	; 1
  80:	8a 83       	std	Y+2, r24	; 0x02
  82:	00 c0       	rjmp	.+0      	; 0x84 <xQueueGenericSendFromISR+0x84>
  84:	1a 82       	std	Y+2, r1	; 0x02
  86:	8a 81       	ldd	r24, Y+2	; 0x02
  88:	29 96       	adiw	r28, 0x09	; 9
  8a:	0f b6       	in	r0, 0x3f	; 63
  8c:	f8 94       	cli
  8e:	de bf       	out	0x3e, r29	; 62
  90:	0f be       	out	0x3f, r0	; 63
  92:	cd bf       	out	0x3d, r28	; 61
  94:	cf 91       	pop	r28
  96:	df 91       	pop	r29
  98:	08 95       	ret

Disassembly of section .text.xQueueGenericReceive:

00000000 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2e 97       	sbiw	r28, 0x0e	; 14
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	98 87       	std	Y+8, r25	; 0x08
  16:	8f 83       	std	Y+7, r24	; 0x07
  18:	7a 87       	std	Y+10, r23	; 0x0a
  1a:	69 87       	std	Y+9, r22	; 0x09
  1c:	5c 87       	std	Y+12, r21	; 0x0c
  1e:	4b 87       	std	Y+11, r20	; 0x0b
  20:	2d 87       	std	Y+13, r18	; 0x0d
  22:	1b 82       	std	Y+3, r1	; 0x03
  24:	0f b6       	in	r0, 0x3f	; 63

	return xReturn;
  26:	f8 94       	cli
}
  28:	0f 92       	push	r0
  2a:	ef 81       	ldd	r30, Y+7	; 0x07
  2c:	f8 85       	ldd	r31, Y+8	; 0x08
  2e:	82 8d       	ldd	r24, Z+26	; 0x1a
  30:	88 23       	and	r24, r24
  32:	01 f4       	brne	.+0      	; 0x34 <xQueueGenericReceive+0x34>
  34:	00 c0       	rjmp	.+0      	; 0x36 <xQueueGenericReceive+0x36>
  36:	ef 81       	ldd	r30, Y+7	; 0x07
  38:	f8 85       	ldd	r31, Y+8	; 0x08
  3a:	86 81       	ldd	r24, Z+6	; 0x06
  3c:	97 81       	ldd	r25, Z+7	; 0x07
  3e:	9a 83       	std	Y+2, r25	; 0x02
  40:	89 83       	std	Y+1, r24	; 0x01
  42:	8f 81       	ldd	r24, Y+7	; 0x07
  44:	98 85       	ldd	r25, Y+8	; 0x08
  46:	29 85       	ldd	r18, Y+9	; 0x09
  48:	3a 85       	ldd	r19, Y+10	; 0x0a
  4a:	b9 01       	movw	r22, r18
  4c:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
  50:	8d 85       	ldd	r24, Y+13	; 0x0d
  52:	88 23       	and	r24, r24
  54:	01 f4       	brne	.+0      	; 0x56 <xQueueGenericReceive+0x56>
  56:	ef 81       	ldd	r30, Y+7	; 0x07
  58:	f8 85       	ldd	r31, Y+8	; 0x08
  5a:	82 8d       	ldd	r24, Z+26	; 0x1a
  5c:	81 50       	subi	r24, 0x01	; 1
  5e:	ef 81       	ldd	r30, Y+7	; 0x07
  60:	f8 85       	ldd	r31, Y+8	; 0x08
  62:	82 8f       	std	Z+26, r24	; 0x1a
  64:	ef 81       	ldd	r30, Y+7	; 0x07
  66:	f8 85       	ldd	r31, Y+8	; 0x08
  68:	80 85       	ldd	r24, Z+8	; 0x08
  6a:	88 23       	and	r24, r24
  6c:	01 f0       	breq	.+0      	; 0x6e <xQueueGenericReceive+0x6e>
  6e:	8f 81       	ldd	r24, Y+7	; 0x07
  70:	98 85       	ldd	r25, Y+8	; 0x08
  72:	08 96       	adiw	r24, 0x08	; 8
  74:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
  78:	81 30       	cpi	r24, 0x01	; 1
  7a:	01 f4       	brne	.+0      	; 0x7c <xQueueGenericReceive+0x7c>
  7c:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
  80:	00 c0       	rjmp	.+0      	; 0x82 <xQueueGenericReceive+0x82>
  82:	ef 81       	ldd	r30, Y+7	; 0x07
  84:	f8 85       	ldd	r31, Y+8	; 0x08
  86:	89 81       	ldd	r24, Y+1	; 0x01
  88:	9a 81       	ldd	r25, Y+2	; 0x02
  8a:	97 83       	std	Z+7, r25	; 0x07
  8c:	86 83       	std	Z+6, r24	; 0x06
  8e:	ef 81       	ldd	r30, Y+7	; 0x07
  90:	f8 85       	ldd	r31, Y+8	; 0x08
  92:	81 89       	ldd	r24, Z+17	; 0x11
  94:	88 23       	and	r24, r24
  96:	01 f0       	breq	.+0      	; 0x98 <xQueueGenericReceive+0x98>
  98:	8f 81       	ldd	r24, Y+7	; 0x07
  9a:	98 85       	ldd	r25, Y+8	; 0x08
  9c:	41 96       	adiw	r24, 0x11	; 17
  9e:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
  a2:	88 23       	and	r24, r24
  a4:	01 f0       	breq	.+0      	; 0xa6 <xQueueGenericReceive+0xa6>
  a6:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
  aa:	0f 90       	pop	r0
  ac:	0f be       	out	0x3f, r0	; 63
  ae:	81 e0       	ldi	r24, 0x01	; 1
  b0:	8e 87       	std	Y+14, r24	; 0x0e
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <xQueueGenericReceive+0xb4>
  b4:	8b 85       	ldd	r24, Y+11	; 0x0b
  b6:	9c 85       	ldd	r25, Y+12	; 0x0c
  b8:	00 97       	sbiw	r24, 0x00	; 0
  ba:	01 f4       	brne	.+0      	; 0xbc <xQueueGenericReceive+0xbc>
  bc:	0f 90       	pop	r0
  be:	0f be       	out	0x3f, r0	; 63
  c0:	1e 86       	std	Y+14, r1	; 0x0e
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <xQueueGenericReceive+0xc4>
  c4:	8b 81       	ldd	r24, Y+3	; 0x03
  c6:	88 23       	and	r24, r24
  c8:	01 f4       	brne	.+0      	; 0xca <xQueueGenericReceive+0xca>
  ca:	ce 01       	movw	r24, r28
  cc:	04 96       	adiw	r24, 0x04	; 4
  ce:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	8b 83       	std	Y+3, r24	; 0x03
  d6:	0f 90       	pop	r0
  d8:	0f be       	out	0x3f, r0	; 63
  da:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
  de:	0f b6       	in	r0, 0x3f	; 63
  e0:	f8 94       	cli
  e2:	0f 92       	push	r0
  e4:	ef 81       	ldd	r30, Y+7	; 0x07
  e6:	f8 85       	ldd	r31, Y+8	; 0x08
  e8:	85 8d       	ldd	r24, Z+29	; 0x1d
  ea:	8f 3f       	cpi	r24, 0xFF	; 255
  ec:	01 f4       	brne	.+0      	; 0xee <xQueueGenericReceive+0xee>
  ee:	ef 81       	ldd	r30, Y+7	; 0x07
  f0:	f8 85       	ldd	r31, Y+8	; 0x08
  f2:	15 8e       	std	Z+29, r1	; 0x1d
  f4:	ef 81       	ldd	r30, Y+7	; 0x07
  f6:	f8 85       	ldd	r31, Y+8	; 0x08
  f8:	86 8d       	ldd	r24, Z+30	; 0x1e
  fa:	8f 3f       	cpi	r24, 0xFF	; 255
  fc:	01 f4       	brne	.+0      	; 0xfe <xQueueGenericReceive+0xfe>
  fe:	ef 81       	ldd	r30, Y+7	; 0x07
 100:	f8 85       	ldd	r31, Y+8	; 0x08
 102:	16 8e       	std	Z+30, r1	; 0x1e
 104:	0f 90       	pop	r0
 106:	0f be       	out	0x3f, r0	; 63
 108:	ce 01       	movw	r24, r28
 10a:	04 96       	adiw	r24, 0x04	; 4
 10c:	9e 01       	movw	r18, r28
 10e:	25 5f       	subi	r18, 0xF5	; 245
 110:	3f 4f       	sbci	r19, 0xFF	; 255
 112:	b9 01       	movw	r22, r18
 114:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 118:	88 23       	and	r24, r24
 11a:	01 f4       	brne	.+0      	; 0x11c <xQueueGenericReceive+0x11c>
 11c:	8f 81       	ldd	r24, Y+7	; 0x07
 11e:	98 85       	ldd	r25, Y+8	; 0x08
 120:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 124:	88 23       	and	r24, r24
 126:	01 f0       	breq	.+0      	; 0x128 <xQueueGenericReceive+0x128>
 128:	8f 81       	ldd	r24, Y+7	; 0x07
 12a:	98 85       	ldd	r25, Y+8	; 0x08
 12c:	41 96       	adiw	r24, 0x11	; 17
 12e:	2b 85       	ldd	r18, Y+11	; 0x0b
 130:	3c 85       	ldd	r19, Y+12	; 0x0c
 132:	b9 01       	movw	r22, r18
 134:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 138:	8f 81       	ldd	r24, Y+7	; 0x07
 13a:	98 85       	ldd	r25, Y+8	; 0x08
 13c:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 140:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 144:	88 23       	and	r24, r24
 146:	01 f0       	breq	.+0      	; 0x148 <xQueueGenericReceive+0x148>
 148:	00 c0       	rjmp	.+0      	; 0x14a <xQueueGenericReceive+0x14a>
 14a:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 14e:	00 c0       	rjmp	.+0      	; 0x150 <xQueueGenericReceive+0x150>
 150:	8f 81       	ldd	r24, Y+7	; 0x07
 152:	98 85       	ldd	r25, Y+8	; 0x08
 154:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 158:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 15c:	00 c0       	rjmp	.+0      	; 0x15e <xQueueGenericReceive+0x15e>
 15e:	8f 81       	ldd	r24, Y+7	; 0x07
 160:	98 85       	ldd	r25, Y+8	; 0x08
 162:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 166:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReceive>
 16a:	1e 86       	std	Y+14, r1	; 0x0e
 16c:	8e 85       	ldd	r24, Y+14	; 0x0e
 16e:	2e 96       	adiw	r28, 0x0e	; 14
 170:	0f b6       	in	r0, 0x3f	; 63
 172:	f8 94       	cli
 174:	de bf       	out	0x3e, r29	; 62
 176:	0f be       	out	0x3f, r0	; 63
 178:	cd bf       	out	0x3d, r28	; 61
 17a:	cf 91       	pop	r28
 17c:	df 91       	pop	r29
 17e:	08 95       	ret

Disassembly of section .text.xQueueReceiveFromISR:

00000000 <xQueueReceiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9c 83       	std	Y+4, r25	; 0x04
  16:	8b 83       	std	Y+3, r24	; 0x03
  18:	7e 83       	std	Y+6, r23	; 0x06
  1a:	6d 83       	std	Y+5, r22	; 0x05
  1c:	58 87       	std	Y+8, r21	; 0x08
  1e:	4f 83       	std	Y+7, r20	; 0x07
  20:	19 82       	std	Y+1, r1	; 0x01
  22:	eb 81       	ldd	r30, Y+3	; 0x03
  24:	fc 81       	ldd	r31, Y+4	; 0x04

	return xReturn;
  26:	82 8d       	ldd	r24, Z+26	; 0x1a
}
  28:	88 23       	and	r24, r24
  2a:	01 f0       	breq	.+0      	; 0x2c <xQueueReceiveFromISR+0x2c>
  2c:	8b 81       	ldd	r24, Y+3	; 0x03
  2e:	9c 81       	ldd	r25, Y+4	; 0x04
  30:	2d 81       	ldd	r18, Y+5	; 0x05
  32:	3e 81       	ldd	r19, Y+6	; 0x06
  34:	b9 01       	movw	r22, r18
  36:	0e 94 00 00 	call	0	; 0x0 <xQueueReceiveFromISR>
  3a:	eb 81       	ldd	r30, Y+3	; 0x03
  3c:	fc 81       	ldd	r31, Y+4	; 0x04
  3e:	82 8d       	ldd	r24, Z+26	; 0x1a
  40:	81 50       	subi	r24, 0x01	; 1
  42:	eb 81       	ldd	r30, Y+3	; 0x03
  44:	fc 81       	ldd	r31, Y+4	; 0x04
  46:	82 8f       	std	Z+26, r24	; 0x1a
  48:	eb 81       	ldd	r30, Y+3	; 0x03
  4a:	fc 81       	ldd	r31, Y+4	; 0x04
  4c:	85 8d       	ldd	r24, Z+29	; 0x1d
  4e:	8f 3f       	cpi	r24, 0xFF	; 255
  50:	01 f4       	brne	.+0      	; 0x52 <xQueueReceiveFromISR+0x52>
  52:	eb 81       	ldd	r30, Y+3	; 0x03
  54:	fc 81       	ldd	r31, Y+4	; 0x04
  56:	80 85       	ldd	r24, Z+8	; 0x08
  58:	88 23       	and	r24, r24
  5a:	01 f0       	breq	.+0      	; 0x5c <xQueueReceiveFromISR+0x5c>
  5c:	8b 81       	ldd	r24, Y+3	; 0x03
  5e:	9c 81       	ldd	r25, Y+4	; 0x04
  60:	08 96       	adiw	r24, 0x08	; 8
  62:	0e 94 00 00 	call	0	; 0x0 <xQueueReceiveFromISR>
  66:	88 23       	and	r24, r24
  68:	01 f0       	breq	.+0      	; 0x6a <xQueueReceiveFromISR+0x6a>
  6a:	ef 81       	ldd	r30, Y+7	; 0x07
  6c:	f8 85       	ldd	r31, Y+8	; 0x08
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	80 83       	st	Z, r24
  72:	00 c0       	rjmp	.+0      	; 0x74 <xQueueReceiveFromISR+0x74>
  74:	eb 81       	ldd	r30, Y+3	; 0x03
  76:	fc 81       	ldd	r31, Y+4	; 0x04
  78:	85 8d       	ldd	r24, Z+29	; 0x1d
  7a:	8f 5f       	subi	r24, 0xFF	; 255
  7c:	eb 81       	ldd	r30, Y+3	; 0x03
  7e:	fc 81       	ldd	r31, Y+4	; 0x04
  80:	85 8f       	std	Z+29, r24	; 0x1d
  82:	81 e0       	ldi	r24, 0x01	; 1
  84:	8a 83       	std	Y+2, r24	; 0x02
  86:	00 c0       	rjmp	.+0      	; 0x88 <xQueueReceiveFromISR+0x88>
  88:	1a 82       	std	Y+2, r1	; 0x02
  8a:	8a 81       	ldd	r24, Y+2	; 0x02
  8c:	28 96       	adiw	r28, 0x08	; 8
  8e:	0f b6       	in	r0, 0x3f	; 63
  90:	f8 94       	cli
  92:	de bf       	out	0x3e, r29	; 62
  94:	0f be       	out	0x3f, r0	; 63
  96:	cd bf       	out	0x3d, r28	; 61
  98:	cf 91       	pop	r28
  9a:	df 91       	pop	r29
  9c:	08 95       	ret

Disassembly of section .text.uxQueueMessagesWaiting:

00000000 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <uxQueueMessagesWaiting+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	0f b6       	in	r0, 0x3f	; 63
  12:	f8 94       	cli
  14:	0f 92       	push	r0
  16:	ea 81       	ldd	r30, Y+2	; 0x02
  18:	fb 81       	ldd	r31, Y+3	; 0x03
  1a:	82 8d       	ldd	r24, Z+26	; 0x1a
  1c:	89 83       	std	Y+1, r24	; 0x01
  1e:	0f 90       	pop	r0
  20:	0f be       	out	0x3f, r0	; 63
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	0f 90       	pop	r0

	return xReturn;
  26:	0f 90       	pop	r0
}
  28:	0f 90       	pop	r0
  2a:	cf 91       	pop	r28
  2c:	df 91       	pop	r29
  2e:	08 95       	ret

Disassembly of section .text.uxQueueMessagesWaitingFromISR:

00000000 <uxQueueMessagesWaitingFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <uxQueueMessagesWaitingFromISR+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	ea 81       	ldd	r30, Y+2	; 0x02
  12:	fb 81       	ldd	r31, Y+3	; 0x03
  14:	82 8d       	ldd	r24, Z+26	; 0x1a
  16:	89 83       	std	Y+1, r24	; 0x01
  18:	89 81       	ldd	r24, Y+1	; 0x01
  1a:	0f 90       	pop	r0
  1c:	0f 90       	pop	r0
  1e:	0f 90       	pop	r0
  20:	cf 91       	pop	r28
  22:	df 91       	pop	r29
  24:	08 95       	ret

Disassembly of section .text.vQueueDelete:

00000000 <vQueueDelete>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vQueueDelete+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	e9 81       	ldd	r30, Y+1	; 0x01
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	fa 81       	ldd	r31, Y+2	; 0x02
  12:	80 81       	ld	r24, Z
  14:	91 81       	ldd	r25, Z+1	; 0x01
  16:	0e 94 00 00 	call	0	; 0x0 <vQueueDelete>
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	9a 81       	ldd	r25, Y+2	; 0x02
  1e:	0e 94 00 00 	call	0	; 0x0 <vQueueDelete>
  22:	0f 90       	pop	r0
  24:	0f 90       	pop	r0

	return xReturn;
  26:	cf 91       	pop	r28
}
  28:	df 91       	pop	r29
  2a:	08 95       	ret

Disassembly of section .text.prvCopyDataToQueue:

00000000 <prvCopyDataToQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvCopyDataToQueue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <prvCopyDataToQueue+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	9a 83       	std	Y+2, r25	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	89 83       	std	Y+1, r24	; 0x01
  12:	7c 83       	std	Y+4, r23	; 0x04
  14:	6b 83       	std	Y+3, r22	; 0x03
  16:	4d 83       	std	Y+5, r20	; 0x05
  18:	e9 81       	ldd	r30, Y+1	; 0x01
  1a:	fa 81       	ldd	r31, Y+2	; 0x02
  1c:	84 8d       	ldd	r24, Z+28	; 0x1c
  1e:	88 23       	and	r24, r24
  20:	01 f4       	brne	.+0      	; 0x22 <prvCopyDataToQueue+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <prvCopyDataToQueue+0x24>
  24:	8d 81       	ldd	r24, Y+5	; 0x05

	return xReturn;
  26:	88 23       	and	r24, r24
}
  28:	01 f4       	brne	.+0      	; 0x2a <prvCopyDataToQueue+0x2a>
  2a:	e9 81       	ldd	r30, Y+1	; 0x01
  2c:	fa 81       	ldd	r31, Y+2	; 0x02
  2e:	64 81       	ldd	r22, Z+4	; 0x04
  30:	75 81       	ldd	r23, Z+5	; 0x05
  32:	e9 81       	ldd	r30, Y+1	; 0x01
  34:	fa 81       	ldd	r31, Y+2	; 0x02
  36:	84 8d       	ldd	r24, Z+28	; 0x1c
  38:	48 2f       	mov	r20, r24
  3a:	50 e0       	ldi	r21, 0x00	; 0
  3c:	2b 81       	ldd	r18, Y+3	; 0x03
  3e:	3c 81       	ldd	r19, Y+4	; 0x04
  40:	cb 01       	movw	r24, r22
  42:	b9 01       	movw	r22, r18
  44:	0e 94 00 00 	call	0	; 0x0 <prvCopyDataToQueue>
  48:	e9 81       	ldd	r30, Y+1	; 0x01
  4a:	fa 81       	ldd	r31, Y+2	; 0x02
  4c:	24 81       	ldd	r18, Z+4	; 0x04
  4e:	35 81       	ldd	r19, Z+5	; 0x05
  50:	e9 81       	ldd	r30, Y+1	; 0x01
  52:	fa 81       	ldd	r31, Y+2	; 0x02
  54:	84 8d       	ldd	r24, Z+28	; 0x1c
  56:	88 2f       	mov	r24, r24
  58:	90 e0       	ldi	r25, 0x00	; 0
  5a:	82 0f       	add	r24, r18
  5c:	93 1f       	adc	r25, r19
  5e:	e9 81       	ldd	r30, Y+1	; 0x01
  60:	fa 81       	ldd	r31, Y+2	; 0x02
  62:	95 83       	std	Z+5, r25	; 0x05
  64:	84 83       	std	Z+4, r24	; 0x04
  66:	e9 81       	ldd	r30, Y+1	; 0x01
  68:	fa 81       	ldd	r31, Y+2	; 0x02
  6a:	24 81       	ldd	r18, Z+4	; 0x04
  6c:	35 81       	ldd	r19, Z+5	; 0x05
  6e:	e9 81       	ldd	r30, Y+1	; 0x01
  70:	fa 81       	ldd	r31, Y+2	; 0x02
  72:	82 81       	ldd	r24, Z+2	; 0x02
  74:	93 81       	ldd	r25, Z+3	; 0x03
  76:	28 17       	cp	r18, r24
  78:	39 07       	cpc	r19, r25
  7a:	00 f4       	brcc	.+0      	; 0x7c <prvCopyDataToQueue+0x7c>
  7c:	00 c0       	rjmp	.+0      	; 0x7e <prvCopyDataToQueue+0x7e>
  7e:	e9 81       	ldd	r30, Y+1	; 0x01
  80:	fa 81       	ldd	r31, Y+2	; 0x02
  82:	80 81       	ld	r24, Z
  84:	91 81       	ldd	r25, Z+1	; 0x01
  86:	e9 81       	ldd	r30, Y+1	; 0x01
  88:	fa 81       	ldd	r31, Y+2	; 0x02
  8a:	95 83       	std	Z+5, r25	; 0x05
  8c:	84 83       	std	Z+4, r24	; 0x04
  8e:	00 c0       	rjmp	.+0      	; 0x90 <prvCopyDataToQueue+0x90>
  90:	e9 81       	ldd	r30, Y+1	; 0x01
  92:	fa 81       	ldd	r31, Y+2	; 0x02
  94:	66 81       	ldd	r22, Z+6	; 0x06
  96:	77 81       	ldd	r23, Z+7	; 0x07
  98:	e9 81       	ldd	r30, Y+1	; 0x01
  9a:	fa 81       	ldd	r31, Y+2	; 0x02
  9c:	84 8d       	ldd	r24, Z+28	; 0x1c
  9e:	48 2f       	mov	r20, r24
  a0:	50 e0       	ldi	r21, 0x00	; 0
  a2:	2b 81       	ldd	r18, Y+3	; 0x03
  a4:	3c 81       	ldd	r19, Y+4	; 0x04
  a6:	cb 01       	movw	r24, r22
  a8:	b9 01       	movw	r22, r18
  aa:	0e 94 00 00 	call	0	; 0x0 <prvCopyDataToQueue>
  ae:	e9 81       	ldd	r30, Y+1	; 0x01
  b0:	fa 81       	ldd	r31, Y+2	; 0x02
  b2:	26 81       	ldd	r18, Z+6	; 0x06
  b4:	37 81       	ldd	r19, Z+7	; 0x07
  b6:	e9 81       	ldd	r30, Y+1	; 0x01
  b8:	fa 81       	ldd	r31, Y+2	; 0x02
  ba:	84 8d       	ldd	r24, Z+28	; 0x1c
  bc:	88 2f       	mov	r24, r24
  be:	90 e0       	ldi	r25, 0x00	; 0
  c0:	90 95       	com	r25
  c2:	81 95       	neg	r24
  c4:	9f 4f       	sbci	r25, 0xFF	; 255
  c6:	82 0f       	add	r24, r18
  c8:	93 1f       	adc	r25, r19
  ca:	e9 81       	ldd	r30, Y+1	; 0x01
  cc:	fa 81       	ldd	r31, Y+2	; 0x02
  ce:	97 83       	std	Z+7, r25	; 0x07
  d0:	86 83       	std	Z+6, r24	; 0x06
  d2:	e9 81       	ldd	r30, Y+1	; 0x01
  d4:	fa 81       	ldd	r31, Y+2	; 0x02
  d6:	26 81       	ldd	r18, Z+6	; 0x06
  d8:	37 81       	ldd	r19, Z+7	; 0x07
  da:	e9 81       	ldd	r30, Y+1	; 0x01
  dc:	fa 81       	ldd	r31, Y+2	; 0x02
  de:	80 81       	ld	r24, Z
  e0:	91 81       	ldd	r25, Z+1	; 0x01
  e2:	28 17       	cp	r18, r24
  e4:	39 07       	cpc	r19, r25
  e6:	00 f4       	brcc	.+0      	; 0xe8 <prvCopyDataToQueue+0xe8>
  e8:	e9 81       	ldd	r30, Y+1	; 0x01
  ea:	fa 81       	ldd	r31, Y+2	; 0x02
  ec:	22 81       	ldd	r18, Z+2	; 0x02
  ee:	33 81       	ldd	r19, Z+3	; 0x03
  f0:	e9 81       	ldd	r30, Y+1	; 0x01
  f2:	fa 81       	ldd	r31, Y+2	; 0x02
  f4:	84 8d       	ldd	r24, Z+28	; 0x1c
  f6:	88 2f       	mov	r24, r24
  f8:	90 e0       	ldi	r25, 0x00	; 0
  fa:	90 95       	com	r25
  fc:	81 95       	neg	r24
  fe:	9f 4f       	sbci	r25, 0xFF	; 255
 100:	82 0f       	add	r24, r18
 102:	93 1f       	adc	r25, r19
 104:	e9 81       	ldd	r30, Y+1	; 0x01
 106:	fa 81       	ldd	r31, Y+2	; 0x02
 108:	97 83       	std	Z+7, r25	; 0x07
 10a:	86 83       	std	Z+6, r24	; 0x06
 10c:	e9 81       	ldd	r30, Y+1	; 0x01
 10e:	fa 81       	ldd	r31, Y+2	; 0x02
 110:	82 8d       	ldd	r24, Z+26	; 0x1a
 112:	8f 5f       	subi	r24, 0xFF	; 255
 114:	e9 81       	ldd	r30, Y+1	; 0x01
 116:	fa 81       	ldd	r31, Y+2	; 0x02
 118:	82 8f       	std	Z+26, r24	; 0x1a
 11a:	0f 90       	pop	r0
 11c:	0f 90       	pop	r0
 11e:	0f 90       	pop	r0
 120:	0f 90       	pop	r0
 122:	0f 90       	pop	r0
 124:	cf 91       	pop	r28
 126:	df 91       	pop	r29
 128:	08 95       	ret

Disassembly of section .text.prvCopyDataFromQueue:

00000000 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvCopyDataFromQueue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <prvCopyDataFromQueue+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9a 83       	std	Y+2, r25	; 0x02
   e:	89 83       	std	Y+1, r24	; 0x01
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	7c 83       	std	Y+4, r23	; 0x04
  12:	6b 83       	std	Y+3, r22	; 0x03
  14:	e9 81       	ldd	r30, Y+1	; 0x01
  16:	fa 81       	ldd	r31, Y+2	; 0x02
  18:	80 81       	ld	r24, Z
  1a:	91 81       	ldd	r25, Z+1	; 0x01
  1c:	00 97       	sbiw	r24, 0x00	; 0
  1e:	01 f0       	breq	.+0      	; 0x20 <prvCopyDataFromQueue+0x20>
  20:	e9 81       	ldd	r30, Y+1	; 0x01
  22:	fa 81       	ldd	r31, Y+2	; 0x02
  24:	26 81       	ldd	r18, Z+6	; 0x06

	return xReturn;
  26:	37 81       	ldd	r19, Z+7	; 0x07
}
  28:	e9 81       	ldd	r30, Y+1	; 0x01
  2a:	fa 81       	ldd	r31, Y+2	; 0x02
  2c:	84 8d       	ldd	r24, Z+28	; 0x1c
  2e:	88 2f       	mov	r24, r24
  30:	90 e0       	ldi	r25, 0x00	; 0
  32:	82 0f       	add	r24, r18
  34:	93 1f       	adc	r25, r19
  36:	e9 81       	ldd	r30, Y+1	; 0x01
  38:	fa 81       	ldd	r31, Y+2	; 0x02
  3a:	97 83       	std	Z+7, r25	; 0x07
  3c:	86 83       	std	Z+6, r24	; 0x06
  3e:	e9 81       	ldd	r30, Y+1	; 0x01
  40:	fa 81       	ldd	r31, Y+2	; 0x02
  42:	26 81       	ldd	r18, Z+6	; 0x06
  44:	37 81       	ldd	r19, Z+7	; 0x07
  46:	e9 81       	ldd	r30, Y+1	; 0x01
  48:	fa 81       	ldd	r31, Y+2	; 0x02
  4a:	82 81       	ldd	r24, Z+2	; 0x02
  4c:	93 81       	ldd	r25, Z+3	; 0x03
  4e:	28 17       	cp	r18, r24
  50:	39 07       	cpc	r19, r25
  52:	00 f0       	brcs	.+0      	; 0x54 <prvCopyDataFromQueue+0x54>
  54:	e9 81       	ldd	r30, Y+1	; 0x01
  56:	fa 81       	ldd	r31, Y+2	; 0x02
  58:	80 81       	ld	r24, Z
  5a:	91 81       	ldd	r25, Z+1	; 0x01
  5c:	e9 81       	ldd	r30, Y+1	; 0x01
  5e:	fa 81       	ldd	r31, Y+2	; 0x02
  60:	97 83       	std	Z+7, r25	; 0x07
  62:	86 83       	std	Z+6, r24	; 0x06
  64:	e9 81       	ldd	r30, Y+1	; 0x01
  66:	fa 81       	ldd	r31, Y+2	; 0x02
  68:	46 81       	ldd	r20, Z+6	; 0x06
  6a:	57 81       	ldd	r21, Z+7	; 0x07
  6c:	e9 81       	ldd	r30, Y+1	; 0x01
  6e:	fa 81       	ldd	r31, Y+2	; 0x02
  70:	84 8d       	ldd	r24, Z+28	; 0x1c
  72:	28 2f       	mov	r18, r24
  74:	30 e0       	ldi	r19, 0x00	; 0
  76:	8b 81       	ldd	r24, Y+3	; 0x03
  78:	9c 81       	ldd	r25, Y+4	; 0x04
  7a:	ba 01       	movw	r22, r20
  7c:	a9 01       	movw	r20, r18
  7e:	0e 94 00 00 	call	0	; 0x0 <prvCopyDataFromQueue>
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	cf 91       	pop	r28
  8c:	df 91       	pop	r29
  8e:	08 95       	ret

Disassembly of section .text.prvUnlockQueue:

00000000 <prvUnlockQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvUnlockQueue+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	0f b6       	in	r0, 0x3f	; 63
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	f8 94       	cli
  12:	0f 92       	push	r0
  14:	00 c0       	rjmp	.+0      	; 0x16 <prvUnlockQueue+0x16>
  16:	e9 81       	ldd	r30, Y+1	; 0x01
  18:	fa 81       	ldd	r31, Y+2	; 0x02
  1a:	81 89       	ldd	r24, Z+17	; 0x11
  1c:	88 23       	and	r24, r24
  1e:	01 f0       	breq	.+0      	; 0x20 <prvUnlockQueue+0x20>
  20:	89 81       	ldd	r24, Y+1	; 0x01
  22:	9a 81       	ldd	r25, Y+2	; 0x02
  24:	41 96       	adiw	r24, 0x11	; 17

	return xReturn;
  26:	0e 94 00 00 	call	0	; 0x0 <prvUnlockQueue>
}
  2a:	88 23       	and	r24, r24
  2c:	01 f0       	breq	.+0      	; 0x2e <prvUnlockQueue+0x2e>
  2e:	0e 94 00 00 	call	0	; 0x0 <prvUnlockQueue>
  32:	e9 81       	ldd	r30, Y+1	; 0x01
  34:	fa 81       	ldd	r31, Y+2	; 0x02
  36:	86 8d       	ldd	r24, Z+30	; 0x1e
  38:	81 50       	subi	r24, 0x01	; 1
  3a:	e9 81       	ldd	r30, Y+1	; 0x01
  3c:	fa 81       	ldd	r31, Y+2	; 0x02
  3e:	86 8f       	std	Z+30, r24	; 0x1e
  40:	e9 81       	ldd	r30, Y+1	; 0x01
  42:	fa 81       	ldd	r31, Y+2	; 0x02
  44:	86 8d       	ldd	r24, Z+30	; 0x1e
  46:	18 16       	cp	r1, r24
  48:	04 f0       	brlt	.+0      	; 0x4a <prvUnlockQueue+0x4a>
  4a:	e9 81       	ldd	r30, Y+1	; 0x01
  4c:	fa 81       	ldd	r31, Y+2	; 0x02
  4e:	8f ef       	ldi	r24, 0xFF	; 255
  50:	86 8f       	std	Z+30, r24	; 0x1e
  52:	0f 90       	pop	r0
  54:	0f be       	out	0x3f, r0	; 63
  56:	0f b6       	in	r0, 0x3f	; 63
  58:	f8 94       	cli
  5a:	0f 92       	push	r0
  5c:	00 c0       	rjmp	.+0      	; 0x5e <prvUnlockQueue+0x5e>
  5e:	e9 81       	ldd	r30, Y+1	; 0x01
  60:	fa 81       	ldd	r31, Y+2	; 0x02
  62:	80 85       	ldd	r24, Z+8	; 0x08
  64:	88 23       	and	r24, r24
  66:	01 f0       	breq	.+0      	; 0x68 <prvUnlockQueue+0x68>
  68:	89 81       	ldd	r24, Y+1	; 0x01
  6a:	9a 81       	ldd	r25, Y+2	; 0x02
  6c:	08 96       	adiw	r24, 0x08	; 8
  6e:	0e 94 00 00 	call	0	; 0x0 <prvUnlockQueue>
  72:	88 23       	and	r24, r24
  74:	01 f0       	breq	.+0      	; 0x76 <prvUnlockQueue+0x76>
  76:	0e 94 00 00 	call	0	; 0x0 <prvUnlockQueue>
  7a:	e9 81       	ldd	r30, Y+1	; 0x01
  7c:	fa 81       	ldd	r31, Y+2	; 0x02
  7e:	85 8d       	ldd	r24, Z+29	; 0x1d
  80:	81 50       	subi	r24, 0x01	; 1
  82:	e9 81       	ldd	r30, Y+1	; 0x01
  84:	fa 81       	ldd	r31, Y+2	; 0x02
  86:	85 8f       	std	Z+29, r24	; 0x1d
  88:	e9 81       	ldd	r30, Y+1	; 0x01
  8a:	fa 81       	ldd	r31, Y+2	; 0x02
  8c:	85 8d       	ldd	r24, Z+29	; 0x1d
  8e:	18 16       	cp	r1, r24
  90:	04 f0       	brlt	.+0      	; 0x92 <prvUnlockQueue+0x92>
  92:	e9 81       	ldd	r30, Y+1	; 0x01
  94:	fa 81       	ldd	r31, Y+2	; 0x02
  96:	8f ef       	ldi	r24, 0xFF	; 255
  98:	85 8f       	std	Z+29, r24	; 0x1d
  9a:	0f 90       	pop	r0
  9c:	0f be       	out	0x3f, r0	; 63
  9e:	0f 90       	pop	r0
  a0:	0f 90       	pop	r0
  a2:	cf 91       	pop	r28
  a4:	df 91       	pop	r29
  a6:	08 95       	ret

Disassembly of section .text.prvIsQueueEmpty:

00000000 <prvIsQueueEmpty>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvIsQueueEmpty+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	0f b6       	in	r0, 0x3f	; 63
  12:	f8 94       	cli
  14:	0f 92       	push	r0
  16:	ea 81       	ldd	r30, Y+2	; 0x02
  18:	fb 81       	ldd	r31, Y+3	; 0x03
  1a:	82 8d       	ldd	r24, Z+26	; 0x1a
  1c:	19 82       	std	Y+1, r1	; 0x01
  1e:	88 23       	and	r24, r24
  20:	01 f4       	brne	.+0      	; 0x22 <prvIsQueueEmpty+0x22>
  22:	81 e0       	ldi	r24, 0x01	; 1
  24:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
  26:	0f 90       	pop	r0
}
  28:	0f be       	out	0x3f, r0	; 63
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	0f 90       	pop	r0
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	cf 91       	pop	r28
  34:	df 91       	pop	r29
  36:	08 95       	ret

Disassembly of section .text.xQueueIsQueueEmptyFromISR:

00000000 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <xQueueIsQueueEmptyFromISR+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	ea 81       	ldd	r30, Y+2	; 0x02
  12:	fb 81       	ldd	r31, Y+3	; 0x03
  14:	82 8d       	ldd	r24, Z+26	; 0x1a
  16:	19 82       	std	Y+1, r1	; 0x01
  18:	88 23       	and	r24, r24
  1a:	01 f4       	brne	.+0      	; 0x1c <xQueueIsQueueEmptyFromISR+0x1c>
  1c:	81 e0       	ldi	r24, 0x01	; 1
  1e:	89 83       	std	Y+1, r24	; 0x01
  20:	89 81       	ldd	r24, Y+1	; 0x01
  22:	0f 90       	pop	r0
  24:	0f 90       	pop	r0

	return xReturn;
  26:	0f 90       	pop	r0
}
  28:	cf 91       	pop	r28
  2a:	df 91       	pop	r29
  2c:	08 95       	ret

Disassembly of section .text.prvIsQueueFull:

00000000 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvIsQueueFull+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	0f b6       	in	r0, 0x3f	; 63
  12:	f8 94       	cli
  14:	0f 92       	push	r0
  16:	ea 81       	ldd	r30, Y+2	; 0x02
  18:	fb 81       	ldd	r31, Y+3	; 0x03
  1a:	92 8d       	ldd	r25, Z+26	; 0x1a
  1c:	ea 81       	ldd	r30, Y+2	; 0x02
  1e:	fb 81       	ldd	r31, Y+3	; 0x03
  20:	83 8d       	ldd	r24, Z+27	; 0x1b
  22:	19 82       	std	Y+1, r1	; 0x01
  24:	98 17       	cp	r25, r24

	return xReturn;
  26:	01 f4       	brne	.+0      	; 0x28 <prvIsQueueFull+0x28>
}
  28:	81 e0       	ldi	r24, 0x01	; 1
  2a:	89 83       	std	Y+1, r24	; 0x01
  2c:	0f 90       	pop	r0
  2e:	0f be       	out	0x3f, r0	; 63
  30:	89 81       	ldd	r24, Y+1	; 0x01
  32:	0f 90       	pop	r0
  34:	0f 90       	pop	r0
  36:	0f 90       	pop	r0
  38:	cf 91       	pop	r28
  3a:	df 91       	pop	r29
  3c:	08 95       	ret

Disassembly of section .text.xQueueIsQueueFullFromISR:

00000000 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <xQueueIsQueueFullFromISR+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9b 83       	std	Y+3, r25	; 0x03
   e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  10:	ea 81       	ldd	r30, Y+2	; 0x02
  12:	fb 81       	ldd	r31, Y+3	; 0x03
  14:	92 8d       	ldd	r25, Z+26	; 0x1a
  16:	ea 81       	ldd	r30, Y+2	; 0x02
  18:	fb 81       	ldd	r31, Y+3	; 0x03
  1a:	83 8d       	ldd	r24, Z+27	; 0x1b
  1c:	19 82       	std	Y+1, r1	; 0x01
  1e:	98 17       	cp	r25, r24
  20:	01 f4       	brne	.+0      	; 0x22 <xQueueIsQueueFullFromISR+0x22>
  22:	81 e0       	ldi	r24, 0x01	; 1
  24:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
  26:	89 81       	ldd	r24, Y+1	; 0x01
}
  28:	0f 90       	pop	r0
  2a:	0f 90       	pop	r0
  2c:	0f 90       	pop	r0
  2e:	cf 91       	pop	r28
  30:	df 91       	pop	r29
  32:	08 95       	ret

tasks.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000005  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000039  2**0
                  ALLOC
  3 .stab         000017d0  00000000  00000000  0000003c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001940  00000000  00000000  0000180c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.pxCurrentTCB 00000002  00000000  00000000  0000314c  2**0
                  ALLOC
  6 .bss.uxTasksDeleted 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
  7 .bss.uxCurrentNumberOfTasks 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
  8 .bss.xTickCount 00000002  00000000  00000000  0000314c  2**0
                  ALLOC
  9 .bss.uxTopUsedPriority 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
 10 .bss.uxTopReadyPriority 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
 11 .bss.xSchedulerRunning 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
 12 .bss.uxSchedulerSuspended 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
 13 .bss.uxMissedTicks 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
 14 .bss.xMissedYield 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
 15 .bss.xNumOfOverflows 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
 16 .bss.uxTaskNumber 00000001  00000000  00000000  0000314c  2**0
                  ALLOC
 17 .data.xNextTaskUnblockTime 00000002  00000000  00000000  0000314c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 18 .text.xTaskGenericCreate 000001da  00000000  00000000  0000314e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text.vTaskDelete 000000c6  00000000  00000000  00003328  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text.vTaskDelayUntil 000000e8  00000000  00000000  000033ee  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text.vTaskDelay 0000006a  00000000  00000000  000034d6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text.vTaskStartScheduler 0000006e  00000000  00000000  00003540  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text.vTaskEndScheduler 00000018  00000000  00000000  000035ae  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 24 .text.vTaskSuspendAll 00000018  00000000  00000000  000035c6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 25 .text.xTaskResumeAll 00000114  00000000  00000000  000035de  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 26 .text.xTaskGetTickCount 0000002e  00000000  00000000  000036f2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 27 .text.xTaskGetTickCountFromISR 0000002a  00000000  00000000  00003720  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 28 .text.uxTaskGetNumberOfTasks 00000012  00000000  00000000  0000374a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 29 .text.vTaskIncrementTick 000001aa  00000000  00000000  0000375c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 30 .text.vTaskSwitchContext 000000cc  00000000  00000000  00003906  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 31 .text.vTaskPlaceOnEventList 0000006c  00000000  00000000  000039d2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 32 .text.xTaskRemoveFromEventList 000000d0  00000000  00000000  00003a3e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 33 .text.vTaskSetTimeOutState 00000032  00000000  00000000  00003b0e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 34 .text.xTaskCheckForTimeOut 000000ba  00000000  00000000  00003b40  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 35 .text.vTaskMissedYield 00000014  00000000  00000000  00003bfa  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 36 .text.prvIdleTask 00000014  00000000  00000000  00003c0e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 37 .text.prvInitialiseTCBVariables 000000ae  00000000  00000000  00003c22  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 38 .text.prvInitialiseTaskLists 0000007a  00000000  00000000  00003cd0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 39 .text.prvCheckTasksWaitingTermination 0000007c  00000000  00000000  00003d4a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 40 .text.prvAddCurrentTaskToDelayedList 00000092  00000000  00000000  00003dc6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 41 .text.prvAllocateTCBAndStack 000000a0  00000000  00000000  00003e58  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 42 .text.prvDeleteTCB 0000002c  00000000  00000000  00003ef8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 43 .bss.pxReadyTasksLists 0000002d  00000000  00000000  00003f24  2**0
                  ALLOC
 44 .bss.xDelayedTaskList1 00000009  00000000  00000000  00003f24  2**0
                  ALLOC
 45 .bss.xDelayedTaskList2 00000009  00000000  00000000  00003f24  2**0
                  ALLOC
 46 .bss.pxDelayedTaskList 00000002  00000000  00000000  00003f24  2**0
                  ALLOC
 47 .bss.pxOverflowDelayedTaskList 00000002  00000000  00000000  00003f24  2**0
                  ALLOC
 48 .bss.xPendingReadyList 00000009  00000000  00000000  00003f24  2**0
                  ALLOC
 49 .bss.xTasksWaitingTermination 00000009  00000000  00000000  00003f24  2**0
                  ALLOC

Disassembly of section .text.xTaskGenericCreate:

00000000 <xTaskGenericCreate>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	1f 93       	push	r17
  10:	df 93       	push	r29
  12:	cf 93       	push	r28
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	64 97       	sbiw	r28, 0x14	; 20
		vPortFree( pxTCB );
  1a:	0f b6       	in	r0, 0x3f	; 63
  1c:	f8 94       	cli
  1e:	de bf       	out	0x3e, r29	; 62
  20:	0f be       	out	0x3f, r0	; 63
	}
  22:	cd bf       	out	0x3d, r28	; 61
  24:	9f 83       	std	Y+7, r25	; 0x07
  26:	8e 83       	std	Y+6, r24	; 0x06
  28:	79 87       	std	Y+9, r23	; 0x09
  2a:	68 87       	std	Y+8, r22	; 0x08
  2c:	5b 87       	std	Y+11, r21	; 0x0b
  2e:	4a 87       	std	Y+10, r20	; 0x0a
  30:	3d 87       	std	Y+13, r19	; 0x0d
  32:	2c 87       	std	Y+12, r18	; 0x0c
  34:	0e 87       	std	Y+14, r16	; 0x0e
  36:	f8 8a       	std	Y+16, r15	; 0x10
  38:	ef 86       	std	Y+15, r14	; 0x0f
  3a:	da 8a       	std	Y+18, r13	; 0x12
  3c:	c9 8a       	std	Y+17, r12	; 0x11
  3e:	bc 8a       	std	Y+20, r11	; 0x14
  40:	ab 8a       	std	Y+19, r10	; 0x13
  42:	8a 85       	ldd	r24, Y+10	; 0x0a
  44:	9b 85       	ldd	r25, Y+11	; 0x0b
  46:	29 89       	ldd	r18, Y+17	; 0x11
  48:	3a 89       	ldd	r19, Y+18	; 0x12
  4a:	b9 01       	movw	r22, r18
  4c:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericCreate>
  50:	9c 83       	std	Y+4, r25	; 0x04
  52:	8b 83       	std	Y+3, r24	; 0x03
  54:	8b 81       	ldd	r24, Y+3	; 0x03
  56:	9c 81       	ldd	r25, Y+4	; 0x04
  58:	00 97       	sbiw	r24, 0x00	; 0
  5a:	01 f4       	brne	.+0      	; 0x5c <xTaskGenericCreate+0x5c>
  5c:	00 c0       	rjmp	.+0      	; 0x5e <xTaskGenericCreate+0x5e>
  5e:	eb 81       	ldd	r30, Y+3	; 0x03
  60:	fc 81       	ldd	r31, Y+4	; 0x04
  62:	27 89       	ldd	r18, Z+23	; 0x17
  64:	30 8d       	ldd	r19, Z+24	; 0x18
  66:	8a 85       	ldd	r24, Y+10	; 0x0a
  68:	9b 85       	ldd	r25, Y+11	; 0x0b
  6a:	01 97       	sbiw	r24, 0x01	; 1
  6c:	82 0f       	add	r24, r18
  6e:	93 1f       	adc	r25, r19
  70:	9a 83       	std	Y+2, r25	; 0x02
  72:	89 83       	std	Y+1, r24	; 0x01
  74:	8b 81       	ldd	r24, Y+3	; 0x03
  76:	9c 81       	ldd	r25, Y+4	; 0x04
  78:	28 85       	ldd	r18, Y+8	; 0x08
  7a:	39 85       	ldd	r19, Y+9	; 0x09
  7c:	eb 89       	ldd	r30, Y+19	; 0x13
  7e:	fc 89       	ldd	r31, Y+20	; 0x14
  80:	aa 85       	ldd	r26, Y+10	; 0x0a
  82:	bb 85       	ldd	r27, Y+11	; 0x0b
  84:	b9 01       	movw	r22, r18
  86:	4e 85       	ldd	r20, Y+14	; 0x0e
  88:	9f 01       	movw	r18, r30
  8a:	8d 01       	movw	r16, r26
  8c:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericCreate>
  90:	89 81       	ldd	r24, Y+1	; 0x01
  92:	9a 81       	ldd	r25, Y+2	; 0x02
  94:	2e 81       	ldd	r18, Y+6	; 0x06
  96:	3f 81       	ldd	r19, Y+7	; 0x07
  98:	4c 85       	ldd	r20, Y+12	; 0x0c
  9a:	5d 85       	ldd	r21, Y+13	; 0x0d
  9c:	b9 01       	movw	r22, r18
  9e:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericCreate>
  a2:	eb 81       	ldd	r30, Y+3	; 0x03
  a4:	fc 81       	ldd	r31, Y+4	; 0x04
  a6:	91 83       	std	Z+1, r25	; 0x01
  a8:	80 83       	st	Z, r24
  aa:	8f 85       	ldd	r24, Y+15	; 0x0f
  ac:	98 89       	ldd	r25, Y+16	; 0x10
  ae:	00 97       	sbiw	r24, 0x00	; 0
  b0:	01 f0       	breq	.+0      	; 0xb2 <xTaskGenericCreate+0xb2>
  b2:	ef 85       	ldd	r30, Y+15	; 0x0f
  b4:	f8 89       	ldd	r31, Y+16	; 0x10
  b6:	8b 81       	ldd	r24, Y+3	; 0x03
  b8:	9c 81       	ldd	r25, Y+4	; 0x04
  ba:	91 83       	std	Z+1, r25	; 0x01
  bc:	80 83       	st	Z, r24
  be:	0f b6       	in	r0, 0x3f	; 63
  c0:	f8 94       	cli
  c2:	0f 92       	push	r0
  c4:	80 91 00 00 	lds	r24, 0x0000
  c8:	8f 5f       	subi	r24, 0xFF	; 255
  ca:	80 93 00 00 	sts	0x0000, r24
  ce:	80 91 00 00 	lds	r24, 0x0000
  d2:	90 91 00 00 	lds	r25, 0x0000
  d6:	00 97       	sbiw	r24, 0x00	; 0
  d8:	01 f4       	brne	.+0      	; 0xda <xTaskGenericCreate+0xda>
  da:	8b 81       	ldd	r24, Y+3	; 0x03
  dc:	9c 81       	ldd	r25, Y+4	; 0x04
  de:	90 93 00 00 	sts	0x0000, r25
  e2:	80 93 00 00 	sts	0x0000, r24
  e6:	80 91 00 00 	lds	r24, 0x0000
  ea:	81 30       	cpi	r24, 0x01	; 1
  ec:	01 f4       	brne	.+0      	; 0xee <xTaskGenericCreate+0xee>
  ee:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericCreate>
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <xTaskGenericCreate+0xf4>
  f4:	80 91 00 00 	lds	r24, 0x0000
  f8:	88 23       	and	r24, r24
  fa:	01 f4       	brne	.+0      	; 0xfc <xTaskGenericCreate+0xfc>
  fc:	e0 91 00 00 	lds	r30, 0x0000
 100:	f0 91 00 00 	lds	r31, 0x0000
 104:	96 89       	ldd	r25, Z+22	; 0x16
 106:	8e 85       	ldd	r24, Y+14	; 0x0e
 108:	89 17       	cp	r24, r25
 10a:	00 f0       	brcs	.+0      	; 0x10c <xTaskGenericCreate+0x10c>
 10c:	8b 81       	ldd	r24, Y+3	; 0x03
 10e:	9c 81       	ldd	r25, Y+4	; 0x04
 110:	90 93 00 00 	sts	0x0000, r25
 114:	80 93 00 00 	sts	0x0000, r24
 118:	eb 81       	ldd	r30, Y+3	; 0x03
 11a:	fc 81       	ldd	r31, Y+4	; 0x04
 11c:	96 89       	ldd	r25, Z+22	; 0x16
 11e:	80 91 00 00 	lds	r24, 0x0000
 122:	89 17       	cp	r24, r25
 124:	00 f4       	brcc	.+0      	; 0x126 <xTaskGenericCreate+0x126>
 126:	eb 81       	ldd	r30, Y+3	; 0x03
 128:	fc 81       	ldd	r31, Y+4	; 0x04
 12a:	86 89       	ldd	r24, Z+22	; 0x16
 12c:	80 93 00 00 	sts	0x0000, r24
 130:	80 91 00 00 	lds	r24, 0x0000
 134:	8f 5f       	subi	r24, 0xFF	; 255
 136:	80 93 00 00 	sts	0x0000, r24
 13a:	eb 81       	ldd	r30, Y+3	; 0x03
 13c:	fc 81       	ldd	r31, Y+4	; 0x04
 13e:	96 89       	ldd	r25, Z+22	; 0x16
 140:	80 91 00 00 	lds	r24, 0x0000
 144:	89 17       	cp	r24, r25
 146:	00 f4       	brcc	.+0      	; 0x148 <xTaskGenericCreate+0x148>
 148:	eb 81       	ldd	r30, Y+3	; 0x03
 14a:	fc 81       	ldd	r31, Y+4	; 0x04
 14c:	86 89       	ldd	r24, Z+22	; 0x16
 14e:	80 93 00 00 	sts	0x0000, r24
 152:	eb 81       	ldd	r30, Y+3	; 0x03
 154:	fc 81       	ldd	r31, Y+4	; 0x04
 156:	86 89       	ldd	r24, Z+22	; 0x16
 158:	28 2f       	mov	r18, r24
 15a:	30 e0       	ldi	r19, 0x00	; 0
 15c:	c9 01       	movw	r24, r18
 15e:	88 0f       	add	r24, r24
 160:	99 1f       	adc	r25, r25
 162:	88 0f       	add	r24, r24
 164:	99 1f       	adc	r25, r25
 166:	88 0f       	add	r24, r24
 168:	99 1f       	adc	r25, r25
 16a:	82 0f       	add	r24, r18
 16c:	93 1f       	adc	r25, r19
 16e:	ac 01       	movw	r20, r24
 170:	40 50       	subi	r20, 0x00	; 0
 172:	50 40       	sbci	r21, 0x00	; 0
 174:	8b 81       	ldd	r24, Y+3	; 0x03
 176:	9c 81       	ldd	r25, Y+4	; 0x04
 178:	9c 01       	movw	r18, r24
 17a:	2e 5f       	subi	r18, 0xFE	; 254
 17c:	3f 4f       	sbci	r19, 0xFF	; 255
 17e:	ca 01       	movw	r24, r20
 180:	b9 01       	movw	r22, r18
 182:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericCreate>
 186:	81 e0       	ldi	r24, 0x01	; 1
 188:	8d 83       	std	Y+5, r24	; 0x05
 18a:	0f 90       	pop	r0
 18c:	0f be       	out	0x3f, r0	; 63
 18e:	00 c0       	rjmp	.+0      	; 0x190 <xTaskGenericCreate+0x190>
 190:	8f ef       	ldi	r24, 0xFF	; 255
 192:	8d 83       	std	Y+5, r24	; 0x05
 194:	8d 81       	ldd	r24, Y+5	; 0x05
 196:	81 30       	cpi	r24, 0x01	; 1
 198:	01 f4       	brne	.+0      	; 0x19a <xTaskGenericCreate+0x19a>
 19a:	80 91 00 00 	lds	r24, 0x0000
 19e:	88 23       	and	r24, r24
 1a0:	01 f0       	breq	.+0      	; 0x1a2 <xTaskGenericCreate+0x1a2>
 1a2:	e0 91 00 00 	lds	r30, 0x0000
 1a6:	f0 91 00 00 	lds	r31, 0x0000
 1aa:	96 89       	ldd	r25, Z+22	; 0x16
 1ac:	8e 85       	ldd	r24, Y+14	; 0x0e
 1ae:	98 17       	cp	r25, r24
 1b0:	00 f4       	brcc	.+0      	; 0x1b2 <xTaskGenericCreate+0x1b2>
 1b2:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericCreate>
 1b6:	8d 81       	ldd	r24, Y+5	; 0x05
 1b8:	64 96       	adiw	r28, 0x14	; 20
 1ba:	0f b6       	in	r0, 0x3f	; 63
 1bc:	f8 94       	cli
 1be:	de bf       	out	0x3e, r29	; 62
 1c0:	0f be       	out	0x3f, r0	; 63
 1c2:	cd bf       	out	0x3d, r28	; 61
 1c4:	cf 91       	pop	r28
 1c6:	df 91       	pop	r29
 1c8:	1f 91       	pop	r17
 1ca:	0f 91       	pop	r16
 1cc:	ff 90       	pop	r15
 1ce:	ef 90       	pop	r14
 1d0:	df 90       	pop	r13
 1d2:	cf 90       	pop	r12
 1d4:	bf 90       	pop	r11
 1d6:	af 90       	pop	r10
 1d8:	08 95       	ret

Disassembly of section .text.vTaskDelete:

00000000 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vTaskDelete+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <vTaskDelete+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <vTaskDelete+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	9c 83       	std	Y+4, r25	; 0x04
  10:	8b 83       	std	Y+3, r24	; 0x03
  12:	0f b6       	in	r0, 0x3f	; 63
  14:	f8 94       	cli
  16:	0f 92       	push	r0
  18:	20 91 00 00 	lds	r18, 0x0000
		vPortFree( pxTCB );
  1c:	30 91 00 00 	lds	r19, 0x0000
  20:	8b 81       	ldd	r24, Y+3	; 0x03
	}
  22:	9c 81       	ldd	r25, Y+4	; 0x04
  24:	82 17       	cp	r24, r18
  26:	93 07       	cpc	r25, r19
  28:	01 f4       	brne	.+0      	; 0x2a <vTaskDelete+0x2a>
  2a:	1c 82       	std	Y+4, r1	; 0x04
  2c:	1b 82       	std	Y+3, r1	; 0x03
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f4       	brne	.+0      	; 0x36 <vTaskDelete+0x36>
  36:	80 91 00 00 	lds	r24, 0x0000
  3a:	90 91 00 00 	lds	r25, 0x0000
  3e:	9e 83       	std	Y+6, r25	; 0x06
  40:	8d 83       	std	Y+5, r24	; 0x05
  42:	00 c0       	rjmp	.+0      	; 0x44 <vTaskDelete+0x44>
  44:	8b 81       	ldd	r24, Y+3	; 0x03
  46:	9c 81       	ldd	r25, Y+4	; 0x04
  48:	9e 83       	std	Y+6, r25	; 0x06
  4a:	8d 83       	std	Y+5, r24	; 0x05
  4c:	8d 81       	ldd	r24, Y+5	; 0x05
  4e:	9e 81       	ldd	r25, Y+6	; 0x06
  50:	9a 83       	std	Y+2, r25	; 0x02
  52:	89 83       	std	Y+1, r24	; 0x01
  54:	89 81       	ldd	r24, Y+1	; 0x01
  56:	9a 81       	ldd	r25, Y+2	; 0x02
  58:	02 96       	adiw	r24, 0x02	; 2
  5a:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  5e:	e9 81       	ldd	r30, Y+1	; 0x01
  60:	fa 81       	ldd	r31, Y+2	; 0x02
  62:	84 89       	ldd	r24, Z+20	; 0x14
  64:	95 89       	ldd	r25, Z+21	; 0x15
  66:	00 97       	sbiw	r24, 0x00	; 0
  68:	01 f0       	breq	.+0      	; 0x6a <vTaskDelete+0x6a>
  6a:	89 81       	ldd	r24, Y+1	; 0x01
  6c:	9a 81       	ldd	r25, Y+2	; 0x02
  6e:	0c 96       	adiw	r24, 0x0c	; 12
  70:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  74:	89 81       	ldd	r24, Y+1	; 0x01
  76:	9a 81       	ldd	r25, Y+2	; 0x02
  78:	9c 01       	movw	r18, r24
  7a:	2e 5f       	subi	r18, 0xFE	; 254
  7c:	3f 4f       	sbci	r19, 0xFF	; 255
  7e:	80 e0       	ldi	r24, 0x00	; 0
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	b9 01       	movw	r22, r18
  84:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  88:	80 91 00 00 	lds	r24, 0x0000
  8c:	8f 5f       	subi	r24, 0xFF	; 255
  8e:	80 93 00 00 	sts	0x0000, r24
  92:	80 91 00 00 	lds	r24, 0x0000
  96:	8f 5f       	subi	r24, 0xFF	; 255
  98:	80 93 00 00 	sts	0x0000, r24
  9c:	0f 90       	pop	r0
  9e:	0f be       	out	0x3f, r0	; 63
  a0:	80 91 00 00 	lds	r24, 0x0000
  a4:	88 23       	and	r24, r24
  a6:	01 f0       	breq	.+0      	; 0xa8 <vTaskDelete+0xa8>
  a8:	8b 81       	ldd	r24, Y+3	; 0x03
  aa:	9c 81       	ldd	r25, Y+4	; 0x04
  ac:	00 97       	sbiw	r24, 0x00	; 0
  ae:	01 f4       	brne	.+0      	; 0xb0 <vTaskDelete+0xb0>
  b0:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  b4:	26 96       	adiw	r28, 0x06	; 6
  b6:	0f b6       	in	r0, 0x3f	; 63
  b8:	f8 94       	cli
  ba:	de bf       	out	0x3e, r29	; 62
  bc:	0f be       	out	0x3f, r0	; 63
  be:	cd bf       	out	0x3d, r28	; 61
  c0:	cf 91       	pop	r28
  c2:	df 91       	pop	r29
  c4:	08 95       	ret

Disassembly of section .text.vTaskDelayUntil:

00000000 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9e 83       	std	Y+6, r25	; 0x06
  16:	8d 83       	std	Y+5, r24	; 0x05
  18:	78 87       	std	Y+8, r23	; 0x08
		vPortFree( pxTCB );
  1a:	6f 83       	std	Y+7, r22	; 0x07
  1c:	19 82       	std	Y+1, r1	; 0x01
  1e:	0e 94 00 00 	call	0	; 0x0 <vTaskDelayUntil>
	}
  22:	ed 81       	ldd	r30, Y+5	; 0x05
  24:	fe 81       	ldd	r31, Y+6	; 0x06
  26:	20 81       	ld	r18, Z
  28:	31 81       	ldd	r19, Z+1	; 0x01
  2a:	8f 81       	ldd	r24, Y+7	; 0x07
  2c:	98 85       	ldd	r25, Y+8	; 0x08
  2e:	82 0f       	add	r24, r18
  30:	93 1f       	adc	r25, r19
  32:	9c 83       	std	Y+4, r25	; 0x04
  34:	8b 83       	std	Y+3, r24	; 0x03
  36:	ed 81       	ldd	r30, Y+5	; 0x05
  38:	fe 81       	ldd	r31, Y+6	; 0x06
  3a:	20 81       	ld	r18, Z
  3c:	31 81       	ldd	r19, Z+1	; 0x01
  3e:	80 91 00 00 	lds	r24, 0x0000
  42:	90 91 00 00 	lds	r25, 0x0000
  46:	82 17       	cp	r24, r18
  48:	93 07       	cpc	r25, r19
  4a:	00 f4       	brcc	.+0      	; 0x4c <vTaskDelayUntil+0x4c>
  4c:	ed 81       	ldd	r30, Y+5	; 0x05
  4e:	fe 81       	ldd	r31, Y+6	; 0x06
  50:	20 81       	ld	r18, Z
  52:	31 81       	ldd	r19, Z+1	; 0x01
  54:	8b 81       	ldd	r24, Y+3	; 0x03
  56:	9c 81       	ldd	r25, Y+4	; 0x04
  58:	82 17       	cp	r24, r18
  5a:	93 07       	cpc	r25, r19
  5c:	00 f4       	brcc	.+0      	; 0x5e <vTaskDelayUntil+0x5e>
  5e:	20 91 00 00 	lds	r18, 0x0000
  62:	30 91 00 00 	lds	r19, 0x0000
  66:	8b 81       	ldd	r24, Y+3	; 0x03
  68:	9c 81       	ldd	r25, Y+4	; 0x04
  6a:	28 17       	cp	r18, r24
  6c:	39 07       	cpc	r19, r25
  6e:	00 f4       	brcc	.+0      	; 0x70 <vTaskDelayUntil+0x70>
  70:	81 e0       	ldi	r24, 0x01	; 1
  72:	89 83       	std	Y+1, r24	; 0x01
  74:	00 c0       	rjmp	.+0      	; 0x76 <vTaskDelayUntil+0x76>
  76:	ed 81       	ldd	r30, Y+5	; 0x05
  78:	fe 81       	ldd	r31, Y+6	; 0x06
  7a:	20 81       	ld	r18, Z
  7c:	31 81       	ldd	r19, Z+1	; 0x01
  7e:	8b 81       	ldd	r24, Y+3	; 0x03
  80:	9c 81       	ldd	r25, Y+4	; 0x04
  82:	82 17       	cp	r24, r18
  84:	93 07       	cpc	r25, r19
  86:	00 f0       	brcs	.+0      	; 0x88 <vTaskDelayUntil+0x88>
  88:	20 91 00 00 	lds	r18, 0x0000
  8c:	30 91 00 00 	lds	r19, 0x0000
  90:	8b 81       	ldd	r24, Y+3	; 0x03
  92:	9c 81       	ldd	r25, Y+4	; 0x04
  94:	28 17       	cp	r18, r24
  96:	39 07       	cpc	r19, r25
  98:	00 f4       	brcc	.+0      	; 0x9a <vTaskDelayUntil+0x9a>
  9a:	81 e0       	ldi	r24, 0x01	; 1
  9c:	89 83       	std	Y+1, r24	; 0x01
  9e:	ed 81       	ldd	r30, Y+5	; 0x05
  a0:	fe 81       	ldd	r31, Y+6	; 0x06
  a2:	8b 81       	ldd	r24, Y+3	; 0x03
  a4:	9c 81       	ldd	r25, Y+4	; 0x04
  a6:	91 83       	std	Z+1, r25	; 0x01
  a8:	80 83       	st	Z, r24
  aa:	89 81       	ldd	r24, Y+1	; 0x01
  ac:	88 23       	and	r24, r24
  ae:	01 f0       	breq	.+0      	; 0xb0 <vTaskDelayUntil+0xb0>
  b0:	80 91 00 00 	lds	r24, 0x0000
  b4:	90 91 00 00 	lds	r25, 0x0000
  b8:	02 96       	adiw	r24, 0x02	; 2
  ba:	0e 94 00 00 	call	0	; 0x0 <vTaskDelayUntil>
  be:	8b 81       	ldd	r24, Y+3	; 0x03
  c0:	9c 81       	ldd	r25, Y+4	; 0x04
  c2:	0e 94 00 00 	call	0	; 0x0 <vTaskDelayUntil>
  c6:	0e 94 00 00 	call	0	; 0x0 <vTaskDelayUntil>
  ca:	8a 83       	std	Y+2, r24	; 0x02
  cc:	8a 81       	ldd	r24, Y+2	; 0x02
  ce:	88 23       	and	r24, r24
  d0:	01 f4       	brne	.+0      	; 0xd2 <vTaskDelayUntil+0xd2>
  d2:	0e 94 00 00 	call	0	; 0x0 <vTaskDelayUntil>
  d6:	28 96       	adiw	r28, 0x08	; 8
  d8:	0f b6       	in	r0, 0x3f	; 63
  da:	f8 94       	cli
  dc:	de bf       	out	0x3e, r29	; 62
  de:	0f be       	out	0x3f, r0	; 63
  e0:	cd bf       	out	0x3d, r28	; 61
  e2:	cf 91       	pop	r28
  e4:	df 91       	pop	r29
  e6:	08 95       	ret

Disassembly of section .text.vTaskDelay:

00000000 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vTaskDelay+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <vTaskDelay+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	9d 83       	std	Y+5, r25	; 0x05
  10:	8c 83       	std	Y+4, r24	; 0x04
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	8c 81       	ldd	r24, Y+4	; 0x04
  16:	9d 81       	ldd	r25, Y+5	; 0x05
  18:	00 97       	sbiw	r24, 0x00	; 0
		vPortFree( pxTCB );
  1a:	01 f0       	breq	.+0      	; 0x1c <vTaskDelay+0x1c>
  1c:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
  20:	20 91 00 00 	lds	r18, 0x0000
	}
  24:	30 91 00 00 	lds	r19, 0x0000
  28:	8c 81       	ldd	r24, Y+4	; 0x04
  2a:	9d 81       	ldd	r25, Y+5	; 0x05
  2c:	82 0f       	add	r24, r18
  2e:	93 1f       	adc	r25, r19
  30:	9b 83       	std	Y+3, r25	; 0x03
  32:	8a 83       	std	Y+2, r24	; 0x02
  34:	80 91 00 00 	lds	r24, 0x0000
  38:	90 91 00 00 	lds	r25, 0x0000
  3c:	02 96       	adiw	r24, 0x02	; 2
  3e:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
  42:	8a 81       	ldd	r24, Y+2	; 0x02
  44:	9b 81       	ldd	r25, Y+3	; 0x03
  46:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
  4a:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
  4e:	89 83       	std	Y+1, r24	; 0x01
  50:	89 81       	ldd	r24, Y+1	; 0x01
  52:	88 23       	and	r24, r24
  54:	01 f4       	brne	.+0      	; 0x56 <vTaskDelay+0x56>
  56:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
  5a:	0f 90       	pop	r0
  5c:	0f 90       	pop	r0
  5e:	0f 90       	pop	r0
  60:	0f 90       	pop	r0
  62:	0f 90       	pop	r0
  64:	cf 91       	pop	r28
  66:	df 91       	pop	r29
  68:	08 95       	ret

Disassembly of section .text.vTaskStartScheduler:

00000000 <vTaskStartScheduler>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	df 93       	push	r29
  10:	cf 93       	push	r28
  12:	0f 92       	push	r0
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	20 e0       	ldi	r18, 0x00	; 0
		vPortFree( pxTCB );
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	80 e0       	ldi	r24, 0x00	; 0
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	b9 01       	movw	r22, r18
	}
  22:	4a ef       	ldi	r20, 0xFA	; 250
  24:	50 e0       	ldi	r21, 0x00	; 0
  26:	20 e0       	ldi	r18, 0x00	; 0
  28:	30 e0       	ldi	r19, 0x00	; 0
  2a:	00 e0       	ldi	r16, 0x00	; 0
  2c:	ee 24       	eor	r14, r14
  2e:	ff 24       	eor	r15, r15
  30:	cc 24       	eor	r12, r12
  32:	dd 24       	eor	r13, r13
  34:	aa 24       	eor	r10, r10
  36:	bb 24       	eor	r11, r11
  38:	0e 94 00 00 	call	0	; 0x0 <vTaskStartScheduler>
  3c:	89 83       	std	Y+1, r24	; 0x01
  3e:	89 81       	ldd	r24, Y+1	; 0x01
  40:	81 30       	cpi	r24, 0x01	; 1
  42:	01 f4       	brne	.+0      	; 0x44 <vTaskStartScheduler+0x44>
  44:	f8 94       	cli
  46:	81 e0       	ldi	r24, 0x01	; 1
  48:	80 93 00 00 	sts	0x0000, r24
  4c:	10 92 00 00 	sts	0x0000, r1
  50:	10 92 00 00 	sts	0x0000, r1
  54:	0e 94 00 00 	call	0	; 0x0 <vTaskStartScheduler>
  58:	0f 90       	pop	r0
  5a:	cf 91       	pop	r28
  5c:	df 91       	pop	r29
  5e:	0f 91       	pop	r16
  60:	ff 90       	pop	r15
  62:	ef 90       	pop	r14
  64:	df 90       	pop	r13
  66:	cf 90       	pop	r12
  68:	bf 90       	pop	r11
  6a:	af 90       	pop	r10
  6c:	08 95       	ret

Disassembly of section .text.vTaskEndScheduler:

00000000 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	f8 94       	cli
   a:	10 92 00 00 	sts	0x0000, r1
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	0e 94 00 00 	call	0	; 0x0 <vTaskEndScheduler>
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.vTaskSuspendAll:

00000000 <vTaskSuspendAll>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	80 91 00 00 	lds	r24, 0x0000
   c:	8f 5f       	subi	r24, 0xFF	; 255
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	80 93 00 00 	sts	0x0000, r24
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.xTaskResumeAll:

00000000 <xTaskResumeAll>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <xTaskResumeAll+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <xTaskResumeAll+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	1a 82       	std	Y+2, r1	; 0x02
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	0f b6       	in	r0, 0x3f	; 63
  10:	f8 94       	cli
  12:	0f 92       	push	r0
  14:	80 91 00 00 	lds	r24, 0x0000
  18:	81 50       	subi	r24, 0x01	; 1
		vPortFree( pxTCB );
  1a:	80 93 00 00 	sts	0x0000, r24
  1e:	80 91 00 00 	lds	r24, 0x0000
	}
  22:	88 23       	and	r24, r24
  24:	01 f0       	breq	.+0      	; 0x26 <xTaskResumeAll+0x26>
  26:	00 c0       	rjmp	.+0      	; 0x28 <xTaskResumeAll+0x28>
  28:	80 91 00 00 	lds	r24, 0x0000
  2c:	88 23       	and	r24, r24
  2e:	01 f4       	brne	.+0      	; 0x30 <xTaskResumeAll+0x30>
  30:	00 c0       	rjmp	.+0      	; 0x32 <xTaskResumeAll+0x32>
  32:	19 82       	std	Y+1, r1	; 0x01
  34:	00 c0       	rjmp	.+0      	; 0x36 <xTaskResumeAll+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	86 81       	ldd	r24, Z+6	; 0x06
  40:	97 81       	ldd	r25, Z+7	; 0x07
  42:	9c 83       	std	Y+4, r25	; 0x04
  44:	8b 83       	std	Y+3, r24	; 0x03
  46:	8b 81       	ldd	r24, Y+3	; 0x03
  48:	9c 81       	ldd	r25, Y+4	; 0x04
  4a:	0c 96       	adiw	r24, 0x0c	; 12
  4c:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeAll>
  50:	8b 81       	ldd	r24, Y+3	; 0x03
  52:	9c 81       	ldd	r25, Y+4	; 0x04
  54:	02 96       	adiw	r24, 0x02	; 2
  56:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeAll>
  5a:	eb 81       	ldd	r30, Y+3	; 0x03
  5c:	fc 81       	ldd	r31, Y+4	; 0x04
  5e:	96 89       	ldd	r25, Z+22	; 0x16
  60:	80 91 00 00 	lds	r24, 0x0000
  64:	89 17       	cp	r24, r25
  66:	00 f4       	brcc	.+0      	; 0x68 <xTaskResumeAll+0x68>
  68:	eb 81       	ldd	r30, Y+3	; 0x03
  6a:	fc 81       	ldd	r31, Y+4	; 0x04
  6c:	86 89       	ldd	r24, Z+22	; 0x16
  6e:	80 93 00 00 	sts	0x0000, r24
  72:	eb 81       	ldd	r30, Y+3	; 0x03
  74:	fc 81       	ldd	r31, Y+4	; 0x04
  76:	86 89       	ldd	r24, Z+22	; 0x16
  78:	28 2f       	mov	r18, r24
  7a:	30 e0       	ldi	r19, 0x00	; 0
  7c:	c9 01       	movw	r24, r18
  7e:	88 0f       	add	r24, r24
  80:	99 1f       	adc	r25, r25
  82:	88 0f       	add	r24, r24
  84:	99 1f       	adc	r25, r25
  86:	88 0f       	add	r24, r24
  88:	99 1f       	adc	r25, r25
  8a:	82 0f       	add	r24, r18
  8c:	93 1f       	adc	r25, r19
  8e:	80 50       	subi	r24, 0x00	; 0
  90:	90 40       	sbci	r25, 0x00	; 0
  92:	2b 81       	ldd	r18, Y+3	; 0x03
  94:	3c 81       	ldd	r19, Y+4	; 0x04
  96:	2e 5f       	subi	r18, 0xFE	; 254
  98:	3f 4f       	sbci	r19, 0xFF	; 255
  9a:	b9 01       	movw	r22, r18
  9c:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeAll>
  a0:	eb 81       	ldd	r30, Y+3	; 0x03
  a2:	fc 81       	ldd	r31, Y+4	; 0x04
  a4:	96 89       	ldd	r25, Z+22	; 0x16
  a6:	e0 91 00 00 	lds	r30, 0x0000
  aa:	f0 91 00 00 	lds	r31, 0x0000
  ae:	86 89       	ldd	r24, Z+22	; 0x16
  b0:	98 17       	cp	r25, r24
  b2:	00 f0       	brcs	.+0      	; 0xb4 <xTaskResumeAll+0xb4>
  b4:	81 e0       	ldi	r24, 0x01	; 1
  b6:	89 83       	std	Y+1, r24	; 0x01
  b8:	80 91 00 00 	lds	r24, 0x0000
  bc:	88 23       	and	r24, r24
  be:	01 f0       	breq	.+0      	; 0xc0 <xTaskResumeAll+0xc0>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <xTaskResumeAll+0xc2>
  c2:	80 91 00 00 	lds	r24, 0x0000
  c6:	88 23       	and	r24, r24
  c8:	01 f0       	breq	.+0      	; 0xca <xTaskResumeAll+0xca>
  ca:	00 c0       	rjmp	.+0      	; 0xcc <xTaskResumeAll+0xcc>
  cc:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeAll>
  d0:	80 91 00 00 	lds	r24, 0x0000
  d4:	81 50       	subi	r24, 0x01	; 1
  d6:	80 93 00 00 	sts	0x0000, r24
  da:	80 91 00 00 	lds	r24, 0x0000
  de:	88 23       	and	r24, r24
  e0:	01 f4       	brne	.+0      	; 0xe2 <xTaskResumeAll+0xe2>
  e2:	81 e0       	ldi	r24, 0x01	; 1
  e4:	89 83       	std	Y+1, r24	; 0x01
  e6:	89 81       	ldd	r24, Y+1	; 0x01
  e8:	81 30       	cpi	r24, 0x01	; 1
  ea:	01 f0       	breq	.+0      	; 0xec <xTaskResumeAll+0xec>
  ec:	80 91 00 00 	lds	r24, 0x0000
  f0:	81 30       	cpi	r24, 0x01	; 1
  f2:	01 f4       	brne	.+0      	; 0xf4 <xTaskResumeAll+0xf4>
  f4:	81 e0       	ldi	r24, 0x01	; 1
  f6:	8a 83       	std	Y+2, r24	; 0x02
  f8:	10 92 00 00 	sts	0x0000, r1
  fc:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeAll>
 100:	0f 90       	pop	r0
 102:	0f be       	out	0x3f, r0	; 63
 104:	8a 81       	ldd	r24, Y+2	; 0x02
 106:	0f 90       	pop	r0
 108:	0f 90       	pop	r0
 10a:	0f 90       	pop	r0
 10c:	0f 90       	pop	r0
 10e:	cf 91       	pop	r28
 110:	df 91       	pop	r29
 112:	08 95       	ret

Disassembly of section .text.xTaskGetTickCount:

00000000 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <xTaskGetTickCount+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	0f 92       	push	r0
  10:	80 91 00 00 	lds	r24, 0x0000
  14:	90 91 00 00 	lds	r25, 0x0000
  18:	9a 83       	std	Y+2, r25	; 0x02
		vPortFree( pxTCB );
  1a:	89 83       	std	Y+1, r24	; 0x01
  1c:	0f 90       	pop	r0
  1e:	0f be       	out	0x3f, r0	; 63
  20:	89 81       	ldd	r24, Y+1	; 0x01
	}
  22:	9a 81       	ldd	r25, Y+2	; 0x02
  24:	0f 90       	pop	r0
  26:	0f 90       	pop	r0
  28:	cf 91       	pop	r28
  2a:	df 91       	pop	r29
  2c:	08 95       	ret

Disassembly of section .text.xTaskGetTickCountFromISR:

00000000 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <xTaskGetTickCountFromISR+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	19 82       	std	Y+1, r1	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	80 91 00 00 	lds	r24, 0x0000
  12:	90 91 00 00 	lds	r25, 0x0000
  16:	9b 83       	std	Y+3, r25	; 0x03
  18:	8a 83       	std	Y+2, r24	; 0x02
		vPortFree( pxTCB );
  1a:	8a 81       	ldd	r24, Y+2	; 0x02
  1c:	9b 81       	ldd	r25, Y+3	; 0x03
  1e:	0f 90       	pop	r0
  20:	0f 90       	pop	r0
	}
  22:	0f 90       	pop	r0
  24:	cf 91       	pop	r28
  26:	df 91       	pop	r29
  28:	08 95       	ret

Disassembly of section .text.uxTaskGetNumberOfTasks:

00000000 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	80 91 00 00 	lds	r24, 0x0000
   c:	cf 91       	pop	r28
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	df 91       	pop	r29
  10:	08 95       	ret

Disassembly of section .text.vTaskIncrementTick:

00000000 <vTaskIncrementTick>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vTaskIncrementTick+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <vTaskIncrementTick+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <vTaskIncrementTick+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	80 91 00 00 	lds	r24, 0x0000
  12:	88 23       	and	r24, r24
  14:	01 f0       	breq	.+0      	; 0x16 <vTaskIncrementTick+0x16>
  16:	00 c0       	rjmp	.+0      	; 0x18 <vTaskIncrementTick+0x18>
  18:	80 91 00 00 	lds	r24, 0x0000
		vPortFree( pxTCB );
  1c:	90 91 00 00 	lds	r25, 0x0000
  20:	01 96       	adiw	r24, 0x01	; 1
	}
  22:	90 93 00 00 	sts	0x0000, r25
  26:	80 93 00 00 	sts	0x0000, r24
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f4       	brne	.+0      	; 0x36 <vTaskIncrementTick+0x36>
  36:	80 91 00 00 	lds	r24, 0x0000
  3a:	90 91 00 00 	lds	r25, 0x0000
  3e:	9c 83       	std	Y+4, r25	; 0x04
  40:	8b 83       	std	Y+3, r24	; 0x03
  42:	80 91 00 00 	lds	r24, 0x0000
  46:	90 91 00 00 	lds	r25, 0x0000
  4a:	90 93 00 00 	sts	0x0000, r25
  4e:	80 93 00 00 	sts	0x0000, r24
  52:	8b 81       	ldd	r24, Y+3	; 0x03
  54:	9c 81       	ldd	r25, Y+4	; 0x04
  56:	90 93 00 00 	sts	0x0000, r25
  5a:	80 93 00 00 	sts	0x0000, r24
  5e:	80 91 00 00 	lds	r24, 0x0000
  62:	8f 5f       	subi	r24, 0xFF	; 255
  64:	80 93 00 00 	sts	0x0000, r24
  68:	e0 91 00 00 	lds	r30, 0x0000
  6c:	f0 91 00 00 	lds	r31, 0x0000
  70:	80 81       	ld	r24, Z
  72:	88 23       	and	r24, r24
  74:	01 f4       	brne	.+0      	; 0x76 <vTaskIncrementTick+0x76>
  76:	8f ef       	ldi	r24, 0xFF	; 255
  78:	9f ef       	ldi	r25, 0xFF	; 255
  7a:	90 93 00 00 	sts	0x0000, r25
  7e:	80 93 00 00 	sts	0x0000, r24
  82:	00 c0       	rjmp	.+0      	; 0x84 <vTaskIncrementTick+0x84>
  84:	e0 91 00 00 	lds	r30, 0x0000
  88:	f0 91 00 00 	lds	r31, 0x0000
  8c:	05 80       	ldd	r0, Z+5	; 0x05
  8e:	f6 81       	ldd	r31, Z+6	; 0x06
  90:	e0 2d       	mov	r30, r0
  92:	86 81       	ldd	r24, Z+6	; 0x06
  94:	97 81       	ldd	r25, Z+7	; 0x07
  96:	9e 83       	std	Y+6, r25	; 0x06
  98:	8d 83       	std	Y+5, r24	; 0x05
  9a:	ed 81       	ldd	r30, Y+5	; 0x05
  9c:	fe 81       	ldd	r31, Y+6	; 0x06
  9e:	82 81       	ldd	r24, Z+2	; 0x02
  a0:	93 81       	ldd	r25, Z+3	; 0x03
  a2:	90 93 00 00 	sts	0x0000, r25
  a6:	80 93 00 00 	sts	0x0000, r24
  aa:	20 91 00 00 	lds	r18, 0x0000
  ae:	30 91 00 00 	lds	r19, 0x0000
  b2:	80 91 00 00 	lds	r24, 0x0000
  b6:	90 91 00 00 	lds	r25, 0x0000
  ba:	28 17       	cp	r18, r24
  bc:	39 07       	cpc	r19, r25
  be:	00 f4       	brcc	.+0      	; 0xc0 <vTaskIncrementTick+0xc0>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <vTaskIncrementTick+0xc2>
  c2:	e0 91 00 00 	lds	r30, 0x0000
  c6:	f0 91 00 00 	lds	r31, 0x0000
  ca:	80 81       	ld	r24, Z
  cc:	88 23       	and	r24, r24
  ce:	01 f4       	brne	.+0      	; 0xd0 <vTaskIncrementTick+0xd0>
  d0:	8f ef       	ldi	r24, 0xFF	; 255
  d2:	9f ef       	ldi	r25, 0xFF	; 255
  d4:	90 93 00 00 	sts	0x0000, r25
  d8:	80 93 00 00 	sts	0x0000, r24
  dc:	00 c0       	rjmp	.+0      	; 0xde <vTaskIncrementTick+0xde>
  de:	e0 91 00 00 	lds	r30, 0x0000
  e2:	f0 91 00 00 	lds	r31, 0x0000
  e6:	05 80       	ldd	r0, Z+5	; 0x05
  e8:	f6 81       	ldd	r31, Z+6	; 0x06
  ea:	e0 2d       	mov	r30, r0
  ec:	86 81       	ldd	r24, Z+6	; 0x06
  ee:	97 81       	ldd	r25, Z+7	; 0x07
  f0:	9e 83       	std	Y+6, r25	; 0x06
  f2:	8d 83       	std	Y+5, r24	; 0x05
  f4:	ed 81       	ldd	r30, Y+5	; 0x05
  f6:	fe 81       	ldd	r31, Y+6	; 0x06
  f8:	82 81       	ldd	r24, Z+2	; 0x02
  fa:	93 81       	ldd	r25, Z+3	; 0x03
  fc:	9a 83       	std	Y+2, r25	; 0x02
  fe:	89 83       	std	Y+1, r24	; 0x01
 100:	20 91 00 00 	lds	r18, 0x0000
 104:	30 91 00 00 	lds	r19, 0x0000
 108:	89 81       	ldd	r24, Y+1	; 0x01
 10a:	9a 81       	ldd	r25, Y+2	; 0x02
 10c:	28 17       	cp	r18, r24
 10e:	39 07       	cpc	r19, r25
 110:	00 f4       	brcc	.+0      	; 0x112 <vTaskIncrementTick+0x112>
 112:	89 81       	ldd	r24, Y+1	; 0x01
 114:	9a 81       	ldd	r25, Y+2	; 0x02
 116:	90 93 00 00 	sts	0x0000, r25
 11a:	80 93 00 00 	sts	0x0000, r24
 11e:	00 c0       	rjmp	.+0      	; 0x120 <vTaskIncrementTick+0x120>
 120:	8d 81       	ldd	r24, Y+5	; 0x05
 122:	9e 81       	ldd	r25, Y+6	; 0x06
 124:	02 96       	adiw	r24, 0x02	; 2
 126:	0e 94 00 00 	call	0	; 0x0 <vTaskIncrementTick>
 12a:	ed 81       	ldd	r30, Y+5	; 0x05
 12c:	fe 81       	ldd	r31, Y+6	; 0x06
 12e:	84 89       	ldd	r24, Z+20	; 0x14
 130:	95 89       	ldd	r25, Z+21	; 0x15
 132:	00 97       	sbiw	r24, 0x00	; 0
 134:	01 f0       	breq	.+0      	; 0x136 <vTaskIncrementTick+0x136>
 136:	8d 81       	ldd	r24, Y+5	; 0x05
 138:	9e 81       	ldd	r25, Y+6	; 0x06
 13a:	0c 96       	adiw	r24, 0x0c	; 12
 13c:	0e 94 00 00 	call	0	; 0x0 <vTaskIncrementTick>
 140:	ed 81       	ldd	r30, Y+5	; 0x05
 142:	fe 81       	ldd	r31, Y+6	; 0x06
 144:	96 89       	ldd	r25, Z+22	; 0x16
 146:	80 91 00 00 	lds	r24, 0x0000
 14a:	89 17       	cp	r24, r25
 14c:	00 f4       	brcc	.+0      	; 0x14e <vTaskIncrementTick+0x14e>
 14e:	ed 81       	ldd	r30, Y+5	; 0x05
 150:	fe 81       	ldd	r31, Y+6	; 0x06
 152:	86 89       	ldd	r24, Z+22	; 0x16
 154:	80 93 00 00 	sts	0x0000, r24
 158:	ed 81       	ldd	r30, Y+5	; 0x05
 15a:	fe 81       	ldd	r31, Y+6	; 0x06
 15c:	86 89       	ldd	r24, Z+22	; 0x16
 15e:	28 2f       	mov	r18, r24
 160:	30 e0       	ldi	r19, 0x00	; 0
 162:	c9 01       	movw	r24, r18
 164:	88 0f       	add	r24, r24
 166:	99 1f       	adc	r25, r25
 168:	88 0f       	add	r24, r24
 16a:	99 1f       	adc	r25, r25
 16c:	88 0f       	add	r24, r24
 16e:	99 1f       	adc	r25, r25
 170:	82 0f       	add	r24, r18
 172:	93 1f       	adc	r25, r19
 174:	ac 01       	movw	r20, r24
 176:	40 50       	subi	r20, 0x00	; 0
 178:	50 40       	sbci	r21, 0x00	; 0
 17a:	8d 81       	ldd	r24, Y+5	; 0x05
 17c:	9e 81       	ldd	r25, Y+6	; 0x06
 17e:	9c 01       	movw	r18, r24
 180:	2e 5f       	subi	r18, 0xFE	; 254
 182:	3f 4f       	sbci	r19, 0xFF	; 255
 184:	ca 01       	movw	r24, r20
 186:	b9 01       	movw	r22, r18
 188:	0e 94 00 00 	call	0	; 0x0 <vTaskIncrementTick>
 18c:	00 c0       	rjmp	.+0      	; 0x18e <vTaskIncrementTick+0x18e>
 18e:	80 91 00 00 	lds	r24, 0x0000
 192:	8f 5f       	subi	r24, 0xFF	; 255
 194:	80 93 00 00 	sts	0x0000, r24
 198:	26 96       	adiw	r28, 0x06	; 6
 19a:	0f b6       	in	r0, 0x3f	; 63
 19c:	f8 94       	cli
 19e:	de bf       	out	0x3e, r29	; 62
 1a0:	0f be       	out	0x3f, r0	; 63
 1a2:	cd bf       	out	0x3d, r28	; 61
 1a4:	cf 91       	pop	r28
 1a6:	df 91       	pop	r29
 1a8:	08 95       	ret

Disassembly of section .text.vTaskSwitchContext:

00000000 <vTaskSwitchContext>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vTaskSwitchContext+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	80 91 00 00 	lds	r24, 0x0000
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	88 23       	and	r24, r24
  10:	01 f0       	breq	.+0      	; 0x12 <vTaskSwitchContext+0x12>
  12:	81 e0       	ldi	r24, 0x01	; 1
  14:	80 93 00 00 	sts	0x0000, r24
  18:	00 c0       	rjmp	.+0      	; 0x1a <vTaskSwitchContext+0x1a>
		vPortFree( pxTCB );
  1a:	80 91 00 00 	lds	r24, 0x0000
  1e:	81 50       	subi	r24, 0x01	; 1
  20:	80 93 00 00 	sts	0x0000, r24
	}
  24:	80 91 00 00 	lds	r24, 0x0000
  28:	28 2f       	mov	r18, r24
  2a:	30 e0       	ldi	r19, 0x00	; 0
  2c:	c9 01       	movw	r24, r18
  2e:	88 0f       	add	r24, r24
  30:	99 1f       	adc	r25, r25
  32:	88 0f       	add	r24, r24
  34:	99 1f       	adc	r25, r25
  36:	88 0f       	add	r24, r24
  38:	99 1f       	adc	r25, r25
  3a:	82 0f       	add	r24, r18
  3c:	93 1f       	adc	r25, r19
  3e:	fc 01       	movw	r30, r24
  40:	e0 50       	subi	r30, 0x00	; 0
  42:	f0 40       	sbci	r31, 0x00	; 0
  44:	80 81       	ld	r24, Z
  46:	88 23       	and	r24, r24
  48:	01 f0       	breq	.+0      	; 0x4a <vTaskSwitchContext+0x4a>
  4a:	80 91 00 00 	lds	r24, 0x0000
  4e:	28 2f       	mov	r18, r24
  50:	30 e0       	ldi	r19, 0x00	; 0
  52:	c9 01       	movw	r24, r18
  54:	88 0f       	add	r24, r24
  56:	99 1f       	adc	r25, r25
  58:	88 0f       	add	r24, r24
  5a:	99 1f       	adc	r25, r25
  5c:	88 0f       	add	r24, r24
  5e:	99 1f       	adc	r25, r25
  60:	82 0f       	add	r24, r18
  62:	93 1f       	adc	r25, r19
  64:	80 50       	subi	r24, 0x00	; 0
  66:	90 40       	sbci	r25, 0x00	; 0
  68:	9a 83       	std	Y+2, r25	; 0x02
  6a:	89 83       	std	Y+1, r24	; 0x01
  6c:	e9 81       	ldd	r30, Y+1	; 0x01
  6e:	fa 81       	ldd	r31, Y+2	; 0x02
  70:	01 80       	ldd	r0, Z+1	; 0x01
  72:	f2 81       	ldd	r31, Z+2	; 0x02
  74:	e0 2d       	mov	r30, r0
  76:	82 81       	ldd	r24, Z+2	; 0x02
  78:	93 81       	ldd	r25, Z+3	; 0x03
  7a:	e9 81       	ldd	r30, Y+1	; 0x01
  7c:	fa 81       	ldd	r31, Y+2	; 0x02
  7e:	92 83       	std	Z+2, r25	; 0x02
  80:	81 83       	std	Z+1, r24	; 0x01
  82:	e9 81       	ldd	r30, Y+1	; 0x01
  84:	fa 81       	ldd	r31, Y+2	; 0x02
  86:	21 81       	ldd	r18, Z+1	; 0x01
  88:	32 81       	ldd	r19, Z+2	; 0x02
  8a:	89 81       	ldd	r24, Y+1	; 0x01
  8c:	9a 81       	ldd	r25, Y+2	; 0x02
  8e:	03 96       	adiw	r24, 0x03	; 3
  90:	28 17       	cp	r18, r24
  92:	39 07       	cpc	r19, r25
  94:	01 f4       	brne	.+0      	; 0x96 <vTaskSwitchContext+0x96>
  96:	e9 81       	ldd	r30, Y+1	; 0x01
  98:	fa 81       	ldd	r31, Y+2	; 0x02
  9a:	01 80       	ldd	r0, Z+1	; 0x01
  9c:	f2 81       	ldd	r31, Z+2	; 0x02
  9e:	e0 2d       	mov	r30, r0
  a0:	82 81       	ldd	r24, Z+2	; 0x02
  a2:	93 81       	ldd	r25, Z+3	; 0x03
  a4:	e9 81       	ldd	r30, Y+1	; 0x01
  a6:	fa 81       	ldd	r31, Y+2	; 0x02
  a8:	92 83       	std	Z+2, r25	; 0x02
  aa:	81 83       	std	Z+1, r24	; 0x01
  ac:	e9 81       	ldd	r30, Y+1	; 0x01
  ae:	fa 81       	ldd	r31, Y+2	; 0x02
  b0:	01 80       	ldd	r0, Z+1	; 0x01
  b2:	f2 81       	ldd	r31, Z+2	; 0x02
  b4:	e0 2d       	mov	r30, r0
  b6:	86 81       	ldd	r24, Z+6	; 0x06
  b8:	97 81       	ldd	r25, Z+7	; 0x07
  ba:	90 93 00 00 	sts	0x0000, r25
  be:	80 93 00 00 	sts	0x0000, r24
  c2:	0f 90       	pop	r0
  c4:	0f 90       	pop	r0
  c6:	cf 91       	pop	r28
  c8:	df 91       	pop	r29
  ca:	08 95       	ret

Disassembly of section .text.vTaskPlaceOnEventList:

00000000 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vTaskPlaceOnEventList+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <vTaskPlaceOnEventList+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <vTaskPlaceOnEventList+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	9c 83       	std	Y+4, r25	; 0x04
  10:	8b 83       	std	Y+3, r24	; 0x03
  12:	7e 83       	std	Y+6, r23	; 0x06
  14:	6d 83       	std	Y+5, r22	; 0x05
  16:	4b 81       	ldd	r20, Y+3	; 0x03
  18:	5c 81       	ldd	r21, Y+4	; 0x04
		vPortFree( pxTCB );
  1a:	80 91 00 00 	lds	r24, 0x0000
  1e:	90 91 00 00 	lds	r25, 0x0000
	}
  22:	9c 01       	movw	r18, r24
  24:	24 5f       	subi	r18, 0xF4	; 244
  26:	3f 4f       	sbci	r19, 0xFF	; 255
  28:	ca 01       	movw	r24, r20
  2a:	b9 01       	movw	r22, r18
  2c:	0e 94 00 00 	call	0	; 0x0 <vTaskPlaceOnEventList>
  30:	80 91 00 00 	lds	r24, 0x0000
  34:	90 91 00 00 	lds	r25, 0x0000
  38:	02 96       	adiw	r24, 0x02	; 2
  3a:	0e 94 00 00 	call	0	; 0x0 <vTaskPlaceOnEventList>
  3e:	20 91 00 00 	lds	r18, 0x0000
  42:	30 91 00 00 	lds	r19, 0x0000
  46:	8d 81       	ldd	r24, Y+5	; 0x05
  48:	9e 81       	ldd	r25, Y+6	; 0x06
  4a:	82 0f       	add	r24, r18
  4c:	93 1f       	adc	r25, r19
  4e:	9a 83       	std	Y+2, r25	; 0x02
  50:	89 83       	std	Y+1, r24	; 0x01
  52:	89 81       	ldd	r24, Y+1	; 0x01
  54:	9a 81       	ldd	r25, Y+2	; 0x02
  56:	0e 94 00 00 	call	0	; 0x0 <vTaskPlaceOnEventList>
  5a:	26 96       	adiw	r28, 0x06	; 6
  5c:	0f b6       	in	r0, 0x3f	; 63
  5e:	f8 94       	cli
  60:	de bf       	out	0x3e, r29	; 62
  62:	0f be       	out	0x3f, r0	; 63
  64:	cd bf       	out	0x3d, r28	; 61
  66:	cf 91       	pop	r28
  68:	df 91       	pop	r29
  6a:	08 95       	ret

Disassembly of section .text.xTaskRemoveFromEventList:

00000000 <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <xTaskRemoveFromEventList+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <xTaskRemoveFromEventList+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	9d 83       	std	Y+5, r25	; 0x05
  10:	8c 83       	std	Y+4, r24	; 0x04
  12:	ec 81       	ldd	r30, Y+4	; 0x04
  14:	fd 81       	ldd	r31, Y+5	; 0x05
  16:	05 80       	ldd	r0, Z+5	; 0x05
  18:	f6 81       	ldd	r31, Z+6	; 0x06
		vPortFree( pxTCB );
  1a:	e0 2d       	mov	r30, r0
  1c:	86 81       	ldd	r24, Z+6	; 0x06
  1e:	97 81       	ldd	r25, Z+7	; 0x07
  20:	9b 83       	std	Y+3, r25	; 0x03
	}
  22:	8a 83       	std	Y+2, r24	; 0x02
  24:	8a 81       	ldd	r24, Y+2	; 0x02
  26:	9b 81       	ldd	r25, Y+3	; 0x03
  28:	0c 96       	adiw	r24, 0x0c	; 12
  2a:	0e 94 00 00 	call	0	; 0x0 <xTaskRemoveFromEventList>
  2e:	80 91 00 00 	lds	r24, 0x0000
  32:	88 23       	and	r24, r24
  34:	01 f4       	brne	.+0      	; 0x36 <xTaskRemoveFromEventList+0x36>
  36:	8a 81       	ldd	r24, Y+2	; 0x02
  38:	9b 81       	ldd	r25, Y+3	; 0x03
  3a:	02 96       	adiw	r24, 0x02	; 2
  3c:	0e 94 00 00 	call	0	; 0x0 <xTaskRemoveFromEventList>
  40:	ea 81       	ldd	r30, Y+2	; 0x02
  42:	fb 81       	ldd	r31, Y+3	; 0x03
  44:	96 89       	ldd	r25, Z+22	; 0x16
  46:	80 91 00 00 	lds	r24, 0x0000
  4a:	89 17       	cp	r24, r25
  4c:	00 f4       	brcc	.+0      	; 0x4e <xTaskRemoveFromEventList+0x4e>
  4e:	ea 81       	ldd	r30, Y+2	; 0x02
  50:	fb 81       	ldd	r31, Y+3	; 0x03
  52:	86 89       	ldd	r24, Z+22	; 0x16
  54:	80 93 00 00 	sts	0x0000, r24
  58:	ea 81       	ldd	r30, Y+2	; 0x02
  5a:	fb 81       	ldd	r31, Y+3	; 0x03
  5c:	86 89       	ldd	r24, Z+22	; 0x16
  5e:	28 2f       	mov	r18, r24
  60:	30 e0       	ldi	r19, 0x00	; 0
  62:	c9 01       	movw	r24, r18
  64:	88 0f       	add	r24, r24
  66:	99 1f       	adc	r25, r25
  68:	88 0f       	add	r24, r24
  6a:	99 1f       	adc	r25, r25
  6c:	88 0f       	add	r24, r24
  6e:	99 1f       	adc	r25, r25
  70:	82 0f       	add	r24, r18
  72:	93 1f       	adc	r25, r19
  74:	ac 01       	movw	r20, r24
  76:	40 50       	subi	r20, 0x00	; 0
  78:	50 40       	sbci	r21, 0x00	; 0
  7a:	8a 81       	ldd	r24, Y+2	; 0x02
  7c:	9b 81       	ldd	r25, Y+3	; 0x03
  7e:	9c 01       	movw	r18, r24
  80:	2e 5f       	subi	r18, 0xFE	; 254
  82:	3f 4f       	sbci	r19, 0xFF	; 255
  84:	ca 01       	movw	r24, r20
  86:	b9 01       	movw	r22, r18
  88:	0e 94 00 00 	call	0	; 0x0 <xTaskRemoveFromEventList>
  8c:	00 c0       	rjmp	.+0      	; 0x8e <xTaskRemoveFromEventList+0x8e>
  8e:	8a 81       	ldd	r24, Y+2	; 0x02
  90:	9b 81       	ldd	r25, Y+3	; 0x03
  92:	9c 01       	movw	r18, r24
  94:	24 5f       	subi	r18, 0xF4	; 244
  96:	3f 4f       	sbci	r19, 0xFF	; 255
  98:	80 e0       	ldi	r24, 0x00	; 0
  9a:	90 e0       	ldi	r25, 0x00	; 0
  9c:	b9 01       	movw	r22, r18
  9e:	0e 94 00 00 	call	0	; 0x0 <xTaskRemoveFromEventList>
  a2:	ea 81       	ldd	r30, Y+2	; 0x02
  a4:	fb 81       	ldd	r31, Y+3	; 0x03
  a6:	96 89       	ldd	r25, Z+22	; 0x16
  a8:	e0 91 00 00 	lds	r30, 0x0000
  ac:	f0 91 00 00 	lds	r31, 0x0000
  b0:	86 89       	ldd	r24, Z+22	; 0x16
  b2:	98 17       	cp	r25, r24
  b4:	00 f0       	brcs	.+0      	; 0xb6 <xTaskRemoveFromEventList+0xb6>
  b6:	81 e0       	ldi	r24, 0x01	; 1
  b8:	89 83       	std	Y+1, r24	; 0x01
  ba:	00 c0       	rjmp	.+0      	; 0xbc <xTaskRemoveFromEventList+0xbc>
  bc:	19 82       	std	Y+1, r1	; 0x01
  be:	89 81       	ldd	r24, Y+1	; 0x01
  c0:	0f 90       	pop	r0
  c2:	0f 90       	pop	r0
  c4:	0f 90       	pop	r0
  c6:	0f 90       	pop	r0
  c8:	0f 90       	pop	r0
  ca:	cf 91       	pop	r28
  cc:	df 91       	pop	r29
  ce:	08 95       	ret

Disassembly of section .text.vTaskSetTimeOutState:

00000000 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <vTaskSetTimeOutState+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	80 91 00 00 	lds	r24, 0x0000
  12:	e9 81       	ldd	r30, Y+1	; 0x01
  14:	fa 81       	ldd	r31, Y+2	; 0x02
  16:	80 83       	st	Z, r24
  18:	80 91 00 00 	lds	r24, 0x0000
		vPortFree( pxTCB );
  1c:	90 91 00 00 	lds	r25, 0x0000
  20:	e9 81       	ldd	r30, Y+1	; 0x01
	}
  22:	fa 81       	ldd	r31, Y+2	; 0x02
  24:	92 83       	std	Z+2, r25	; 0x02
  26:	81 83       	std	Z+1, r24	; 0x01
  28:	0f 90       	pop	r0
  2a:	0f 90       	pop	r0
  2c:	cf 91       	pop	r28
  2e:	df 91       	pop	r29
  30:	08 95       	ret

Disassembly of section .text.xTaskCheckForTimeOut:

00000000 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <xTaskCheckForTimeOut+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <xTaskCheckForTimeOut+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	9b 83       	std	Y+3, r25	; 0x03
  10:	8a 83       	std	Y+2, r24	; 0x02
  12:	7d 83       	std	Y+5, r23	; 0x05
  14:	6c 83       	std	Y+4, r22	; 0x04
  16:	0f b6       	in	r0, 0x3f	; 63
  18:	f8 94       	cli
		vPortFree( pxTCB );
  1a:	0f 92       	push	r0
  1c:	ea 81       	ldd	r30, Y+2	; 0x02
  1e:	fb 81       	ldd	r31, Y+3	; 0x03
  20:	90 81       	ld	r25, Z
	}
  22:	80 91 00 00 	lds	r24, 0x0000
  26:	98 17       	cp	r25, r24
  28:	01 f0       	breq	.+0      	; 0x2a <xTaskCheckForTimeOut+0x2a>
  2a:	ea 81       	ldd	r30, Y+2	; 0x02
  2c:	fb 81       	ldd	r31, Y+3	; 0x03
  2e:	21 81       	ldd	r18, Z+1	; 0x01
  30:	32 81       	ldd	r19, Z+2	; 0x02
  32:	80 91 00 00 	lds	r24, 0x0000
  36:	90 91 00 00 	lds	r25, 0x0000
  3a:	82 17       	cp	r24, r18
  3c:	93 07       	cpc	r25, r19
  3e:	00 f0       	brcs	.+0      	; 0x40 <xTaskCheckForTimeOut+0x40>
  40:	81 e0       	ldi	r24, 0x01	; 1
  42:	89 83       	std	Y+1, r24	; 0x01
  44:	00 c0       	rjmp	.+0      	; 0x46 <xTaskCheckForTimeOut+0x46>
  46:	20 91 00 00 	lds	r18, 0x0000
  4a:	30 91 00 00 	lds	r19, 0x0000
  4e:	ea 81       	ldd	r30, Y+2	; 0x02
  50:	fb 81       	ldd	r31, Y+3	; 0x03
  52:	81 81       	ldd	r24, Z+1	; 0x01
  54:	92 81       	ldd	r25, Z+2	; 0x02
  56:	28 1b       	sub	r18, r24
  58:	39 0b       	sbc	r19, r25
  5a:	ec 81       	ldd	r30, Y+4	; 0x04
  5c:	fd 81       	ldd	r31, Y+5	; 0x05
  5e:	80 81       	ld	r24, Z
  60:	91 81       	ldd	r25, Z+1	; 0x01
  62:	28 17       	cp	r18, r24
  64:	39 07       	cpc	r19, r25
  66:	00 f4       	brcc	.+0      	; 0x68 <xTaskCheckForTimeOut+0x68>
  68:	ec 81       	ldd	r30, Y+4	; 0x04
  6a:	fd 81       	ldd	r31, Y+5	; 0x05
  6c:	40 81       	ld	r20, Z
  6e:	51 81       	ldd	r21, Z+1	; 0x01
  70:	ea 81       	ldd	r30, Y+2	; 0x02
  72:	fb 81       	ldd	r31, Y+3	; 0x03
  74:	21 81       	ldd	r18, Z+1	; 0x01
  76:	32 81       	ldd	r19, Z+2	; 0x02
  78:	80 91 00 00 	lds	r24, 0x0000
  7c:	90 91 00 00 	lds	r25, 0x0000
  80:	b9 01       	movw	r22, r18
  82:	68 1b       	sub	r22, r24
  84:	79 0b       	sbc	r23, r25
  86:	cb 01       	movw	r24, r22
  88:	84 0f       	add	r24, r20
  8a:	95 1f       	adc	r25, r21
  8c:	ec 81       	ldd	r30, Y+4	; 0x04
  8e:	fd 81       	ldd	r31, Y+5	; 0x05
  90:	91 83       	std	Z+1, r25	; 0x01
  92:	80 83       	st	Z, r24
  94:	8a 81       	ldd	r24, Y+2	; 0x02
  96:	9b 81       	ldd	r25, Y+3	; 0x03
  98:	0e 94 00 00 	call	0	; 0x0 <xTaskCheckForTimeOut>
  9c:	19 82       	std	Y+1, r1	; 0x01
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <xTaskCheckForTimeOut+0xa0>
  a0:	81 e0       	ldi	r24, 0x01	; 1
  a2:	89 83       	std	Y+1, r24	; 0x01
  a4:	0f 90       	pop	r0
  a6:	0f be       	out	0x3f, r0	; 63
  a8:	89 81       	ldd	r24, Y+1	; 0x01
  aa:	0f 90       	pop	r0
  ac:	0f 90       	pop	r0
  ae:	0f 90       	pop	r0
  b0:	0f 90       	pop	r0
  b2:	0f 90       	pop	r0
  b4:	cf 91       	pop	r28
  b6:	df 91       	pop	r29
  b8:	08 95       	ret

Disassembly of section .text.vTaskMissedYield:

00000000 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	81 e0       	ldi	r24, 0x01	; 1
   a:	80 93 00 00 	sts	0x0000, r24
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	cf 91       	pop	r28
  10:	df 91       	pop	r29
  12:	08 95       	ret

Disassembly of section .text.prvIdleTask:

00000000 <prvIdleTask>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvIdleTask+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	0e 94 00 00 	call	0	; 0x0 <prvIdleTask>
  12:	00 c0       	rjmp	.+0      	; 0x14 <__zero_reg__+0x13>

Disassembly of section .text.prvInitialiseTCBVariables:

00000000 <prvInitialiseTCBVariables>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	df 93       	push	r29
   6:	cf 93       	push	r28
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	29 97       	sbiw	r28, 0x09	; 9
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	0f b6       	in	r0, 0x3f	; 63
  10:	f8 94       	cli
  12:	de bf       	out	0x3e, r29	; 62
  14:	0f be       	out	0x3f, r0	; 63
  16:	cd bf       	out	0x3d, r28	; 61
  18:	9a 83       	std	Y+2, r25	; 0x02
		vPortFree( pxTCB );
  1a:	89 83       	std	Y+1, r24	; 0x01
  1c:	7c 83       	std	Y+4, r23	; 0x04
  1e:	6b 83       	std	Y+3, r22	; 0x03
  20:	4d 83       	std	Y+5, r20	; 0x05
	}
  22:	3f 83       	std	Y+7, r19	; 0x07
  24:	2e 83       	std	Y+6, r18	; 0x06
  26:	19 87       	std	Y+9, r17	; 0x09
  28:	08 87       	std	Y+8, r16	; 0x08
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	9a 81       	ldd	r25, Y+2	; 0x02
  2e:	49 96       	adiw	r24, 0x19	; 25
  30:	2b 81       	ldd	r18, Y+3	; 0x03
  32:	3c 81       	ldd	r19, Y+4	; 0x04
  34:	b9 01       	movw	r22, r18
  36:	48 e0       	ldi	r20, 0x08	; 8
  38:	50 e0       	ldi	r21, 0x00	; 0
  3a:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseTCBVariables>
  3e:	e9 81       	ldd	r30, Y+1	; 0x01
  40:	fa 81       	ldd	r31, Y+2	; 0x02
  42:	10 a2       	std	Z+32, r1	; 0x20
  44:	8d 81       	ldd	r24, Y+5	; 0x05
  46:	85 30       	cpi	r24, 0x05	; 5
  48:	00 f0       	brcs	.+0      	; 0x4a <prvInitialiseTCBVariables+0x4a>
  4a:	84 e0       	ldi	r24, 0x04	; 4
  4c:	8d 83       	std	Y+5, r24	; 0x05
  4e:	e9 81       	ldd	r30, Y+1	; 0x01
  50:	fa 81       	ldd	r31, Y+2	; 0x02
  52:	8d 81       	ldd	r24, Y+5	; 0x05
  54:	86 8b       	std	Z+22, r24	; 0x16
  56:	89 81       	ldd	r24, Y+1	; 0x01
  58:	9a 81       	ldd	r25, Y+2	; 0x02
  5a:	02 96       	adiw	r24, 0x02	; 2
  5c:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseTCBVariables>
  60:	89 81       	ldd	r24, Y+1	; 0x01
  62:	9a 81       	ldd	r25, Y+2	; 0x02
  64:	0c 96       	adiw	r24, 0x0c	; 12
  66:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseTCBVariables>
  6a:	e9 81       	ldd	r30, Y+1	; 0x01
  6c:	fa 81       	ldd	r31, Y+2	; 0x02
  6e:	89 81       	ldd	r24, Y+1	; 0x01
  70:	9a 81       	ldd	r25, Y+2	; 0x02
  72:	91 87       	std	Z+9, r25	; 0x09
  74:	80 87       	std	Z+8, r24	; 0x08
  76:	8d 81       	ldd	r24, Y+5	; 0x05
  78:	28 2f       	mov	r18, r24
  7a:	30 e0       	ldi	r19, 0x00	; 0
  7c:	85 e0       	ldi	r24, 0x05	; 5
  7e:	90 e0       	ldi	r25, 0x00	; 0
  80:	82 1b       	sub	r24, r18
  82:	93 0b       	sbc	r25, r19
  84:	e9 81       	ldd	r30, Y+1	; 0x01
  86:	fa 81       	ldd	r31, Y+2	; 0x02
  88:	95 87       	std	Z+13, r25	; 0x0d
  8a:	84 87       	std	Z+12, r24	; 0x0c
  8c:	e9 81       	ldd	r30, Y+1	; 0x01
  8e:	fa 81       	ldd	r31, Y+2	; 0x02
  90:	89 81       	ldd	r24, Y+1	; 0x01
  92:	9a 81       	ldd	r25, Y+2	; 0x02
  94:	93 8b       	std	Z+19, r25	; 0x13
  96:	82 8b       	std	Z+18, r24	; 0x12
  98:	29 96       	adiw	r28, 0x09	; 9
  9a:	0f b6       	in	r0, 0x3f	; 63
  9c:	f8 94       	cli
  9e:	de bf       	out	0x3e, r29	; 62
  a0:	0f be       	out	0x3f, r0	; 63
  a2:	cd bf       	out	0x3d, r28	; 61
  a4:	cf 91       	pop	r28
  a6:	df 91       	pop	r29
  a8:	1f 91       	pop	r17
  aa:	0f 91       	pop	r16
  ac:	08 95       	ret

Disassembly of section .text.prvInitialiseTaskLists:

00000000 <prvInitialiseTaskLists>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	19 82       	std	Y+1, r1	; 0x01
   c:	00 c0       	rjmp	.+0      	; 0xe <prvInitialiseTaskLists+0xe>
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	c9 01       	movw	r24, r18
  16:	88 0f       	add	r24, r24
  18:	99 1f       	adc	r25, r25
		vPortFree( pxTCB );
  1a:	88 0f       	add	r24, r24
  1c:	99 1f       	adc	r25, r25
  1e:	88 0f       	add	r24, r24
  20:	99 1f       	adc	r25, r25
	}
  22:	82 0f       	add	r24, r18
  24:	93 1f       	adc	r25, r19
  26:	80 50       	subi	r24, 0x00	; 0
  28:	90 40       	sbci	r25, 0x00	; 0
  2a:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseTaskLists>
  2e:	89 81       	ldd	r24, Y+1	; 0x01
  30:	8f 5f       	subi	r24, 0xFF	; 255
  32:	89 83       	std	Y+1, r24	; 0x01
  34:	89 81       	ldd	r24, Y+1	; 0x01
  36:	85 30       	cpi	r24, 0x05	; 5
  38:	00 f0       	brcs	.+0      	; 0x3a <prvInitialiseTaskLists+0x3a>
  3a:	80 e0       	ldi	r24, 0x00	; 0
  3c:	90 e0       	ldi	r25, 0x00	; 0
  3e:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseTaskLists>
  42:	80 e0       	ldi	r24, 0x00	; 0
  44:	90 e0       	ldi	r25, 0x00	; 0
  46:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseTaskLists>
  4a:	80 e0       	ldi	r24, 0x00	; 0
  4c:	90 e0       	ldi	r25, 0x00	; 0
  4e:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseTaskLists>
  52:	80 e0       	ldi	r24, 0x00	; 0
  54:	90 e0       	ldi	r25, 0x00	; 0
  56:	0e 94 00 00 	call	0	; 0x0 <prvInitialiseTaskLists>
  5a:	80 e0       	ldi	r24, 0x00	; 0
  5c:	90 e0       	ldi	r25, 0x00	; 0
  5e:	90 93 00 00 	sts	0x0000, r25
  62:	80 93 00 00 	sts	0x0000, r24
  66:	80 e0       	ldi	r24, 0x00	; 0
  68:	90 e0       	ldi	r25, 0x00	; 0
  6a:	90 93 00 00 	sts	0x0000, r25
  6e:	80 93 00 00 	sts	0x0000, r24
  72:	0f 90       	pop	r0
  74:	cf 91       	pop	r28
  76:	df 91       	pop	r29
  78:	08 95       	ret

Disassembly of section .text.prvCheckTasksWaitingTermination:

00000000 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvCheckTasksWaitingTermination+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	80 91 00 00 	lds	r24, 0x0000
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  10:	88 23       	and	r24, r24
  12:	01 f0       	breq	.+0      	; 0x14 <prvCheckTasksWaitingTermination+0x14>
  14:	0e 94 00 00 	call	0	; 0x0 <prvCheckTasksWaitingTermination>
  18:	80 91 00 00 	lds	r24, 0x0000
		vPortFree( pxTCB );
  1c:	1b 82       	std	Y+3, r1	; 0x03
  1e:	88 23       	and	r24, r24
  20:	01 f4       	brne	.+0      	; 0x22 <prvCheckTasksWaitingTermination+0x22>
	}
  22:	81 e0       	ldi	r24, 0x01	; 1
  24:	8b 83       	std	Y+3, r24	; 0x03
  26:	0e 94 00 00 	call	0	; 0x0 <prvCheckTasksWaitingTermination>
  2a:	8b 81       	ldd	r24, Y+3	; 0x03
  2c:	88 23       	and	r24, r24
  2e:	01 f4       	brne	.+0      	; 0x30 <prvCheckTasksWaitingTermination+0x30>
  30:	0f b6       	in	r0, 0x3f	; 63
  32:	f8 94       	cli
  34:	0f 92       	push	r0
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	86 81       	ldd	r24, Z+6	; 0x06
  40:	97 81       	ldd	r25, Z+7	; 0x07
  42:	9a 83       	std	Y+2, r25	; 0x02
  44:	89 83       	std	Y+1, r24	; 0x01
  46:	89 81       	ldd	r24, Y+1	; 0x01
  48:	9a 81       	ldd	r25, Y+2	; 0x02
  4a:	02 96       	adiw	r24, 0x02	; 2
  4c:	0e 94 00 00 	call	0	; 0x0 <prvCheckTasksWaitingTermination>
  50:	80 91 00 00 	lds	r24, 0x0000
  54:	81 50       	subi	r24, 0x01	; 1
  56:	80 93 00 00 	sts	0x0000, r24
  5a:	80 91 00 00 	lds	r24, 0x0000
  5e:	81 50       	subi	r24, 0x01	; 1
  60:	80 93 00 00 	sts	0x0000, r24
  64:	0f 90       	pop	r0
  66:	0f be       	out	0x3f, r0	; 63
  68:	89 81       	ldd	r24, Y+1	; 0x01
  6a:	9a 81       	ldd	r25, Y+2	; 0x02
  6c:	0e 94 00 00 	call	0	; 0x0 <prvCheckTasksWaitingTermination>
  70:	0f 90       	pop	r0
  72:	0f 90       	pop	r0
  74:	0f 90       	pop	r0
  76:	cf 91       	pop	r28
  78:	df 91       	pop	r29
  7a:	08 95       	ret

Disassembly of section .text.prvAddCurrentTaskToDelayedList:

00000000 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvAddCurrentTaskToDelayedList+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	e0 91 00 00 	lds	r30, 0x0000
  12:	f0 91 00 00 	lds	r31, 0x0000
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	9a 81       	ldd	r25, Y+2	; 0x02
		vPortFree( pxTCB );
  1a:	93 83       	std	Z+3, r25	; 0x03
  1c:	82 83       	std	Z+2, r24	; 0x02
  1e:	20 91 00 00 	lds	r18, 0x0000
	}
  22:	30 91 00 00 	lds	r19, 0x0000
  26:	89 81       	ldd	r24, Y+1	; 0x01
  28:	9a 81       	ldd	r25, Y+2	; 0x02
  2a:	82 17       	cp	r24, r18
  2c:	93 07       	cpc	r25, r19
  2e:	00 f4       	brcc	.+0      	; 0x30 <prvAddCurrentTaskToDelayedList+0x30>
  30:	80 91 00 00 	lds	r24, 0x0000
  34:	90 91 00 00 	lds	r25, 0x0000
  38:	20 91 00 00 	lds	r18, 0x0000
  3c:	30 91 00 00 	lds	r19, 0x0000
  40:	2e 5f       	subi	r18, 0xFE	; 254
  42:	3f 4f       	sbci	r19, 0xFF	; 255
  44:	b9 01       	movw	r22, r18
  46:	0e 94 00 00 	call	0	; 0x0 <prvAddCurrentTaskToDelayedList>
  4a:	00 c0       	rjmp	.+0      	; 0x4c <prvAddCurrentTaskToDelayedList+0x4c>
  4c:	40 91 00 00 	lds	r20, 0x0000
  50:	50 91 00 00 	lds	r21, 0x0000
  54:	80 91 00 00 	lds	r24, 0x0000
  58:	90 91 00 00 	lds	r25, 0x0000
  5c:	9c 01       	movw	r18, r24
  5e:	2e 5f       	subi	r18, 0xFE	; 254
  60:	3f 4f       	sbci	r19, 0xFF	; 255
  62:	ca 01       	movw	r24, r20
  64:	b9 01       	movw	r22, r18
  66:	0e 94 00 00 	call	0	; 0x0 <prvAddCurrentTaskToDelayedList>
  6a:	20 91 00 00 	lds	r18, 0x0000
  6e:	30 91 00 00 	lds	r19, 0x0000
  72:	89 81       	ldd	r24, Y+1	; 0x01
  74:	9a 81       	ldd	r25, Y+2	; 0x02
  76:	82 17       	cp	r24, r18
  78:	93 07       	cpc	r25, r19
  7a:	00 f4       	brcc	.+0      	; 0x7c <prvAddCurrentTaskToDelayedList+0x7c>
  7c:	89 81       	ldd	r24, Y+1	; 0x01
  7e:	9a 81       	ldd	r25, Y+2	; 0x02
  80:	90 93 00 00 	sts	0x0000, r25
  84:	80 93 00 00 	sts	0x0000, r24
  88:	0f 90       	pop	r0
  8a:	0f 90       	pop	r0
  8c:	cf 91       	pop	r28
  8e:	df 91       	pop	r29
  90:	08 95       	ret

Disassembly of section .text.prvAllocateTCBAndStack:

00000000 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9c 83       	std	Y+4, r25	; 0x04
  16:	8b 83       	std	Y+3, r24	; 0x03
  18:	7e 83       	std	Y+6, r23	; 0x06
		vPortFree( pxTCB );
  1a:	6d 83       	std	Y+5, r22	; 0x05
  1c:	81 e2       	ldi	r24, 0x21	; 33
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	0e 94 00 00 	call	0	; 0x0 <prvAllocateTCBAndStack>
	}
  24:	9a 83       	std	Y+2, r25	; 0x02
  26:	89 83       	std	Y+1, r24	; 0x01
  28:	89 81       	ldd	r24, Y+1	; 0x01
  2a:	9a 81       	ldd	r25, Y+2	; 0x02
  2c:	00 97       	sbiw	r24, 0x00	; 0
  2e:	01 f0       	breq	.+0      	; 0x30 <prvAllocateTCBAndStack+0x30>
  30:	8d 81       	ldd	r24, Y+5	; 0x05
  32:	9e 81       	ldd	r25, Y+6	; 0x06
  34:	00 97       	sbiw	r24, 0x00	; 0
  36:	01 f4       	brne	.+0      	; 0x38 <prvAllocateTCBAndStack+0x38>
  38:	8b 81       	ldd	r24, Y+3	; 0x03
  3a:	9c 81       	ldd	r25, Y+4	; 0x04
  3c:	0e 94 00 00 	call	0	; 0x0 <prvAllocateTCBAndStack>
  40:	98 87       	std	Y+8, r25	; 0x08
  42:	8f 83       	std	Y+7, r24	; 0x07
  44:	00 c0       	rjmp	.+0      	; 0x46 <prvAllocateTCBAndStack+0x46>
  46:	8d 81       	ldd	r24, Y+5	; 0x05
  48:	9e 81       	ldd	r25, Y+6	; 0x06
  4a:	98 87       	std	Y+8, r25	; 0x08
  4c:	8f 83       	std	Y+7, r24	; 0x07
  4e:	e9 81       	ldd	r30, Y+1	; 0x01
  50:	fa 81       	ldd	r31, Y+2	; 0x02
  52:	8f 81       	ldd	r24, Y+7	; 0x07
  54:	98 85       	ldd	r25, Y+8	; 0x08
  56:	90 8f       	std	Z+24, r25	; 0x18
  58:	87 8b       	std	Z+23, r24	; 0x17
  5a:	e9 81       	ldd	r30, Y+1	; 0x01
  5c:	fa 81       	ldd	r31, Y+2	; 0x02
  5e:	87 89       	ldd	r24, Z+23	; 0x17
  60:	90 8d       	ldd	r25, Z+24	; 0x18
  62:	00 97       	sbiw	r24, 0x00	; 0
  64:	01 f4       	brne	.+0      	; 0x66 <prvAllocateTCBAndStack+0x66>
  66:	89 81       	ldd	r24, Y+1	; 0x01
  68:	9a 81       	ldd	r25, Y+2	; 0x02
  6a:	0e 94 00 00 	call	0	; 0x0 <prvAllocateTCBAndStack>
  6e:	1a 82       	std	Y+2, r1	; 0x02
  70:	19 82       	std	Y+1, r1	; 0x01
  72:	00 c0       	rjmp	.+0      	; 0x74 <prvAllocateTCBAndStack+0x74>
  74:	e9 81       	ldd	r30, Y+1	; 0x01
  76:	fa 81       	ldd	r31, Y+2	; 0x02
  78:	87 89       	ldd	r24, Z+23	; 0x17
  7a:	90 8d       	ldd	r25, Z+24	; 0x18
  7c:	2b 81       	ldd	r18, Y+3	; 0x03
  7e:	3c 81       	ldd	r19, Y+4	; 0x04
  80:	65 ea       	ldi	r22, 0xA5	; 165
  82:	70 e0       	ldi	r23, 0x00	; 0
  84:	a9 01       	movw	r20, r18
  86:	0e 94 00 00 	call	0	; 0x0 <prvAllocateTCBAndStack>
  8a:	89 81       	ldd	r24, Y+1	; 0x01
  8c:	9a 81       	ldd	r25, Y+2	; 0x02
  8e:	28 96       	adiw	r28, 0x08	; 8
  90:	0f b6       	in	r0, 0x3f	; 63
  92:	f8 94       	cli
  94:	de bf       	out	0x3e, r29	; 62
  96:	0f be       	out	0x3f, r0	; 63
  98:	cd bf       	out	0x3d, r28	; 61
  9a:	cf 91       	pop	r28
  9c:	df 91       	pop	r29
  9e:	08 95       	ret

Disassembly of section .text.prvDeleteTCB:

00000000 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <prvDeleteTCB+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   e:	e9 81       	ldd	r30, Y+1	; 0x01
  10:	fa 81       	ldd	r31, Y+2	; 0x02
  12:	87 89       	ldd	r24, Z+23	; 0x17
  14:	90 8d       	ldd	r25, Z+24	; 0x18
  16:	0e 94 00 00 	call	0	; 0x0 <prvDeleteTCB>
		vPortFree( pxTCB );
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	9a 81       	ldd	r25, Y+2	; 0x02
  1e:	0e 94 00 00 	call	0	; 0x0 <prvDeleteTCB>
	}
  22:	0f 90       	pop	r0
  24:	0f 90       	pop	r0
  26:	cf 91       	pop	r28
  28:	df 91       	pop	r29
  2a:	08 95       	ret

timers.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000004c8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000c94  00000000  00000000  000004fc  2**0
                  CONTENTS, READONLY, DEBUGGING
